var ZE=Object.defineProperty,JE=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(t,n)=>(typeof require<"u"?require:t)[n]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')}),eg=(e,t)=>{for(var n in t)ZE(e,n,{get:t[n],enumerable:!0})},YE={};eg(YE,{Abs:()=>pl,Acos:()=>Qs,Acosh:()=>ei,AdadeltaOptimizer:()=>vy,AdagradOptimizer:()=>wy,AdamOptimizer:()=>ky,AdamaxOptimizer:()=>Iy,Add:()=>Ya,AddN:()=>ti,All:()=>dl,Any:()=>hl,ArgMax:()=>cl,ArgMin:()=>fl,Asin:()=>ni,Asinh:()=>ri,Atan:()=>ai,Atan2:()=>ii,Atanh:()=>si,AvgPool:()=>oi,AvgPool3D:()=>ml,AvgPool3DGrad:()=>Sp,AvgPoolGrad:()=>Ip,BackendWasm:()=>E_,BatchMatMul:()=>li,BatchToSpaceND:()=>gl,Bincount:()=>yl,BitwiseAnd:()=>bl,BroadcastArgs:()=>Np,BroadcastTo:()=>M0,Callback:()=>_S,CallbackList:()=>wI,Cast:()=>ui,Ceil:()=>pi,ClipByValue:()=>Qa,Complex:()=>Xh,ComplexAbs:()=>Tp,Concat:()=>xl,Conv2D:()=>di,Conv2DBackpropFilter:()=>Zh,Conv2DBackpropInput:()=>hi,Conv3D:()=>ci,Conv3DBackpropFilterV2:()=>vl,Conv3DBackpropInputV2:()=>wl,Cos:()=>fi,Cosh:()=>mi,CropAndResize:()=>Il,Cumprod:()=>kl,Cumsum:()=>gi,CustomCallback:()=>II,DataStorage:()=>jh,DenseBincount:()=>Cp,DepthToSpace:()=>Sl,DepthwiseConv2dNative:()=>yi,DepthwiseConv2dNativeBackpropFilter:()=>Jh,DepthwiseConv2dNativeBackpropInput:()=>Yh,Diag:()=>_p,Dilation2D:()=>bi,Dilation2DBackpropFilter:()=>qo,Dilation2DBackpropInput:()=>jo,Draw:()=>Qh,ENV:()=>sg,EarlyStopping:()=>ES,Einsum:()=>ec,Elu:()=>vi,EluGrad:()=>Nl,Environment:()=>R0,Equal:()=>Tl,Erf:()=>wi,Exp:()=>ki,ExpandDims:()=>Cl,Expm1:()=>Ii,FFT:()=>tc,Fill:()=>Ep,FlipLeftRight:()=>_l,Floor:()=>Si,FloorDiv:()=>Ni,FromPixels:()=>gh,FusedBatchNorm:()=>Ti,FusedConv2D:()=>Rs,FusedDepthwiseConv2D:()=>Ds,GPGPUContext:()=>dh,GatherNd:()=>$l,GatherV2:()=>El,GraphModel:()=>ux,Greater:()=>Al,GreaterEqual:()=>Ci,History:()=>kI,IFFT:()=>nc,Identity:()=>_i,Imag:()=>rc,InputSpec:()=>Et,IsFinite:()=>Ei,IsInf:()=>$i,IsNan:()=>Ai,KernelBackend:()=>wp,LRN:()=>Mi,LRNGrad:()=>zl,LayerVariable:()=>cI,LayersModel:()=>ia,LeakyRelu:()=>Fi,Less:()=>Fl,LessEqual:()=>Rl,LinSpace:()=>Dl,Log:()=>Ri,Log1p:()=>Di,LogSoftmax:()=>L0,LogicalAnd:()=>Ml,LogicalNot:()=>Ol,LogicalOr:()=>Ll,LogicalXor:()=>O0,LowerBound:()=>U$,MathBackendCPU:()=>hx,MathBackendWebGL:()=>Bx,MatrixBandPart:()=>G$,Max:()=>Oi,MaxPool:()=>zi,MaxPool3D:()=>Pl,MaxPool3DGrad:()=>Ap,MaxPoolGrad:()=>$p,MaxPoolWithArgmax:()=>Fp,Maximum:()=>Li,Mean:()=>Pi,Min:()=>Bi,Minimum:()=>Wi,MirrorPad:()=>Vi,Mod:()=>Ui,MomentumOptimizer:()=>Sy,Multinomial:()=>Bl,Multiply:()=>Gi,Neg:()=>Wl,NonMaxSuppressionV3:()=>Ul,NonMaxSuppressionV4:()=>Gl,NonMaxSuppressionV5:()=>Hl,NotEqual:()=>Vl,OP_SCOPE_SUFFIX:()=>pg,OneHot:()=>Hi,OnesLike:()=>jl,Optimizer:()=>ma,OptimizerConstructors:()=>jk,Pack:()=>ql,PadV2:()=>ji,Pool:()=>H$,Pow:()=>qi,Prelu:()=>Ki,Prod:()=>Xi,RMSPropOptimizer:()=>Ny,RNN:()=>ga,RaggedGather:()=>ac,RaggedRange:()=>sc,RaggedTensorToTensor:()=>ic,Range:()=>Rp,Rank:()=>Xf,Real:()=>oc,RealDiv:()=>xi,Reciprocal:()=>Zi,Reduction:()=>dn,Relu:()=>Ji,Relu6:()=>eo,Reshape:()=>Kl,ResizeBilinear:()=>Qi,ResizeBilinearGrad:()=>Zl,ResizeNearestNeighbor:()=>Yi,ResizeNearestNeighborGrad:()=>Xl,Reverse:()=>to,RotateWithOffset:()=>du,Round:()=>no,Rsqrt:()=>ro,SGDOptimizer:()=>Uc,ScatterNd:()=>Jl,SearchSorted:()=>Ql,Select:()=>eu,Selu:()=>ao,Sequential:()=>nf,Sigmoid:()=>lo,Sign:()=>oo,Sin:()=>so,Sinh:()=>io,Slice:()=>tu,Softmax:()=>co,Softplus:()=>uo,SpaceToBatchND:()=>nu,SparseFillEmptyRows:()=>Dp,SparseReshape:()=>au,SparseSegmentMean:()=>Mp,SparseSegmentSum:()=>Op,SparseToDense:()=>su,SplitV:()=>ru,Sqrt:()=>po,Square:()=>Lp,SquaredDifference:()=>fo,StaticRegexReplace:()=>zp,Step:()=>ts,StridedSlice:()=>iu,StringNGrams:()=>Pp,StringSplit:()=>Bp,StringToHashBucketFast:()=>Wp,Sub:()=>mo,Sum:()=>ho,SymbolicTensor:()=>Nr,Tan:()=>go,Tanh:()=>yo,Tensor:()=>Fe,TensorBuffer:()=>$t,TensorScatterUpdate:()=>Yl,Tile:()=>es,TopK:()=>ou,Transform:()=>lu,Transpose:()=>sa,Unique:()=>Vp,Unpack:()=>uu,UnsortedSegmentSum:()=>Up,UpperBound:()=>j$,Variable:()=>Ms,ZerosLike:()=>pu,_FusedMatMul:()=>Fs,abs:()=>_t,acos:()=>mg,acosh:()=>gg,add:()=>X,addN:()=>d1,all:()=>hc,any:()=>lp,argMax:()=>Ps,argMin:()=>yg,asin:()=>bg,asinh:()=>xg,atan:()=>vg,atan2:()=>wg,atanh:()=>kg,avgPool:()=>ha,avgPool3d:()=>Sg,backend:()=>dg,backend_util:()=>N,basicLSTMCell:()=>m1,batchNorm:()=>bo,batchNorm2d:()=>Ng,batchNorm3d:()=>Tg,batchNorm4d:()=>Cg,batchToSpaceND:()=>Zp,bincount:()=>_g,bitwiseAnd:()=>g1,booleanMaskAsync:()=>sk,broadcastArgs:()=>y1,broadcastTo:()=>_s,broadcast_util:()=>hu,browser:()=>ud,buffer:()=>ze,callbacks:()=>WU,cast:()=>se,ceil:()=>Eg,clipByValue:()=>an,clone:()=>Br,complex:()=>la,concat:()=>it,concat1d:()=>$g,concat2d:()=>Ag,concat3d:()=>Fg,concat4d:()=>Rg,constraints:()=>yI,conv1d:()=>cc,conv2d:()=>fn,conv2dTranspose:()=>fc,conv3d:()=>Mg,conv3dTranspose:()=>Og,copyRegisteredKernels:()=>Z$,cos:()=>Jp,cosh:()=>mc,cosineWindow:()=>zc,cumprod:()=>dp,cumsum:()=>gc,customGrad:()=>Hr,data:()=>QS,denseBincount:()=>xh,deprecationWarn:()=>J0,depthToSpace:()=>Lg,depthwiseConv2d:()=>xo,deregisterOp:()=>GU,device_util:()=>qp,diag:()=>x1,dilation2d:()=>zg,disableDeprecationWarnings:()=>TA,dispose:()=>_e,disposeVariables:()=>CA,div:()=>fe,divNoNan:()=>Pg,dot:()=>Bg,dropout:()=>my,einsum:()=>ks,elu:()=>cu,enableDebugMode:()=>NA,enableProdMode:()=>SA,enclosingPowerOfTwo:()=>gy,engine:()=>lr,ensureShape:()=>w1,env:()=>G,equal:()=>Wn,erf:()=>yc,euclideanNorm:()=>Ug,exp:()=>sn,expandDims:()=>Ht,expm1:()=>Gg,eye:()=>bc,fft:()=>od,fill:()=>Bn,findBackend:()=>RA,findBackendFactory:()=>DA,floor:()=>mu,floorDiv:()=>dc,forceHalfFloat:()=>IT,fused:()=>tl,gather:()=>gu,gatherND:()=>uk,gather_util:()=>_y,getBackend:()=>Y0,getGradient:()=>qf,getKernel:()=>sp,getKernelsForBackend:()=>yh,getThreadsCount:()=>Kpe,gpgpu_util:()=>eT,grad:()=>hD,grads:()=>cD,greater:()=>xn,greaterEqual:()=>ca,ifft:()=>el,imag:()=>Yp,image:()=>Zn,inTopKAsync:()=>pk,initializers:()=>bI,input:()=>LI,io:()=>nn,irfft:()=>Ac,isFinite:()=>Hg,isInf:()=>jg,isNaN:()=>qg,keep:()=>Mt,kernel_impls:()=>Xr,layers:()=>xI,leakyRelu:()=>Qp,less:()=>Zo,lessEqual:()=>rs,linalg:()=>xy,linspace:()=>T1,loadGraphModel:()=>ZG,loadGraphModelSync:()=>JG,loadLayersModel:()=>O4,localResponseNormalization:()=>Kg,log:()=>Vn,log1p:()=>ed,logSigmoid:()=>Xg,logSoftmax:()=>vc,logSumExp:()=>td,logicalAnd:()=>dr,logicalNot:()=>nd,logicalOr:()=>wc,logicalXor:()=>Zg,losses:()=>kk,lowerBound:()=>_1,matMul:()=>Oe,math:()=>Rk,max:()=>er,maxPool:()=>Vt,maxPool3d:()=>Jg,maxPoolWithArgmax:()=>E1,maximum:()=>Kr,mean:()=>xt,memory:()=>nm,meshgrid:()=>$1,metrics:()=>NS,min:()=>Xo,minimum:()=>Va,mirrorPad:()=>Yg,mod:()=>Qg,model:()=>P4,models:()=>TS,moments:()=>rd,movingAverage:()=>ik,mul:()=>z,multiRNNCell:()=>A1,multinomial:()=>F1,neg:()=>ct,nextFrame:()=>Ey,norm:()=>fu,notEqual:()=>Vs,oneHot:()=>Jo,ones:()=>Nn,onesLike:()=>Un,op:()=>L,outerProduct:()=>R1,pad:()=>_r,pad1d:()=>D1,pad2d:()=>M1,pad3d:()=>O1,pad4d:()=>L1,pool:()=>ey,pow:()=>Gr,prelu:()=>sd,print:()=>fg,prod:()=>ty,profile:()=>_A,raggedGather:()=>z1,raggedRange:()=>P1,raggedTensorToTensor:()=>B1,rand:()=>W1,randomGamma:()=>H1,randomNormal:()=>Ic,randomStandardNormal:()=>j1,randomUniform:()=>as,randomUniformInt:()=>q1,range:()=>Us,ready:()=>AA,real:()=>Yo,reciprocal:()=>iy,registerBackend:()=>pc,registerCallbackConstructor:()=>W4,registerGradient:()=>z0,registerKernel:()=>Gp,registerOp:()=>UU,regularizers:()=>CS,relu:()=>et,relu6:()=>Sc,removeBackend:()=>FA,reshape:()=>P,reverse:()=>rr,reverse1d:()=>K1,reverse2d:()=>X1,reverse3d:()=>Z1,reverse4d:()=>J1,rfft:()=>ld,round:()=>Nc,rsqrt:()=>Tc,scalar:()=>we,scatterND:()=>ok,scatter_util:()=>Dc,searchSorted:()=>kc,selu:()=>Cc,separableConv2d:()=>yu,sequential:()=>B4,serialization:()=>ne,setBackend:()=>$A,setPlatform:()=>MA,setThreadsCount:()=>qpe,setWasmPath:()=>Hpe,setWasmPaths:()=>jpe,setWebGLContext:()=>S2,setdiff1dAsync:()=>Y1,shared:()=>cx,sigmoid:()=>pr,sign:()=>oy,signal:()=>wk,sin:()=>_c,sinh:()=>Ec,slice:()=>Ue,slice1d:()=>id,slice2d:()=>$c,slice3d:()=>bu,slice4d:()=>Qo,slice_util:()=>Lt,softmax:()=>ss,softplus:()=>vo,spaceToBatchND:()=>ad,sparse:()=>Ik,sparseToDense:()=>lk,spectral:()=>vk,split:()=>Tn,sqrt:()=>Kt,square:()=>st,squaredDifference:()=>Fc,squeeze:()=>is,stack:()=>At,step:()=>wo,stridedSlice:()=>ly,string:()=>Sk,sub:()=>de,sum:()=>ge,sumOutType:()=>uc,tan:()=>uy,tanh:()=>Wa,tensor:()=>cn,tensor1d:()=>Ye,tensor2d:()=>Wr,tensor3d:()=>Rc,tensor4d:()=>Ua,tensor5d:()=>Q1,tensor6d:()=>ek,tensorScatterUpdate:()=>nk,tensor_util:()=>xr,test_util:()=>V1,tidy:()=>B,tile:()=>Pn,time:()=>EA,topk:()=>dy,train:()=>xs,transpose:()=>Le,truncatedNormal:()=>Oc,unique:()=>hy,unregisterGradient:()=>X$,unregisterKernel:()=>K$,unsortedSegmentSum:()=>Lc,unstack:()=>St,upcastType:()=>tr,upperBound:()=>rk,util:()=>w,valueAndGrad:()=>fD,valueAndGrads:()=>mD,variable:()=>cy,variableGrads:()=>C1,version:()=>tde,version_converter:()=>QG,version_core:()=>PL,version_cpu:()=>ej,version_layers:()=>Yy,version_wasm:()=>Xpe,version_webgl:()=>UZ,webgl:()=>GZ,webgl_util:()=>I2,where:()=>qt,whereAsync:()=>fy,zeros:()=>vt,zerosLike:()=>He});var QE=Object.create,tg=Object.defineProperty,e$=Object.getOwnPropertyDescriptor,t$=Object.getOwnPropertyNames,n$=Object.getPrototypeOf,r$=Object.prototype.hasOwnProperty,Rt=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),Ee=(e,t)=>{for(var n in t)tg(e,n,{get:t[n],enumerable:!0})},a$=(e,t,n,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let a of t$(t))!r$.call(e,a)&&a!==n&&tg(e,a,{get:()=>t[a],enumerable:!(r=e$(t,a))||r.enumerable});return e},Ja=(e,t,n)=>(n=e!=null?QE(n$(e)):{},a$(!e||!e.__esModule?tg(n,"default",{value:e,enumerable:!0}):n,e)),s$=Rt((e,t)=>{t.exports=r;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function r(S,M,W){this.low=S|0,this.high=M|0,this.unsigned=!!W}r.prototype.__isLong__,Object.defineProperty(r.prototype,"__isLong__",{value:!0});function a(S){return(S&&S.__isLong__)===!0}r.isLong=a;var s={},i={};function o(S,M){var W,U,H;return M?(S>>>=0,(H=0<=S&&S<256)&&(U=i[S],U)?U:(W=p(S,(S|0)<0?-1:0,!0),H&&(i[S]=W),W)):(S|=0,(H=-128<=S&&S<128)&&(U=s[S],U)?U:(W=p(S,S<0?-1:0,!1),H&&(s[S]=W),W))}r.fromInt=o;function l(S,M){if(isNaN(S))return M?v:x;if(M){if(S<0)return v;if(S>=g)return A}else{if(S<=-9223372036854776e3)return R;if(S+1>=y)return E}return S<0?l(-S,M).neg():p(S%m|0,S/m|0,M)}r.fromNumber=l;function p(S,M,W){return new r(S,M,W)}r.fromBits=p;var u=Math.pow;function d(S,M,W){if(S.length===0)throw Error("empty string");if(S==="NaN"||S==="Infinity"||S==="+Infinity"||S==="-Infinity")return x;if(typeof M=="number"?(W=M,M=!1):M=!!M,W=W||10,W<2||36<W)throw RangeError("radix");var U;if((U=S.indexOf("-"))>0)throw Error("interior hyphen");if(U===0)return d(S.substring(1),M,W).neg();for(var H=l(u(W,8)),K=x,j=0;j<S.length;j+=8){var Z=Math.min(8,S.length-j),ee=parseInt(S.substring(j,j+Z),W);if(Z<8){var Y=l(u(W,Z));K=K.mul(Y).add(l(ee))}else K=K.mul(H),K=K.add(l(ee))}return K.unsigned=M,K}r.fromString=d;function h(S,M){return typeof S=="number"?l(S,M):typeof S=="string"?d(S,M):p(S.low,S.high,typeof M=="boolean"?M:S.unsigned)}r.fromValue=h;var c=65536,f=1<<24,m=c*c,g=m*m,y=g/2,b=o(f),x=o(0);r.ZERO=x;var v=o(0,!0);r.UZERO=v;var I=o(1);r.ONE=I;var T=o(1,!0);r.UONE=T;var _=o(-1);r.NEG_ONE=_;var E=p(-1,2147483647,!1);r.MAX_VALUE=E;var A=p(-1,-1,!0);r.MAX_UNSIGNED_VALUE=A;var R=p(0,-2147483648,!1);r.MIN_VALUE=R;var F=r.prototype;F.toInt=function(){return this.unsigned?this.low>>>0:this.low},F.toNumber=function(){return this.unsigned?(this.high>>>0)*m+(this.low>>>0):this.high*m+(this.low>>>0)},F.toString=function(S){if(S=S||10,S<2||36<S)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(R)){var M=l(S),W=this.div(M),U=W.mul(M).sub(this);return W.toString(S)+U.toInt().toString(S)}else return"-"+this.neg().toString(S);for(var H=l(u(S,6),this.unsigned),K=this,j="";;){var Z=K.div(H),ee=K.sub(Z.mul(H)).toInt()>>>0,Y=ee.toString(S);if(K=Z,K.isZero())return Y+j;for(;Y.length<6;)Y="0"+Y;j=""+Y+j}},F.getHighBits=function(){return this.high},F.getHighBitsUnsigned=function(){return this.high>>>0},F.getLowBits=function(){return this.low},F.getLowBitsUnsigned=function(){return this.low>>>0},F.getNumBitsAbs=function(){if(this.isNegative())return this.eq(R)?64:this.neg().getNumBitsAbs();for(var S=this.high!=0?this.high:this.low,M=31;M>0&&!(S&1<<M);M--);return this.high!=0?M+33:M+1},F.isZero=function(){return this.high===0&&this.low===0},F.eqz=F.isZero,F.isNegative=function(){return!this.unsigned&&this.high<0},F.isPositive=function(){return this.unsigned||this.high>=0},F.isOdd=function(){return(this.low&1)===1},F.isEven=function(){return(this.low&1)===0},F.equals=function(S){return a(S)||(S=h(S)),this.unsigned!==S.unsigned&&this.high>>>31===1&&S.high>>>31===1?!1:this.high===S.high&&this.low===S.low},F.eq=F.equals,F.notEquals=function(S){return!this.eq(S)},F.neq=F.notEquals,F.ne=F.notEquals,F.lessThan=function(S){return this.comp(S)<0},F.lt=F.lessThan,F.lessThanOrEqual=function(S){return this.comp(S)<=0},F.lte=F.lessThanOrEqual,F.le=F.lessThanOrEqual,F.greaterThan=function(S){return this.comp(S)>0},F.gt=F.greaterThan,F.greaterThanOrEqual=function(S){return this.comp(S)>=0},F.gte=F.greaterThanOrEqual,F.ge=F.greaterThanOrEqual,F.compare=function(S){if(a(S)||(S=h(S)),this.eq(S))return 0;var M=this.isNegative(),W=S.isNegative();return M&&!W?-1:!M&&W?1:this.unsigned?S.high>>>0>this.high>>>0||S.high===this.high&&S.low>>>0>this.low>>>0?-1:1:this.sub(S).isNegative()?-1:1},F.comp=F.compare,F.negate=function(){return!this.unsigned&&this.eq(R)?R:this.not().add(I)},F.neg=F.negate,F.add=function(S){a(S)||(S=h(S));var M=this.high>>>16,W=this.high&65535,U=this.low>>>16,H=this.low&65535,K=S.high>>>16,j=S.high&65535,Z=S.low>>>16,ee=S.low&65535,Y=0,re=0,te=0,ae=0;return ae+=H+ee,te+=ae>>>16,ae&=65535,te+=U+Z,re+=te>>>16,te&=65535,re+=W+j,Y+=re>>>16,re&=65535,Y+=M+K,Y&=65535,p(te<<16|ae,Y<<16|re,this.unsigned)},F.subtract=function(S){return a(S)||(S=h(S)),this.add(S.neg())},F.sub=F.subtract,F.multiply=function(S){if(this.isZero())return x;if(a(S)||(S=h(S)),n){var M=n.mul(this.low,this.high,S.low,S.high);return p(M,n.get_high(),this.unsigned)}if(S.isZero())return x;if(this.eq(R))return S.isOdd()?R:x;if(S.eq(R))return this.isOdd()?R:x;if(this.isNegative())return S.isNegative()?this.neg().mul(S.neg()):this.neg().mul(S).neg();if(S.isNegative())return this.mul(S.neg()).neg();if(this.lt(b)&&S.lt(b))return l(this.toNumber()*S.toNumber(),this.unsigned);var W=this.high>>>16,U=this.high&65535,H=this.low>>>16,K=this.low&65535,j=S.high>>>16,Z=S.high&65535,ee=S.low>>>16,Y=S.low&65535,re=0,te=0,ae=0,ie=0;return ie+=K*Y,ae+=ie>>>16,ie&=65535,ae+=H*Y,te+=ae>>>16,ae&=65535,ae+=K*ee,te+=ae>>>16,ae&=65535,te+=U*Y,re+=te>>>16,te&=65535,te+=H*ee,re+=te>>>16,te&=65535,te+=K*Z,re+=te>>>16,te&=65535,re+=W*Y+U*ee+H*Z+K*j,re&=65535,p(ae<<16|ie,re<<16|te,this.unsigned)},F.mul=F.multiply,F.divide=function(S){if(a(S)||(S=h(S)),S.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&S.low===-1&&S.high===-1)return this;var M=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,S.low,S.high);return p(M,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?v:x;var W,U,H;if(this.unsigned){if(S.unsigned||(S=S.toUnsigned()),S.gt(this))return v;if(S.gt(this.shru(1)))return T;H=v}else{if(this.eq(R)){if(S.eq(I)||S.eq(_))return R;if(S.eq(R))return I;var K=this.shr(1);return W=K.div(S).shl(1),W.eq(x)?S.isNegative()?I:_:(U=this.sub(S.mul(W)),H=W.add(U.div(S)),H)}else if(S.eq(R))return this.unsigned?v:x;if(this.isNegative())return S.isNegative()?this.neg().div(S.neg()):this.neg().div(S).neg();if(S.isNegative())return this.div(S.neg()).neg();H=x}for(U=this;U.gte(S);){W=Math.max(1,Math.floor(U.toNumber()/S.toNumber()));for(var j=Math.ceil(Math.log(W)/Math.LN2),Z=j<=48?1:u(2,j-48),ee=l(W),Y=ee.mul(S);Y.isNegative()||Y.gt(U);)W-=Z,ee=l(W,this.unsigned),Y=ee.mul(S);ee.isZero()&&(ee=I),H=H.add(ee),U=U.sub(Y)}return H},F.div=F.divide,F.modulo=function(S){if(a(S)||(S=h(S)),n){var M=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,S.low,S.high);return p(M,n.get_high(),this.unsigned)}return this.sub(this.div(S).mul(S))},F.mod=F.modulo,F.rem=F.modulo,F.not=function(){return p(~this.low,~this.high,this.unsigned)},F.and=function(S){return a(S)||(S=h(S)),p(this.low&S.low,this.high&S.high,this.unsigned)},F.or=function(S){return a(S)||(S=h(S)),p(this.low|S.low,this.high|S.high,this.unsigned)},F.xor=function(S){return a(S)||(S=h(S)),p(this.low^S.low,this.high^S.high,this.unsigned)},F.shiftLeft=function(S){return a(S)&&(S=S.toInt()),(S&=63)===0?this:S<32?p(this.low<<S,this.high<<S|this.low>>>32-S,this.unsigned):p(0,this.low<<S-32,this.unsigned)},F.shl=F.shiftLeft,F.shiftRight=function(S){return a(S)&&(S=S.toInt()),(S&=63)===0?this:S<32?p(this.low>>>S|this.high<<32-S,this.high>>S,this.unsigned):p(this.high>>S-32,this.high>=0?0:-1,this.unsigned)},F.shr=F.shiftRight,F.shiftRightUnsigned=function(S){if(a(S)&&(S=S.toInt()),S&=63,S===0)return this;var M=this.high;if(S<32){var W=this.low;return p(W>>>S|M<<32-S,M>>>S,this.unsigned)}else return S===32?p(M,0,this.unsigned):p(M>>>S-32,0,this.unsigned)},F.shru=F.shiftRightUnsigned,F.shr_u=F.shiftRightUnsigned,F.toSigned=function(){return this.unsigned?p(this.low,this.high,!1):this},F.toUnsigned=function(){return this.unsigned?this:p(this.low,this.high,!0)},F.toBytes=function(S){return S?this.toBytesLE():this.toBytesBE()},F.toBytesLE=function(){var S=this.high,M=this.low;return[M&255,M>>>8&255,M>>>16&255,M>>>24,S&255,S>>>8&255,S>>>16&255,S>>>24]},F.toBytesBE=function(){var S=this.high,M=this.low;return[S>>>24,S>>>16&255,S>>>8&255,S&255,M>>>24,M>>>16&255,M>>>8&255,M&255]},r.fromBytes=function(S,M,W){return W?r.fromBytesLE(S,M):r.fromBytesBE(S,M)},r.fromBytesLE=function(S,M){return new r(S[0]|S[1]<<8|S[2]<<16|S[3]<<24,S[4]|S[5]<<8|S[6]<<16|S[7]<<24,M)},r.fromBytesBE=function(S,M){return new r(S[4]<<24|S[5]<<16|S[6]<<8|S[7],S[0]<<24|S[1]<<16|S[2]<<8|S[3],M)}}),i$=Rt(()=>{}),o$=Rt(()=>{}),l$=Rt((e,t)=>{(function(n,r,a){function s(p){var u=this,d=l();u.next=function(){var h=2091639*u.s0+u.c*23283064365386963e-26;return u.s0=u.s1,u.s1=u.s2,u.s2=h-(u.c=h|0)},u.c=1,u.s0=d(" "),u.s1=d(" "),u.s2=d(" "),u.s0-=d(p),u.s0<0&&(u.s0+=1),u.s1-=d(p),u.s1<0&&(u.s1+=1),u.s2-=d(p),u.s2<0&&(u.s2+=1),d=null}function i(p,u){return u.c=p.c,u.s0=p.s0,u.s1=p.s1,u.s2=p.s2,u}function o(p,u){var d=new s(p),h=u&&u.state,c=d.next;return c.int32=function(){return d.next()*4294967296|0},c.double=function(){return c()+(c()*2097152|0)*11102230246251565e-32},c.quick=c,h&&(typeof h=="object"&&i(h,d),c.state=function(){return i(d,{})}),c}function l(){var p=4022871197,u=function(d){d=String(d);for(var h=0;h<d.length;h++){p+=d.charCodeAt(h);var c=.02519603282416938*p;p=c>>>0,c-=p,c*=p,p=c>>>0,c-=p,p+=c*4294967296}return(p>>>0)*23283064365386963e-26};return u}r&&r.exports?r.exports=o:a&&a.amd?a(function(){return o}):this.alea=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),u$=Rt((e,t)=>{(function(n,r,a){function s(l){var p=this,u="";p.x=0,p.y=0,p.z=0,p.w=0,p.next=function(){var h=p.x^p.x<<11;return p.x=p.y,p.y=p.z,p.z=p.w,p.w^=p.w>>>19^h^h>>>8},l===(l|0)?p.x=l:u+=l;for(var d=0;d<u.length+64;d++)p.x^=u.charCodeAt(d)|0,p.next()}function i(l,p){return p.x=l.x,p.y=l.y,p.z=l.z,p.w=l.w,p}function o(l,p){var u=new s(l),d=p&&p.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var c=u.next()>>>11,f=(u.next()>>>0)/4294967296,m=(c+f)/(1<<21);while(m===0);return m},h.int32=u.next,h.quick=h,d&&(typeof d=="object"&&i(d,u),h.state=function(){return i(u,{})}),h}r&&r.exports?r.exports=o:a&&a.amd?a(function(){return o}):this.xor128=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),p$=Rt((e,t)=>{(function(n,r,a){function s(l){var p=this,u="";p.next=function(){var h=p.x^p.x>>>2;return p.x=p.y,p.y=p.z,p.z=p.w,p.w=p.v,(p.d=p.d+362437|0)+(p.v=p.v^p.v<<4^(h^h<<1))|0},p.x=0,p.y=0,p.z=0,p.w=0,p.v=0,l===(l|0)?p.x=l:u+=l;for(var d=0;d<u.length+64;d++)p.x^=u.charCodeAt(d)|0,d==u.length&&(p.d=p.x<<10^p.x>>>4),p.next()}function i(l,p){return p.x=l.x,p.y=l.y,p.z=l.z,p.w=l.w,p.v=l.v,p.d=l.d,p}function o(l,p){var u=new s(l),d=p&&p.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var c=u.next()>>>11,f=(u.next()>>>0)/4294967296,m=(c+f)/(1<<21);while(m===0);return m},h.int32=u.next,h.quick=h,d&&(typeof d=="object"&&i(d,u),h.state=function(){return i(u,{})}),h}r&&r.exports?r.exports=o:a&&a.amd?a(function(){return o}):this.xorwow=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),d$=Rt((e,t)=>{(function(n,r,a){function s(l){var p=this;p.next=function(){var d=p.x,h=p.i,c,f;return c=d[h],c^=c>>>7,f=c^c<<24,c=d[h+1&7],f^=c^c>>>10,c=d[h+3&7],f^=c^c>>>3,c=d[h+4&7],f^=c^c<<7,c=d[h+7&7],c=c^c<<13,f^=c^c<<9,d[h]=f,p.i=h+1&7,f};function u(d,h){var c,f=[];if(h===(h|0))f[0]=h;else for(h=""+h,c=0;c<h.length;++c)f[c&7]=f[c&7]<<15^h.charCodeAt(c)+f[c+1&7]<<13;for(;f.length<8;)f.push(0);for(c=0;c<8&&f[c]===0;++c);for(c==8?f[7]=-1:f[c],d.x=f,d.i=0,c=256;c>0;--c)d.next()}u(p,l)}function i(l,p){return p.x=l.x.slice(),p.i=l.i,p}function o(l,p){l==null&&(l=+new Date);var u=new s(l),d=p&&p.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var c=u.next()>>>11,f=(u.next()>>>0)/4294967296,m=(c+f)/(1<<21);while(m===0);return m},h.int32=u.next,h.quick=h,d&&(d.x&&i(d,u),h.state=function(){return i(u,{})}),h}r&&r.exports?r.exports=o:a&&a.amd?a(function(){return o}):this.xorshift7=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),h$=Rt((e,t)=>{(function(n,r,a){function s(l){var p=this;p.next=function(){var d=p.w,h=p.X,c=p.i,f,m;return p.w=d=d+1640531527|0,m=h[c+34&127],f=h[c=c+1&127],m^=m<<13,f^=f<<17,m^=m>>>15,f^=f>>>12,m=h[c]=m^f,p.i=c,m+(d^d>>>16)|0};function u(d,h){var c,f,m,g,y,b=[],x=128;for(h===(h|0)?(f=h,h=null):(h=h+"\0",f=0,x=Math.max(x,h.length)),m=0,g=-32;g<x;++g)h&&(f^=h.charCodeAt((g+32)%h.length)),g===0&&(y=f),f^=f<<10,f^=f>>>15,f^=f<<4,f^=f>>>13,g>=0&&(y=y+1640531527|0,c=b[g&127]^=f+y,m=c==0?m+1:0);for(m>=128&&(b[(h&&h.length||0)&127]=-1),m=127,g=4*128;g>0;--g)f=b[m+34&127],c=b[m=m+1&127],f^=f<<13,c^=c<<17,f^=f>>>15,c^=c>>>12,b[m]=f^c;d.w=y,d.X=b,d.i=m}u(p,l)}function i(l,p){return p.i=l.i,p.w=l.w,p.X=l.X.slice(),p}function o(l,p){l==null&&(l=+new Date);var u=new s(l),d=p&&p.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var c=u.next()>>>11,f=(u.next()>>>0)/4294967296,m=(c+f)/(1<<21);while(m===0);return m},h.int32=u.next,h.quick=h,d&&(d.X&&i(d,u),h.state=function(){return i(u,{})}),h}r&&r.exports?r.exports=o:a&&a.amd?a(function(){return o}):this.xor4096=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),c$=Rt((e,t)=>{(function(n,r,a){function s(l){var p=this,u="";p.next=function(){var h=p.b,c=p.c,f=p.d,m=p.a;return h=h<<25^h>>>7^c,c=c-f|0,f=f<<24^f>>>8^m,m=m-h|0,p.b=h=h<<20^h>>>12^c,p.c=c=c-f|0,p.d=f<<16^c>>>16^m,p.a=m-h|0},p.a=0,p.b=0,p.c=-1640531527,p.d=1367130551,l===Math.floor(l)?(p.a=l/4294967296|0,p.b=l|0):u+=l;for(var d=0;d<u.length+20;d++)p.b^=u.charCodeAt(d)|0,p.next()}function i(l,p){return p.a=l.a,p.b=l.b,p.c=l.c,p.d=l.d,p}function o(l,p){var u=new s(l),d=p&&p.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var c=u.next()>>>11,f=(u.next()>>>0)/4294967296,m=(c+f)/(1<<21);while(m===0);return m},h.int32=u.next,h.quick=h,d&&(typeof d=="object"&&i(d,u),h.state=function(){return i(u,{})}),h}r&&r.exports?r.exports=o:a&&a.amd?a(function(){return o}):this.tychei=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),f$=Rt(()=>{}),m$=Rt((e,t)=>{(function(n,r,a){var s=256,i=6,o=52,l="random",p=a.pow(s,i),u=a.pow(2,o),d=u*2,h=s-1,c;function f(I,T,_){var E=[];T=T==!0?{entropy:!0}:T||{};var A=b(y(T.entropy?[I,v(r)]:I??x(),3),E),R=new m(E),F=function(){for(var S=R.g(i),M=p,W=0;S<u;)S=(S+W)*s,M*=s,W=R.g(1);for(;S>=d;)S/=2,M/=2,W>>>=1;return(S+W)/M};return F.int32=function(){return R.g(4)|0},F.quick=function(){return R.g(4)/4294967296},F.double=F,b(v(R.S),r),(T.pass||_||function(S,M,W,U){return U&&(U.S&&g(U,R),S.state=function(){return g(R,{})}),W?(a[l]=S,M):S})(F,A,"global"in T?T.global:this==a,T.state)}function m(I){var T,_=I.length,E=this,A=0,R=E.i=E.j=0,F=E.S=[];for(_||(I=[_++]);A<s;)F[A]=A++;for(A=0;A<s;A++)F[A]=F[R=h&R+I[A%_]+(T=F[A])],F[R]=T;(E.g=function(S){for(var M,W=0,U=E.i,H=E.j,K=E.S;S--;)M=K[U=h&U+1],W=W*s+K[h&(K[U]=K[H=h&H+M])+(K[H]=M)];return E.i=U,E.j=H,W})(s)}function g(I,T){return T.i=I.i,T.j=I.j,T.S=I.S.slice(),T}function y(I,T){var _=[],E=typeof I,A;if(T&&E=="object")for(A in I)try{_.push(y(I[A],T-1))}catch{}return _.length?_:E=="string"?I:I+"\0"}function b(I,T){for(var _=I+"",E,A=0;A<_.length;)T[h&A]=h&(E^=T[h&A]*19)+_.charCodeAt(A++);return v(T)}function x(){try{var I;return c&&(I=c.randomBytes)?I=I(s):(I=new Uint8Array(s),(n.crypto||n.msCrypto).getRandomValues(I)),v(I)}catch{var T=n.navigator,_=T&&T.plugins;return[+new Date,n,_,n.screen,v(r)]}}function v(I){return String.fromCharCode.apply(0,I)}if(b(a.random(),r),typeof t=="object"&&t.exports){t.exports=f;try{c=f$()}catch{}}else typeof define=="function"&&define.amd?define(function(){return f}):a["seed"+l]=f})(typeof self<"u"?self:e,[],Math)}),Hh=Rt((e,t)=>{var n=l$(),r=u$(),a=p$(),s=d$(),i=h$(),o=c$(),l=m$();l.alea=n,l.xor128=r,l.xorwow=a,l.xorshift7=s,l.xor4096=i,l.tychei=o,t.exports=l}),w0=Rt(()=>{}),ng=Rt(()=>{}),k0=Rt(()=>{}),g$=Rt(()=>{}),y$=Rt(()=>{}),b$=Rt(()=>{}),x$=Rt((e,t)=>{var n=(()=>{var r=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(r=r||__filename),function(a){a=a||{};function s(){return j.buffer!=he&&Ge(j.buffer),Ie}function i(){return j.buffer!=he&&Ge(j.buffer),Te}function o(){return j.buffer!=he&&Ge(j.buffer),Re}function l(){return j.buffer!=he&&Ge(j.buffer),Pe}function p(){return j.buffer!=he&&Ge(j.buffer),rt}var u=typeof a<"u"?a:{},d,h;u.ready=new Promise(function(D,q){d=D,h=q});var c;typeof process<"u"&&process.listeners&&(c={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var f=Object.assign({},u),m=(D,q)=>{throw q},g=typeof window=="object",y=typeof importScripts=="function",b=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",x=u.ENVIRONMENT_IS_PTHREAD||!1,v="";function I(D){return u.locateFile?u.locateFile(D,v):v+D}var T,_,E;function A(D){D instanceof Yr||U("exiting due to exception: "+D)}if(b){var R=ng(),F=k0();y?v=F.dirname(v)+"/":v=__dirname+"/",T=(q,le)=>(q=xa(q)?new URL(q):F.normalize(q),R.readFileSync(q,le?void 0:"utf8")),E=q=>{var le=T(q,!0);return le.buffer||(le=new Uint8Array(le)),le},_=(q,le,Ne)=>{q=xa(q)?new URL(q):F.normalize(q),R.readFile(q,function(Ae,Me){Ae?Ne(Ae):le(Me.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",function(q){if(!(q instanceof Yr))throw q}),process.on("unhandledRejection",function(q){throw q}),m=(q,le)=>{if(It())throw process.exitCode=q,le;A(le),process.exit(q)},u.inspect=function(){return"[Emscripten Module object]"};let D;try{D=g$()}catch(q){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),q}global.Worker=D.Worker}else(g||y)&&(y?v=self.location.href:typeof document<"u"&&document.currentScript&&(v=document.currentScript.src),typeof r<"u"&&r&&(v=r),v.indexOf("blob:")!==0?v=v.substr(0,v.replace(/[?#].*/,"").lastIndexOf("/")+1):v="",b||(T=D=>{var q=new XMLHttpRequest;return q.open("GET",D,!1),q.send(null),q.responseText},y&&(E=D=>{var q=new XMLHttpRequest;return q.open("GET",D,!1),q.responseType="arraybuffer",q.send(null),new Uint8Array(q.response)}),_=(D,q,le)=>{var Ne=new XMLHttpRequest;Ne.open("GET",D,!0),Ne.responseType="arraybuffer",Ne.onload=()=>{if(Ne.status==200||Ne.status==0&&Ne.response){q(Ne.response);return}le()},Ne.onerror=le,Ne.send(null)}));b&&typeof performance>"u"&&(global.performance=y$().performance);var S=console.log.bind(console),M=console.warn.bind(console);b&&(S=D=>R.writeSync(1,D+`
`),M=D=>R.writeSync(2,D+`
`));var W=u.print||S,U=u.printErr||M;Object.assign(u,f),f=null,u.arguments&&u.arguments,u.thisProgram&&u.thisProgram,u.quit&&(m=u.quit);var H;u.wasmBinary&&(H=u.wasmBinary);var K=u.noExitRuntime||!0;typeof WebAssembly!="object"&&Jr("no native wasm support detected");var j,Z,ee=!1,Y;function re(D,q){D||Jr(q)}var te=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function ae(D,q,le){q>>>=0;for(var Ne=q+le,Ae=q;D[Ae]&&!(Ae>=Ne);)++Ae;if(Ae-q>16&&D.buffer&&te)return te.decode(D.buffer instanceof SharedArrayBuffer?D.slice(q,Ae):D.subarray(q,Ae));for(var Me="";q<Ae;){var me=D[q++];if(!(me&128)){Me+=String.fromCharCode(me);continue}var ke=D[q++]&63;if((me&224)==192){Me+=String.fromCharCode((me&31)<<6|ke);continue}var bt=D[q++]&63;if((me&240)==224?me=(me&15)<<12|ke<<6|bt:me=(me&7)<<18|ke<<12|bt<<6|D[q++]&63,me<65536)Me+=String.fromCharCode(me);else{var Kn=me-65536;Me+=String.fromCharCode(55296|Kn>>10,56320|Kn&1023)}}return Me}function ie(D,q){return D>>>=0,D?ae(i(),D,q):""}function ve(D,q,le,Ne){if(le>>>=0,!(Ne>0))return 0;for(var Ae=le,Me=le+Ne-1,me=0;me<D.length;++me){var ke=D.charCodeAt(me);if(ke>=55296&&ke<=57343){var bt=D.charCodeAt(++me);ke=65536+((ke&1023)<<10)|bt&1023}if(ke<=127){if(le>=Me)break;q[le++>>>0]=ke}else if(ke<=2047){if(le+1>=Me)break;q[le++>>>0]=192|ke>>6,q[le++>>>0]=128|ke&63}else if(ke<=65535){if(le+2>=Me)break;q[le++>>>0]=224|ke>>12,q[le++>>>0]=128|ke>>6&63,q[le++>>>0]=128|ke&63}else{if(le+3>=Me)break;q[le++>>>0]=240|ke>>18,q[le++>>>0]=128|ke>>12&63,q[le++>>>0]=128|ke>>6&63,q[le++>>>0]=128|ke&63}}return q[le>>>0]=0,le-Ae}function be(D,q,le){return ve(D,i(),q,le)}var he,Ie,Te,Re,Pe,rt;x&&(he=u.buffer);function Ge(D){he=D,u.HEAP8=Ie=new Int8Array(D),u.HEAP16=new Int16Array(D),u.HEAP32=Re=new Int32Array(D),u.HEAPU8=Te=new Uint8Array(D),u.HEAPU16=new Uint16Array(D),u.HEAPU32=Pe=new Uint32Array(D),u.HEAPF32=new Float32Array(D),u.HEAPF64=rt=new Float64Array(D)}var qe=u.INITIAL_MEMORY||16777216;if(x)j=u.wasmMemory,he=u.buffer;else if(u.wasmMemory)j=u.wasmMemory;else if(j=new WebAssembly.Memory({initial:qe/65536,maximum:65536,shared:!0}),!(j.buffer instanceof SharedArrayBuffer))throw U("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),b&&U("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");j&&(he=j.buffer),qe=he.byteLength,Ge(he);var $e,Je=[],pt=[],Fn=[];function It(){return K}function wn(){if(u.preRun)for(typeof u.preRun=="function"&&(u.preRun=[u.preRun]);u.preRun.length;)sr(u.preRun.shift());dt(Je)}function Jt(){!x&&dt(pt)}function kn(){if(!x){if(u.postRun)for(typeof u.postRun=="function"&&(u.postRun=[u.postRun]);u.postRun.length;)In(u.postRun.shift());dt(Fn)}}function sr(D){Je.unshift(D)}function Rn(D){pt.unshift(D)}function In(D){Fn.unshift(D)}var Yt=0,jn=null;function ba(D){Yt++,u.monitorRunDependencies&&u.monitorRunDependencies(Yt)}function Ru(D){if(Yt--,u.monitorRunDependencies&&u.monitorRunDependencies(Yt),Yt==0&&jn){var q=jn;jn=null,q()}}function Jr(D){u.onAbort&&u.onAbort(D),D="Aborted("+D+")",U(D),ee=!0,Y=1,D+=". Build with -sASSERTIONS for more info.";var q=new WebAssembly.RuntimeError(D);throw h(q),q}var Du="data:application/octet-stream;base64,";function $r(D){return D.startsWith(Du)}function xa(D){return D.startsWith("file://")}var Qt;Qt="tfjs-backend-wasm-threaded-simd.wasm",$r(Qt)||(Qt=I(Qt));function Td(D){try{if(D==Qt&&H)return new Uint8Array(H);if(E)return E(D);throw"both async and sync fetching of the wasm failed"}catch(q){Jr(q)}}function Cd(){if(!H&&(g||y)){if(typeof fetch=="function"&&!xa(Qt))return fetch(Qt,{credentials:"same-origin"}).then(function(D){if(!D.ok)throw"failed to load wasm binary file at '"+Qt+"'";return D.arrayBuffer()}).catch(function(){return Td(Qt)});if(_)return new Promise(function(D,q){_(Qt,function(le){D(new Uint8Array(le))},q)})}return Promise.resolve().then(function(){return Td(Qt)})}function _d(){var D={env:Nv,wasi_snapshot_preview1:Nv};function q(me,ke){var bt=me.exports;if(u.asm=bt,Qr(u.asm._emscripten_tls_init),$e=u.asm.__indirect_function_table,Rn(u.asm.__wasm_call_ctors),Z=ke,!x){var Kn=ce.unusedWorkers.length;ce.unusedWorkers.forEach(function(ea){ce.loadWasmModuleToWorker(ea,function(){--Kn||Ru()})})}}x||ba();function le(me){q(me.instance,me.module)}function Ne(me){return Cd().then(function(ke){return WebAssembly.instantiate(ke,D)}).then(function(ke){return ke}).then(me,function(ke){U("failed to asynchronously prepare wasm: "+ke),Jr(ke)})}function Ae(){return!H&&typeof WebAssembly.instantiateStreaming=="function"&&!$r(Qt)&&!xa(Qt)&&!b&&typeof fetch=="function"?fetch(Qt,{credentials:"same-origin"}).then(function(me){var ke=WebAssembly.instantiateStreaming(me,D);return ke.then(le,function(bt){return U("wasm streaming compile failed: "+bt),U("falling back to ArrayBuffer instantiation"),Ne(le)})}):Ne(le)}if(u.instantiateWasm)try{var Me=u.instantiateWasm(D,q);return Me}catch(me){U("Module.instantiateWasm callback failed with error: "+me),h(me)}return Ae().catch(h),{}}var Ed={};function Yr(D){this.name="ExitStatus",this.message="Program terminated with exit("+D+")",this.status=D}function $o(D){var q=ce.pthreads[D];delete ce.pthreads[D],q.terminate(),Nf(D),ce.runningWorkers.splice(ce.runningWorkers.indexOf(q),1),q.pthread_ptr=0}function $d(D){var q=ce.pthreads[D];q.postMessage({cmd:"cancel"})}function fs(D){var q=ce.pthreads[D];re(q),ce.returnWorkerToPool(q)}function ms(D){var q=ce.getNewWorker();if(!q)return 6;ce.runningWorkers.push(q),ce.pthreads[D.pthread_ptr]=q,q.pthread_ptr=D.pthread_ptr;var le={cmd:"run",start_routine:D.startRoutine,arg:D.arg,pthread_ptr:D.pthread_ptr};return q.runPthread=()=>{b&&q.ref(),q.postMessage(le,D.transferList),delete q.runPthread},q.loaded&&q.runPthread(),0}function Ad(D){if(x)return Ao(1,1,D);Y=D,It()||(ce.terminateAllThreads(),u.onExit&&u.onExit(D),ee=!0),m(D,new Yr(D))}function Q(D,q){if(Y=D,!q&&x)throw Ve(D),"unwind";Ad(D)}var oe=Q;function Se(D){if(D instanceof Yr||D=="unwind")return Y;m(1,D)}var ce={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init:function(){x?ce.initWorker():ce.initMainThread()},initMainThread:function(){for(var D=8;D--;)ce.allocateUnusedWorker()},initWorker:function(){K=!1},setExitStatus:function(D){Y=D},terminateAllThreads:function(){for(var D of Object.values(ce.pthreads))ce.returnWorkerToPool(D);for(var D of ce.unusedWorkers)D.terminate();ce.unusedWorkers=[]},returnWorkerToPool:function(D){var q=D.pthread_ptr;delete ce.pthreads[q],ce.unusedWorkers.push(D),ce.runningWorkers.splice(ce.runningWorkers.indexOf(D),1),D.pthread_ptr=0,b&&D.unref(),Nf(q)},receiveObjectTransfer:function(D){},threadInitTLS:function(){ce.tlsInitFunctions.forEach(D=>D())},loadWasmModuleToWorker:function(D,q){D.onmessage=Me=>{var me=Me.data,ke=me.cmd;if(D.pthread_ptr&&(ce.currentProxiedOperationCallerThread=D.pthread_ptr),me.targetThread&&me.targetThread!=Md()){var bt=ce.pthreads[me.targetThread];bt?bt.postMessage(me,me.transferList):U('Internal error! Worker sent a message "'+ke+'" to target pthread '+me.targetThread+", but that thread no longer exists!"),ce.currentProxiedOperationCallerThread=void 0;return}ke==="processProxyingQueue"?kf(me.queue):ke==="spawnThread"?ms(me):ke==="cleanupThread"?fs(me.thread):ke==="killThread"?$o(me.thread):ke==="cancelThread"?$d(me.thread):ke==="loaded"?(D.loaded=!0,b&&D.unref(),q&&q(D),D.runPthread&&D.runPthread()):ke==="print"?W("Thread "+me.threadId+": "+me.text):ke==="printErr"?U("Thread "+me.threadId+": "+me.text):ke==="alert"?alert("Thread "+me.threadId+": "+me.text):me.target==="setimmediate"?D.postMessage(me):ke==="callHandler"?u[me.handler](...me.args):ke&&U("worker sent an unknown command "+ke),ce.currentProxiedOperationCallerThread=void 0},D.onerror=Me=>{var me="worker sent an error!";throw U(me+" "+Me.filename+":"+Me.lineno+": "+Me.message),Me},b&&(D.on("message",function(Me){D.onmessage({data:Me})}),D.on("error",function(Me){D.onerror(Me)}),D.on("detachedExit",function(){}));var le=[],Ne=["onExit","onAbort","print","printErr"];for(var Ae of Ne)u.hasOwnProperty(Ae)&&le.push(Ae);D.postMessage({cmd:"load",handlers:le,urlOrBlob:u.mainScriptUrlOrBlob||r,wasmMemory:j,wasmModule:Z})},allocateUnusedWorker:function(){var D,q=I("tfjs-backend-wasm-threaded-simd.worker.js");D=new Worker(q),ce.unusedWorkers.push(D)},getNewWorker:function(){return ce.unusedWorkers.length==0&&(ce.allocateUnusedWorker(),ce.loadWasmModuleToWorker(ce.unusedWorkers[0])),ce.unusedWorkers.pop()}};u.PThread=ce;function dt(D){for(;D.length>0;)D.shift()(u)}function mt(){var D=Md(),q=o()[D+52>>>2],le=o()[D+56>>>2],Ne=q-le;$v(q,Ne),Od(q)}u.establishStackSpace=mt;function Ve(D){if(x)return Ao(2,0,D);try{oe(D)}catch(q){Se(q)}}var De=[];function Ct(D){var q=De[D];return q||(D>=De.length&&(De.length=D+1),De[D]=q=$e.get(D)),q}function qn(D,q){var le=Ct(D)(q);It()?ce.setExitStatus(le):Ev(le)}u.invokeEntryPoint=qn;function Qr(D){ce.tlsInitFunctions.push(D)}function Fd(D){Tv(D,!y,1,!g),ce.threadInitTLS()}function Mu(D){x?postMessage({cmd:"cleanupThread",thread:D}):fs(D)}function Rd(D,q,le,Ne){return x?Ao(3,1,D,q,le,Ne):un(D,q,le,Ne)}function un(D,q,le,Ne){if(typeof SharedArrayBuffer>"u")return U("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var Ae=[],Me=0;if(x&&(Ae.length===0||Me))return Rd(D,q,le,Ne);var me={startRoutine:le,pthread_ptr:D,arg:Ne,transferList:Ae};return x?(me.cmd="spawnThread",postMessage(me,Ae),0):ms(me)}function va(){return 65536}var Dd=!0;function _E(){return Dd}function kf(D){Atomics.store(o(),D>>2,1),Md()&&_v(D),Atomics.compareExchange(o(),D>>2,1,0)}u.executeNotifiedProxyingQueue=kf;function EE(D,q,le,Ne){if(D==q)setTimeout(()=>kf(Ne));else if(x)postMessage({targetThread:D,cmd:"processProxyingQueue",queue:Ne});else{var Ae=ce.pthreads[D];if(!Ae)return;Ae.postMessage({cmd:"processProxyingQueue",queue:Ne})}return 1}function $E(D,q,le){return-1}function AE(){Jr("")}function Ou(D){Ou.shown||(Ou.shown={}),Ou.shown[D]||(Ou.shown[D]=1,b&&(D="warning: "+D),U(D))}function FE(){b||y||Ou("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")}function RE(){return Date.now()}function vv(){return 4294901760}function DE(){return vv()}var If;b?If=()=>{var D=process.hrtime();return D[0]*1e3+D[1]/1e6}:If=()=>performance.timeOrigin+performance.now();function ME(D,q,le){i().copyWithin(D>>>0,q>>>0,q+le>>>0)}function OE(){return b?b$().cpus().length:navigator.hardwareConcurrency}function LE(D){var q=Tf(),le=D();return Od(q),le}function Ao(D,q){var le=arguments.length-2,Ne=arguments;return LE(()=>{for(var Ae=le,Me=Ld(Ae*8),me=Me>>3,ke=0;ke<le;ke++){var bt=Ne[2+ke];p()[me+ke>>>0]=bt}return Cv(D,Ae,Me,q)})}var Sf=[];function zE(D,q,le){Sf.length=q;for(var Ne=le>>3,Ae=0;Ae<q;Ae++)Sf[Ae]=p()[Ne+Ae>>>0];var Me=D<0,me=Me?Ed[-D-1]:qE[D];return me.apply(null,Sf)}function PE(D){try{return j.grow(D-he.byteLength+65535>>>16),Ge(j.buffer),1}catch{}}function BE(D){var q=i().length;if(D=D>>>0,D<=q)return!1;var le=vv();if(D>le)return!1;let Ne=(bt,Kn)=>bt+(Kn-bt%Kn)%Kn;for(var Ae=1;Ae<=4;Ae*=2){var Me=q*(1+.2/Ae);Me=Math.min(Me,D+100663296);var me=Math.min(le,Ne(Math.max(D,Me),65536)),ke=PE(me);if(ke)return!0}return!1}function WE(){throw"unwind"}function wv(D){return x?Ao(4,1,D):52}function kv(D,q,le,Ne,Ae){return x?Ao(5,1,D,q,le,Ne,Ae):70}var VE=[null,[],[]];function UE(D,q){var le=VE[D];q===0||q===10?((D===1?W:U)(ae(le,0)),le.length=0):le.push(q)}function Iv(D,q,le,Ne){if(x)return Ao(6,1,D,q,le,Ne);for(var Ae=0,Me=0;Me<le;Me++){var me=l()[q>>>2],ke=l()[q+4>>>2];q+=8;for(var bt=0;bt<ke;bt++)UE(D,i()[me+bt>>>0]);Ae+=ke}return l()[Ne>>>2]=Ae,0}function Sv(D){var q=u["_"+D];return q}function GE(D,q){s().set(D,q>>>0)}function HE(D,q,le,Ne,Ae){var Me={string:Xn=>{var Fo=0;if(Xn!=null&&Xn!==0){var Rv=(Xn.length<<2)+1;Fo=Ld(Rv),be(Xn,Fo,Rv)}return Fo},array:Xn=>{var Fo=Ld(Xn.length);return GE(Xn,Fo),Fo}};function me(Xn){return q==="string"?ie(Xn):q==="boolean"?!!Xn:Xn}var ke=Sv(D),bt=[],Kn=0;if(Ne)for(var ea=0;ea<Ne.length;ea++){var Fv=Me[le[ea]];Fv?(Kn===0&&(Kn=Tf()),bt[ea]=Fv(Ne[ea])):bt[ea]=Ne[ea]}var Cf=ke.apply(null,bt);function XE(Xn){return Kn!==0&&Od(Kn),me(Xn)}return Cf=XE(Cf),Cf}function jE(D,q,le,Ne){le=le||[];var Ae=le.every(me=>me==="number"||me==="boolean"),Me=q!=="string";return Me&&Ae&&!Ne?Sv(D):function(){return HE(D,q,le,arguments)}}ce.init();var qE=[null,Ad,Ve,Rd,wv,kv,Iv],Nv={__emscripten_init_main_thread_js:Fd,__emscripten_thread_cleanup:Mu,__pthread_create_js:un,_emscripten_default_pthread_stack_size:va,_emscripten_get_now_is_monotonic:_E,_emscripten_notify_task_queue:EE,_emscripten_set_offscreencanvas_size:$E,abort:AE,emscripten_check_blocking_allowed:FE,emscripten_date_now:RE,emscripten_get_heap_max:DE,emscripten_get_now:If,emscripten_memcpy_big:ME,emscripten_num_logical_cores:OE,emscripten_receive_on_main_thread_js:zE,emscripten_resize_heap:BE,emscripten_unwind_to_js_event_loop:WE,exit:oe,fd_close:wv,fd_seek:kv,fd_write:Iv,memory:j||u.wasmMemory};_d(),u.___wasm_call_ctors=function(){return(u.___wasm_call_ctors=u.asm.__wasm_call_ctors).apply(null,arguments)},u._init=function(){return(u._init=u.asm.init).apply(null,arguments)},u._init_with_threads_count=function(){return(u._init_with_threads_count=u.asm.init_with_threads_count).apply(null,arguments)},u._get_threads_count=function(){return(u._get_threads_count=u.asm.get_threads_count).apply(null,arguments)},u._register_tensor=function(){return(u._register_tensor=u.asm.register_tensor).apply(null,arguments)},u._dispose_data=function(){return(u._dispose_data=u.asm.dispose_data).apply(null,arguments)},u._dispose=function(){return(u._dispose=u.asm.dispose).apply(null,arguments)},u._Abs=function(){return(u._Abs=u.asm.Abs).apply(null,arguments)},u._Acos=function(){return(u._Acos=u.asm.Acos).apply(null,arguments)},u._Acosh=function(){return(u._Acosh=u.asm.Acosh).apply(null,arguments)},u._Add=function(){return(u._Add=u.asm.Add).apply(null,arguments)},u._AddN=function(){return(u._AddN=u.asm.AddN).apply(null,arguments)},u._All=function(){return(u._All=u.asm.All).apply(null,arguments)},u._Any=function(){return(u._Any=u.asm.Any).apply(null,arguments)},u._ArgMax=function(){return(u._ArgMax=u.asm.ArgMax).apply(null,arguments)},u._ArgMin=function(){return(u._ArgMin=u.asm.ArgMin).apply(null,arguments)},u._Asin=function(){return(u._Asin=u.asm.Asin).apply(null,arguments)},u._Asinh=function(){return(u._Asinh=u.asm.Asinh).apply(null,arguments)},u._Atan=function(){return(u._Atan=u.asm.Atan).apply(null,arguments)},u._Atan2=function(){return(u._Atan2=u.asm.Atan2).apply(null,arguments)},u._Atanh=function(){return(u._Atanh=u.asm.Atanh).apply(null,arguments)},u._AvgPool=function(){return(u._AvgPool=u.asm.AvgPool).apply(null,arguments)},u._AvgPool3D=function(){return(u._AvgPool3D=u.asm.AvgPool3D).apply(null,arguments)},u._AvgPool3DGrad=function(){return(u._AvgPool3DGrad=u.asm.AvgPool3DGrad).apply(null,arguments)},u._AvgPoolGrad=function(){return(u._AvgPoolGrad=u.asm.AvgPoolGrad).apply(null,arguments)},u._BatchMatMul=function(){return(u._BatchMatMul=u.asm.BatchMatMul).apply(null,arguments)},u._Bincount=function(){return(u._Bincount=u.asm.Bincount).apply(null,arguments)},u._BitwiseAnd=function(){return(u._BitwiseAnd=u.asm.BitwiseAnd).apply(null,arguments)},u._Ceil=function(){return(u._Ceil=u.asm.Ceil).apply(null,arguments)},u._ClipByValue=function(){return(u._ClipByValue=u.asm.ClipByValue).apply(null,arguments)},u._Conv2D=function(){return(u._Conv2D=u.asm.Conv2D).apply(null,arguments)},u._Conv2DBackpropInput=function(){return(u._Conv2DBackpropInput=u.asm.Conv2DBackpropInput).apply(null,arguments)},u._Conv3D=function(){return(u._Conv3D=u.asm.Conv3D).apply(null,arguments)},u._Conv3DBackpropFilterV2=function(){return(u._Conv3DBackpropFilterV2=u.asm.Conv3DBackpropFilterV2).apply(null,arguments)},u._Conv3DBackpropInputV2=function(){return(u._Conv3DBackpropInputV2=u.asm.Conv3DBackpropInputV2).apply(null,arguments)},u._Cos=function(){return(u._Cos=u.asm.Cos).apply(null,arguments)},u._Cosh=function(){return(u._Cosh=u.asm.Cosh).apply(null,arguments)},u._CropAndResize=function(){return(u._CropAndResize=u.asm.CropAndResize).apply(null,arguments)},u._Cumprod=function(){return(u._Cumprod=u.asm.Cumprod).apply(null,arguments)},u._Cumsum=function(){return(u._Cumsum=u.asm.Cumsum).apply(null,arguments)},u._DenseBincount=function(){return(u._DenseBincount=u.asm.DenseBincount).apply(null,arguments)},u._DepthToSpace=function(){return(u._DepthToSpace=u.asm.DepthToSpace).apply(null,arguments)},u._DepthwiseConv2dNative=function(){return(u._DepthwiseConv2dNative=u.asm.DepthwiseConv2dNative).apply(null,arguments)},u._Diag=function(){return(u._Diag=u.asm.Diag).apply(null,arguments)},u._Dilation2D=function(){return(u._Dilation2D=u.asm.Dilation2D).apply(null,arguments)},u._Dilation2DBackpropFilter=function(){return(u._Dilation2DBackpropFilter=u.asm.Dilation2DBackpropFilter).apply(null,arguments)},u._Dilation2DBackpropInput=function(){return(u._Dilation2DBackpropInput=u.asm.Dilation2DBackpropInput).apply(null,arguments)},u._Elu=function(){return(u._Elu=u.asm.Elu).apply(null,arguments)},u._EluGrad=function(){return(u._EluGrad=u.asm.EluGrad).apply(null,arguments)},u._Equal=function(){return(u._Equal=u.asm.Equal).apply(null,arguments)},u._Erf=function(){return(u._Erf=u.asm.Erf).apply(null,arguments)},u._Exp=function(){return(u._Exp=u.asm.Exp).apply(null,arguments)},u._Expm1=function(){return(u._Expm1=u.asm.Expm1).apply(null,arguments)},u._FlipLeftRight=function(){return(u._FlipLeftRight=u.asm.FlipLeftRight).apply(null,arguments)},u._Floor=function(){return(u._Floor=u.asm.Floor).apply(null,arguments)},u._FloorDiv=function(){return(u._FloorDiv=u.asm.FloorDiv).apply(null,arguments)},u._FusedBatchNorm=function(){return(u._FusedBatchNorm=u.asm.FusedBatchNorm).apply(null,arguments)},u._FusedConv2D=function(){return(u._FusedConv2D=u.asm.FusedConv2D).apply(null,arguments)},u._FusedDepthwiseConv2D=function(){return(u._FusedDepthwiseConv2D=u.asm.FusedDepthwiseConv2D).apply(null,arguments)},u._Gather=function(){return(u._Gather=u.asm.Gather).apply(null,arguments)},u._GatherNd=function(){return(u._GatherNd=u.asm.GatherNd).apply(null,arguments)},u._Greater=function(){return(u._Greater=u.asm.Greater).apply(null,arguments)},u._GreaterEqual=function(){return(u._GreaterEqual=u.asm.GreaterEqual).apply(null,arguments)},u._IsFinite=function(){return(u._IsFinite=u.asm.IsFinite).apply(null,arguments)},u._IsInf=function(){return(u._IsInf=u.asm.IsInf).apply(null,arguments)},u._IsNan=function(){return(u._IsNan=u.asm.IsNan).apply(null,arguments)},u._LRN=function(){return(u._LRN=u.asm.LRN).apply(null,arguments)},u._LRNGrad=function(){return(u._LRNGrad=u.asm.LRNGrad).apply(null,arguments)},u._LeakyRelu=function(){return(u._LeakyRelu=u.asm.LeakyRelu).apply(null,arguments)},u._Less=function(){return(u._Less=u.asm.Less).apply(null,arguments)},u._LessEqual=function(){return(u._LessEqual=u.asm.LessEqual).apply(null,arguments)},u._LinSpace=function(){return(u._LinSpace=u.asm.LinSpace).apply(null,arguments)},u._Log=function(){return(u._Log=u.asm.Log).apply(null,arguments)},u._Log1p=function(){return(u._Log1p=u.asm.Log1p).apply(null,arguments)},u._LogicalAnd=function(){return(u._LogicalAnd=u.asm.LogicalAnd).apply(null,arguments)},u._LogicalNot=function(){return(u._LogicalNot=u.asm.LogicalNot).apply(null,arguments)},u._LogicalOr=function(){return(u._LogicalOr=u.asm.LogicalOr).apply(null,arguments)},u._LogicalXor=function(){return(u._LogicalXor=u.asm.LogicalXor).apply(null,arguments)},u._Max=function(){return(u._Max=u.asm.Max).apply(null,arguments)},u._MaxPool=function(){return(u._MaxPool=u.asm.MaxPool).apply(null,arguments)},u._MaxPool3D=function(){return(u._MaxPool3D=u.asm.MaxPool3D).apply(null,arguments)},u._MaxPool3DGrad=function(){return(u._MaxPool3DGrad=u.asm.MaxPool3DGrad).apply(null,arguments)},u._MaxPoolGrad=function(){return(u._MaxPoolGrad=u.asm.MaxPoolGrad).apply(null,arguments)},u._MaxPoolWithArgmax=function(){return(u._MaxPoolWithArgmax=u.asm.MaxPoolWithArgmax).apply(null,arguments)},u._Maximum=function(){return(u._Maximum=u.asm.Maximum).apply(null,arguments)},u._Mean=function(){return(u._Mean=u.asm.Mean).apply(null,arguments)},u._Min=function(){return(u._Min=u.asm.Min).apply(null,arguments)},u._Minimum=function(){return(u._Minimum=u.asm.Minimum).apply(null,arguments)},u._MirrorPad=function(){return(u._MirrorPad=u.asm.MirrorPad).apply(null,arguments)},u._Mod=function(){return(u._Mod=u.asm.Mod).apply(null,arguments)},u._Multinomial=function(){return(u._Multinomial=u.asm.Multinomial).apply(null,arguments)},u._Multiply=function(){return(u._Multiply=u.asm.Multiply).apply(null,arguments)},u._Neg=function(){return(u._Neg=u.asm.Neg).apply(null,arguments)},u._NonMaxSuppressionV3=function(){return(u._NonMaxSuppressionV3=u.asm.NonMaxSuppressionV3).apply(null,arguments)},u._NonMaxSuppressionV4=function(){return(u._NonMaxSuppressionV4=u.asm.NonMaxSuppressionV4).apply(null,arguments)},u._NonMaxSuppressionV5=function(){return(u._NonMaxSuppressionV5=u.asm.NonMaxSuppressionV5).apply(null,arguments)},u._NotEqual=function(){return(u._NotEqual=u.asm.NotEqual).apply(null,arguments)},u._OneHot=function(){return(u._OneHot=u.asm.OneHot).apply(null,arguments)},u._PadV2=function(){return(u._PadV2=u.asm.PadV2).apply(null,arguments)},u._Pow=function(){return(u._Pow=u.asm.Pow).apply(null,arguments)},u._Prelu=function(){return(u._Prelu=u.asm.Prelu).apply(null,arguments)},u._Prod=function(){return(u._Prod=u.asm.Prod).apply(null,arguments)},u._RealDiv=function(){return(u._RealDiv=u.asm.RealDiv).apply(null,arguments)},u._Reciprocal=function(){return(u._Reciprocal=u.asm.Reciprocal).apply(null,arguments)},u._Relu=function(){return(u._Relu=u.asm.Relu).apply(null,arguments)},u._Relu6=function(){return(u._Relu6=u.asm.Relu6).apply(null,arguments)},u._ResizeBilinear=function(){return(u._ResizeBilinear=u.asm.ResizeBilinear).apply(null,arguments)},u._ResizeBilinearGrad=function(){return(u._ResizeBilinearGrad=u.asm.ResizeBilinearGrad).apply(null,arguments)},u._ResizeNearestNeighbor=function(){return(u._ResizeNearestNeighbor=u.asm.ResizeNearestNeighbor).apply(null,arguments)},u._ResizeNearestNeighborGrad=function(){return(u._ResizeNearestNeighborGrad=u.asm.ResizeNearestNeighborGrad).apply(null,arguments)},u._Reverse=function(){return(u._Reverse=u.asm.Reverse).apply(null,arguments)},u._RotateWithOffset=function(){return(u._RotateWithOffset=u.asm.RotateWithOffset).apply(null,arguments)},u._Round=function(){return(u._Round=u.asm.Round).apply(null,arguments)},u._Rsqrt=function(){return(u._Rsqrt=u.asm.Rsqrt).apply(null,arguments)},u._ScatterNd=function(){return(u._ScatterNd=u.asm.ScatterNd).apply(null,arguments)},u._SearchSorted=function(){return(u._SearchSorted=u.asm.SearchSorted).apply(null,arguments)},u._SelectV2=function(){return(u._SelectV2=u.asm.SelectV2).apply(null,arguments)},u._Selu=function(){return(u._Selu=u.asm.Selu).apply(null,arguments)},u._Sigmoid=function(){return(u._Sigmoid=u.asm.Sigmoid).apply(null,arguments)},u._Sign=function(){return(u._Sign=u.asm.Sign).apply(null,arguments)},u._Sin=function(){return(u._Sin=u.asm.Sin).apply(null,arguments)},u._Sinh=function(){return(u._Sinh=u.asm.Sinh).apply(null,arguments)},u._Softmax=function(){return(u._Softmax=u.asm.Softmax).apply(null,arguments)},u._Softplus=function(){return(u._Softplus=u.asm.Softplus).apply(null,arguments)},u._SparseFillEmptyRows=function(){return(u._SparseFillEmptyRows=u.asm.SparseFillEmptyRows).apply(null,arguments)},u._SparseReshape=function(){return(u._SparseReshape=u.asm.SparseReshape).apply(null,arguments)},u._SparseSegmentReduction=function(){return(u._SparseSegmentReduction=u.asm.SparseSegmentReduction).apply(null,arguments)},u._SparseToDense=function(){return(u._SparseToDense=u.asm.SparseToDense).apply(null,arguments)},u._Sqrt=function(){return(u._Sqrt=u.asm.Sqrt).apply(null,arguments)},u._Square=function(){return(u._Square=u.asm.Square).apply(null,arguments)},u._SquaredDifference=function(){return(u._SquaredDifference=u.asm.SquaredDifference).apply(null,arguments)},u._Step=function(){return(u._Step=u.asm.Step).apply(null,arguments)},u._StridedSlice=function(){return(u._StridedSlice=u.asm.StridedSlice).apply(null,arguments)},u._Sub=function(){return(u._Sub=u.asm.Sub).apply(null,arguments)},u._Sum=function(){return(u._Sum=u.asm.Sum).apply(null,arguments)},u._Tan=function(){return(u._Tan=u.asm.Tan).apply(null,arguments)},u._Tanh=function(){return(u._Tanh=u.asm.Tanh).apply(null,arguments)},u._TensorScatterUpdate=function(){return(u._TensorScatterUpdate=u.asm.TensorScatterUpdate).apply(null,arguments)},u._Tile=function(){return(u._Tile=u.asm.Tile).apply(null,arguments)},u._TopK=function(){return(u._TopK=u.asm.TopK).apply(null,arguments)},u._Transform=function(){return(u._Transform=u.asm.Transform).apply(null,arguments)},u._Transpose=function(){return(u._Transpose=u.asm.Transpose).apply(null,arguments)},u.__FusedMatMul=function(){return(u.__FusedMatMul=u.asm._FusedMatMul).apply(null,arguments)},u._malloc=function(){return(u._malloc=u.asm.malloc).apply(null,arguments)},u._free=function(){return(u._free=u.asm.free).apply(null,arguments)},u.__emscripten_tls_init=function(){return(u.__emscripten_tls_init=u.asm._emscripten_tls_init).apply(null,arguments)};var Md=u._pthread_self=function(){return(Md=u._pthread_self=u.asm.pthread_self).apply(null,arguments)};u.___errno_location=function(){return(u.___errno_location=u.asm.__errno_location).apply(null,arguments)};var Tv=u.__emscripten_thread_init=function(){return(Tv=u.__emscripten_thread_init=u.asm._emscripten_thread_init).apply(null,arguments)};u.__emscripten_thread_crashed=function(){return(u.__emscripten_thread_crashed=u.asm._emscripten_thread_crashed).apply(null,arguments)},u._emscripten_main_thread_process_queued_calls=function(){return(u._emscripten_main_thread_process_queued_calls=u.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},u._emscripten_main_browser_thread_id=function(){return(u._emscripten_main_browser_thread_id=u.asm.emscripten_main_browser_thread_id).apply(null,arguments)};var Cv=u._emscripten_run_in_main_runtime_thread_js=function(){return(Cv=u._emscripten_run_in_main_runtime_thread_js=u.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)};u._emscripten_dispatch_to_thread_=function(){return(u._emscripten_dispatch_to_thread_=u.asm.emscripten_dispatch_to_thread_).apply(null,arguments)};var _v=u.__emscripten_proxy_execute_task_queue=function(){return(_v=u.__emscripten_proxy_execute_task_queue=u.asm._emscripten_proxy_execute_task_queue).apply(null,arguments)},Nf=u.__emscripten_thread_free_data=function(){return(Nf=u.__emscripten_thread_free_data=u.asm._emscripten_thread_free_data).apply(null,arguments)},Ev=u.__emscripten_thread_exit=function(){return(Ev=u.__emscripten_thread_exit=u.asm._emscripten_thread_exit).apply(null,arguments)},$v=u._emscripten_stack_set_limits=function(){return($v=u._emscripten_stack_set_limits=u.asm.emscripten_stack_set_limits).apply(null,arguments)},Tf=u.stackSave=function(){return(Tf=u.stackSave=u.asm.stackSave).apply(null,arguments)},Od=u.stackRestore=function(){return(Od=u.stackRestore=u.asm.stackRestore).apply(null,arguments)},Ld=u.stackAlloc=function(){return(Ld=u.stackAlloc=u.asm.stackAlloc).apply(null,arguments)};u.dynCall_iijjiiii=function(){return(u.dynCall_iijjiiii=u.asm.dynCall_iijjiiii).apply(null,arguments)},u.dynCall_jiji=function(){return(u.dynCall_jiji=u.asm.dynCall_jiji).apply(null,arguments)},u.keepRuntimeAlive=It,u.wasmMemory=j,u.cwrap=jE,u.ExitStatus=Yr,u.PThread=ce;var zd;jn=function D(){zd||Av(),zd||(jn=D)};function Av(D){if(Yt>0)return;if(x){d(u),Jt(),startWorker(u);return}if(wn(),Yt>0)return;function q(){zd||(zd=!0,u.calledRun=!0,!ee&&(Jt(),d(u),u.onRuntimeInitialized&&u.onRuntimeInitialized(),kn()))}u.setStatus?(u.setStatus("Running..."),setTimeout(function(){setTimeout(function(){u.setStatus("")},1),q()},1)):q()}if(u.preInit)for(typeof u.preInit=="function"&&(u.preInit=[u.preInit]);u.preInit.length>0;)u.preInit.pop()();Av();var Pd;c&&(Pd={uncaughtException:process.listeners("uncaughtException").filter(function(D){return!c.uncaughtException.indexOf(D)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(D){return!c.unhandledRejection.indexOf(D)>-1})});var Bd;if(typeof WasmBackendModule<"u")Bd=WasmBackendModule;else if(typeof a<"u")Bd=a;else throw new Error("Could not find wasm module in post.js");if(Pd){var KE=Bd._dispose;Bd._dispose=function(){KE(),Pd.uncaughtException.forEach(function(D){process.removeListener("uncaughtException",D)}),Pd.unhandledRejection.forEach(function(D){process.removeListener("unhandledRejection",D)})}}return a.ready}})();typeof e=="object"&&typeof t=="object"?t.exports=n:typeof define=="function"&&define.amd?define([],function(){return n}):typeof e=="object"&&(e.WasmBackendModuleThreadedSimd=n)}),v$=Rt((e,t)=>{t.exports.wasmWorkerContents=`"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8")+"//# sourceURL="+f)},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"
");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"})};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=function(){postMessage({cmd:"callHandler",handler:handler,args:[...arguments]})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};`}),w$=Rt((e,t)=>{var n=(()=>{var r=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(r=r||__filename),function(a){a=a||{};var s=typeof a<"u"?a:{},i,o;s.ready=new Promise(function(Q,oe){i=Q,o=oe});var l;typeof process<"u"&&process.listeners&&(l={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var p=Object.assign({},s),u=typeof window=="object",d=typeof importScripts=="function",h=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",c="";function f(Q){return s.locateFile?s.locateFile(Q,c):c+Q}var m,g,y;if(h){var b=ng(),x=k0();d?c=x.dirname(c)+"/":c=__dirname+"/",m=(Q,oe)=>(Q=qe(Q)?new URL(Q):x.normalize(Q),b.readFileSync(Q,oe?void 0:"utf8")),y=Q=>{var oe=m(Q,!0);return oe.buffer||(oe=new Uint8Array(oe)),oe},g=(Q,oe,Se)=>{Q=qe(Q)?new URL(Q):x.normalize(Q),b.readFile(Q,function(ce,dt){ce?Se(ce):oe(dt.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",function(Q){if(!(Q instanceof It))throw Q}),process.on("unhandledRejection",function(Q){throw Q}),s.inspect=function(){return"[Emscripten Module object]"}}else(u||d)&&(d?c=self.location.href:typeof document<"u"&&document.currentScript&&(c=document.currentScript.src),r&&(c=r),c.indexOf("blob:")!==0?c=c.substr(0,c.replace(/[?#].*/,"").lastIndexOf("/")+1):c="",m=Q=>{var oe=new XMLHttpRequest;return oe.open("GET",Q,!1),oe.send(null),oe.responseText},d&&(y=Q=>{var oe=new XMLHttpRequest;return oe.open("GET",Q,!1),oe.responseType="arraybuffer",oe.send(null),new Uint8Array(oe.response)}),g=(Q,oe,Se)=>{var ce=new XMLHttpRequest;ce.open("GET",Q,!0),ce.responseType="arraybuffer",ce.onload=()=>{if(ce.status==200||ce.status==0&&ce.response){oe(ce.response);return}Se()},ce.onerror=Se,ce.send(null)});var v=s.print||console.log.bind(console),I=s.printErr||console.warn.bind(console);Object.assign(s,p),p=null,s.arguments&&s.arguments,s.thisProgram&&s.thisProgram,s.quit&&s.quit;var T;s.wasmBinary&&(T=s.wasmBinary),s.noExitRuntime,typeof WebAssembly!="object"&&Pe("no native wasm support detected");var _,E=!1,A=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function R(Q,oe,Se){oe>>>=0;for(var ce=oe+Se,dt=oe;Q[dt]&&!(dt>=ce);)++dt;if(dt-oe>16&&Q.buffer&&A)return A.decode(Q.subarray(oe,dt));for(var mt="";oe<dt;){var Ve=Q[oe++];if(!(Ve&128)){mt+=String.fromCharCode(Ve);continue}var De=Q[oe++]&63;if((Ve&224)==192){mt+=String.fromCharCode((Ve&31)<<6|De);continue}var Ct=Q[oe++]&63;if((Ve&240)==224?Ve=(Ve&15)<<12|De<<6|Ct:Ve=(Ve&7)<<18|De<<12|Ct<<6|Q[oe++]&63,Ve<65536)mt+=String.fromCharCode(Ve);else{var qn=Ve-65536;mt+=String.fromCharCode(55296|qn>>10,56320|qn&1023)}}return mt}function F(Q,oe){return Q>>>=0,Q?R(H,Q,oe):""}function S(Q,oe,Se,ce){if(Se>>>=0,!(ce>0))return 0;for(var dt=Se,mt=Se+ce-1,Ve=0;Ve<Q.length;++Ve){var De=Q.charCodeAt(Ve);if(De>=55296&&De<=57343){var Ct=Q.charCodeAt(++Ve);De=65536+((De&1023)<<10)|Ct&1023}if(De<=127){if(Se>=mt)break;oe[Se++>>>0]=De}else if(De<=2047){if(Se+1>=mt)break;oe[Se++>>>0]=192|De>>6,oe[Se++>>>0]=128|De&63}else if(De<=65535){if(Se+2>=mt)break;oe[Se++>>>0]=224|De>>12,oe[Se++>>>0]=128|De>>6&63,oe[Se++>>>0]=128|De&63}else{if(Se+3>=mt)break;oe[Se++>>>0]=240|De>>18,oe[Se++>>>0]=128|De>>12&63,oe[Se++>>>0]=128|De>>6&63,oe[Se++>>>0]=128|De&63}}return oe[Se>>>0]=0,Se-dt}function M(Q,oe,Se){return S(Q,H,oe,Se)}var W,U,H,K;function j(Q){W=Q,s.HEAP8=U=new Int8Array(Q),s.HEAP16=new Int16Array(Q),s.HEAP32=new Int32Array(Q),s.HEAPU8=H=new Uint8Array(Q),s.HEAPU16=new Uint16Array(Q),s.HEAPU32=K=new Uint32Array(Q),s.HEAPF32=new Float32Array(Q),s.HEAPF64=new Float64Array(Q)}s.INITIAL_MEMORY;var Z=[],ee=[],Y=[];function re(){if(s.preRun)for(typeof s.preRun=="function"&&(s.preRun=[s.preRun]);s.preRun.length;)ie(s.preRun.shift());wn(Z)}function te(){wn(ee)}function ae(){if(s.postRun)for(typeof s.postRun=="function"&&(s.postRun=[s.postRun]);s.postRun.length;)be(s.postRun.shift());wn(Y)}function ie(Q){Z.unshift(Q)}function ve(Q){ee.unshift(Q)}function be(Q){Y.unshift(Q)}var he=0,Ie=null;function Te(Q){he++,s.monitorRunDependencies&&s.monitorRunDependencies(he)}function Re(Q){if(he--,s.monitorRunDependencies&&s.monitorRunDependencies(he),he==0&&Ie){var oe=Ie;Ie=null,oe()}}function Pe(Q){s.onAbort&&s.onAbort(Q),Q="Aborted("+Q+")",I(Q),E=!0,Q+=". Build with -sASSERTIONS for more info.";var oe=new WebAssembly.RuntimeError(Q);throw o(oe),oe}var rt="data:application/octet-stream;base64,";function Ge(Q){return Q.startsWith(rt)}function qe(Q){return Q.startsWith("file://")}var $e;$e="tfjs-backend-wasm.wasm",Ge($e)||($e=f($e));function Je(Q){try{if(Q==$e&&T)return new Uint8Array(T);if(y)return y(Q);throw"both async and sync fetching of the wasm failed"}catch(oe){Pe(oe)}}function pt(){if(!T&&(u||d)){if(typeof fetch=="function"&&!qe($e))return fetch($e,{credentials:"same-origin"}).then(function(Q){if(!Q.ok)throw"failed to load wasm binary file at '"+$e+"'";return Q.arrayBuffer()}).catch(function(){return Je($e)});if(g)return new Promise(function(Q,oe){g($e,function(Se){Q(new Uint8Array(Se))},oe)})}return Promise.resolve().then(function(){return Je($e)})}function Fn(){var Q={env:Cd,wasi_snapshot_preview1:Cd};function oe(Ve,De){var Ct=Ve.exports;s.asm=Ct,_=s.asm.memory,j(_.buffer),s.asm.__indirect_function_table,ve(s.asm.__wasm_call_ctors),Re()}Te();function Se(Ve){oe(Ve.instance)}function ce(Ve){return pt().then(function(De){return WebAssembly.instantiate(De,Q)}).then(function(De){return De}).then(Ve,function(De){I("failed to asynchronously prepare wasm: "+De),Pe(De)})}function dt(){return!T&&typeof WebAssembly.instantiateStreaming=="function"&&!Ge($e)&&!qe($e)&&!h&&typeof fetch=="function"?fetch($e,{credentials:"same-origin"}).then(function(Ve){var De=WebAssembly.instantiateStreaming(Ve,Q);return De.then(Se,function(Ct){return I("wasm streaming compile failed: "+Ct),I("falling back to ArrayBuffer instantiation"),ce(Se)})}):ce(Se)}if(s.instantiateWasm)try{var mt=s.instantiateWasm(Q,oe);return mt}catch(Ve){I("Module.instantiateWasm callback failed with error: "+Ve),o(Ve)}return dt().catch(o),{}}function It(Q){this.name="ExitStatus",this.message="Program terminated with exit("+Q+")",this.status=Q}function wn(Q){for(;Q.length>0;)Q.shift()(s)}function Jt(){Pe("")}function kn(){return 4294901760}function sr(){return kn()}function Rn(Q,oe,Se){H.copyWithin(Q>>>0,oe>>>0,oe+Se>>>0)}function In(Q){try{return _.grow(Q-W.byteLength+65535>>>16),j(_.buffer),1}catch{}}function Yt(Q){var oe=H.length;Q=Q>>>0;var Se=kn();if(Q>Se)return!1;let ce=(Ct,qn)=>Ct+(qn-Ct%qn)%qn;for(var dt=1;dt<=4;dt*=2){var mt=oe*(1+.2/dt);mt=Math.min(mt,Q+100663296);var Ve=Math.min(Se,ce(Math.max(Q,mt),65536)),De=In(Ve);if(De)return!0}return!1}function jn(Q){return 52}function ba(Q,oe,Se,ce,dt){return 70}var Ru=[null,[],[]];function Jr(Q,oe){var Se=Ru[Q];oe===0||oe===10?((Q===1?v:I)(R(Se,0)),Se.length=0):Se.push(oe)}function Du(Q,oe,Se,ce){for(var dt=0,mt=0;mt<Se;mt++){var Ve=K[oe>>>2],De=K[oe+4>>>2];oe+=8;for(var Ct=0;Ct<De;Ct++)Jr(Q,H[Ve+Ct>>>0]);dt+=De}return K[ce>>>2]=dt,0}function $r(Q){var oe=s["_"+Q];return oe}function xa(Q,oe){U.set(Q,oe>>>0)}function Qt(Q,oe,Se,ce,dt){var mt={string:un=>{var va=0;if(un!=null&&un!==0){var Dd=(un.length<<2)+1;va=Yr(Dd),M(un,va,Dd)}return va},array:un=>{var va=Yr(un.length);return xa(un,va),va}};function Ve(un){return oe==="string"?F(un):oe==="boolean"?!!un:un}var De=$r(Q),Ct=[],qn=0;if(ce)for(var Qr=0;Qr<ce.length;Qr++){var Fd=mt[Se[Qr]];Fd?(qn===0&&(qn=_d()),Ct[Qr]=Fd(ce[Qr])):Ct[Qr]=ce[Qr]}var Mu=De.apply(null,Ct);function Rd(un){return qn!==0&&Ed(qn),Ve(un)}return Mu=Rd(Mu),Mu}function Td(Q,oe,Se,ce){Se=Se||[];var dt=Se.every(Ve=>Ve==="number"||Ve==="boolean"),mt=oe!=="string";return mt&&dt&&!ce?$r(Q):function(){return Qt(Q,oe,Se,arguments)}}var Cd={abort:Jt,emscripten_get_heap_max:sr,emscripten_memcpy_big:Rn,emscripten_resize_heap:Yt,fd_close:jn,fd_seek:ba,fd_write:Du};Fn(),s.___wasm_call_ctors=function(){return(s.___wasm_call_ctors=s.asm.__wasm_call_ctors).apply(null,arguments)},s._init=function(){return(s._init=s.asm.init).apply(null,arguments)},s._init_with_threads_count=function(){return(s._init_with_threads_count=s.asm.init_with_threads_count).apply(null,arguments)},s._get_threads_count=function(){return(s._get_threads_count=s.asm.get_threads_count).apply(null,arguments)},s._register_tensor=function(){return(s._register_tensor=s.asm.register_tensor).apply(null,arguments)},s._dispose_data=function(){return(s._dispose_data=s.asm.dispose_data).apply(null,arguments)},s._dispose=function(){return(s._dispose=s.asm.dispose).apply(null,arguments)},s._Abs=function(){return(s._Abs=s.asm.Abs).apply(null,arguments)},s._Acos=function(){return(s._Acos=s.asm.Acos).apply(null,arguments)},s._Acosh=function(){return(s._Acosh=s.asm.Acosh).apply(null,arguments)},s._Add=function(){return(s._Add=s.asm.Add).apply(null,arguments)},s._AddN=function(){return(s._AddN=s.asm.AddN).apply(null,arguments)},s._All=function(){return(s._All=s.asm.All).apply(null,arguments)},s._Any=function(){return(s._Any=s.asm.Any).apply(null,arguments)},s._ArgMax=function(){return(s._ArgMax=s.asm.ArgMax).apply(null,arguments)},s._ArgMin=function(){return(s._ArgMin=s.asm.ArgMin).apply(null,arguments)},s._Asin=function(){return(s._Asin=s.asm.Asin).apply(null,arguments)},s._Asinh=function(){return(s._Asinh=s.asm.Asinh).apply(null,arguments)},s._Atan=function(){return(s._Atan=s.asm.Atan).apply(null,arguments)},s._Atan2=function(){return(s._Atan2=s.asm.Atan2).apply(null,arguments)},s._Atanh=function(){return(s._Atanh=s.asm.Atanh).apply(null,arguments)},s._AvgPool=function(){return(s._AvgPool=s.asm.AvgPool).apply(null,arguments)},s._AvgPool3D=function(){return(s._AvgPool3D=s.asm.AvgPool3D).apply(null,arguments)},s._AvgPool3DGrad=function(){return(s._AvgPool3DGrad=s.asm.AvgPool3DGrad).apply(null,arguments)},s._AvgPoolGrad=function(){return(s._AvgPoolGrad=s.asm.AvgPoolGrad).apply(null,arguments)},s._BatchMatMul=function(){return(s._BatchMatMul=s.asm.BatchMatMul).apply(null,arguments)},s._Bincount=function(){return(s._Bincount=s.asm.Bincount).apply(null,arguments)},s._BitwiseAnd=function(){return(s._BitwiseAnd=s.asm.BitwiseAnd).apply(null,arguments)},s._Ceil=function(){return(s._Ceil=s.asm.Ceil).apply(null,arguments)},s._ClipByValue=function(){return(s._ClipByValue=s.asm.ClipByValue).apply(null,arguments)},s._Conv2D=function(){return(s._Conv2D=s.asm.Conv2D).apply(null,arguments)},s._Conv2DBackpropInput=function(){return(s._Conv2DBackpropInput=s.asm.Conv2DBackpropInput).apply(null,arguments)},s._Conv3D=function(){return(s._Conv3D=s.asm.Conv3D).apply(null,arguments)},s._Conv3DBackpropFilterV2=function(){return(s._Conv3DBackpropFilterV2=s.asm.Conv3DBackpropFilterV2).apply(null,arguments)},s._Conv3DBackpropInputV2=function(){return(s._Conv3DBackpropInputV2=s.asm.Conv3DBackpropInputV2).apply(null,arguments)},s._Cos=function(){return(s._Cos=s.asm.Cos).apply(null,arguments)},s._Cosh=function(){return(s._Cosh=s.asm.Cosh).apply(null,arguments)},s._CropAndResize=function(){return(s._CropAndResize=s.asm.CropAndResize).apply(null,arguments)},s._Cumprod=function(){return(s._Cumprod=s.asm.Cumprod).apply(null,arguments)},s._Cumsum=function(){return(s._Cumsum=s.asm.Cumsum).apply(null,arguments)},s._DenseBincount=function(){return(s._DenseBincount=s.asm.DenseBincount).apply(null,arguments)},s._DepthToSpace=function(){return(s._DepthToSpace=s.asm.DepthToSpace).apply(null,arguments)},s._DepthwiseConv2dNative=function(){return(s._DepthwiseConv2dNative=s.asm.DepthwiseConv2dNative).apply(null,arguments)},s._Diag=function(){return(s._Diag=s.asm.Diag).apply(null,arguments)},s._Dilation2D=function(){return(s._Dilation2D=s.asm.Dilation2D).apply(null,arguments)},s._Dilation2DBackpropFilter=function(){return(s._Dilation2DBackpropFilter=s.asm.Dilation2DBackpropFilter).apply(null,arguments)},s._Dilation2DBackpropInput=function(){return(s._Dilation2DBackpropInput=s.asm.Dilation2DBackpropInput).apply(null,arguments)},s._Elu=function(){return(s._Elu=s.asm.Elu).apply(null,arguments)},s._EluGrad=function(){return(s._EluGrad=s.asm.EluGrad).apply(null,arguments)},s._Equal=function(){return(s._Equal=s.asm.Equal).apply(null,arguments)},s._Erf=function(){return(s._Erf=s.asm.Erf).apply(null,arguments)},s._Exp=function(){return(s._Exp=s.asm.Exp).apply(null,arguments)},s._Expm1=function(){return(s._Expm1=s.asm.Expm1).apply(null,arguments)},s._FlipLeftRight=function(){return(s._FlipLeftRight=s.asm.FlipLeftRight).apply(null,arguments)},s._Floor=function(){return(s._Floor=s.asm.Floor).apply(null,arguments)},s._FloorDiv=function(){return(s._FloorDiv=s.asm.FloorDiv).apply(null,arguments)},s._FusedBatchNorm=function(){return(s._FusedBatchNorm=s.asm.FusedBatchNorm).apply(null,arguments)},s._FusedConv2D=function(){return(s._FusedConv2D=s.asm.FusedConv2D).apply(null,arguments)},s._FusedDepthwiseConv2D=function(){return(s._FusedDepthwiseConv2D=s.asm.FusedDepthwiseConv2D).apply(null,arguments)},s._Gather=function(){return(s._Gather=s.asm.Gather).apply(null,arguments)},s._GatherNd=function(){return(s._GatherNd=s.asm.GatherNd).apply(null,arguments)},s._Greater=function(){return(s._Greater=s.asm.Greater).apply(null,arguments)},s._GreaterEqual=function(){return(s._GreaterEqual=s.asm.GreaterEqual).apply(null,arguments)},s._IsFinite=function(){return(s._IsFinite=s.asm.IsFinite).apply(null,arguments)},s._IsInf=function(){return(s._IsInf=s.asm.IsInf).apply(null,arguments)},s._IsNan=function(){return(s._IsNan=s.asm.IsNan).apply(null,arguments)},s._LRN=function(){return(s._LRN=s.asm.LRN).apply(null,arguments)},s._LRNGrad=function(){return(s._LRNGrad=s.asm.LRNGrad).apply(null,arguments)},s._LeakyRelu=function(){return(s._LeakyRelu=s.asm.LeakyRelu).apply(null,arguments)},s._Less=function(){return(s._Less=s.asm.Less).apply(null,arguments)},s._LessEqual=function(){return(s._LessEqual=s.asm.LessEqual).apply(null,arguments)},s._LinSpace=function(){return(s._LinSpace=s.asm.LinSpace).apply(null,arguments)},s._Log=function(){return(s._Log=s.asm.Log).apply(null,arguments)},s._Log1p=function(){return(s._Log1p=s.asm.Log1p).apply(null,arguments)},s._LogicalAnd=function(){return(s._LogicalAnd=s.asm.LogicalAnd).apply(null,arguments)},s._LogicalNot=function(){return(s._LogicalNot=s.asm.LogicalNot).apply(null,arguments)},s._LogicalOr=function(){return(s._LogicalOr=s.asm.LogicalOr).apply(null,arguments)},s._LogicalXor=function(){return(s._LogicalXor=s.asm.LogicalXor).apply(null,arguments)},s._Max=function(){return(s._Max=s.asm.Max).apply(null,arguments)},s._MaxPool=function(){return(s._MaxPool=s.asm.MaxPool).apply(null,arguments)},s._MaxPool3D=function(){return(s._MaxPool3D=s.asm.MaxPool3D).apply(null,arguments)},s._MaxPool3DGrad=function(){return(s._MaxPool3DGrad=s.asm.MaxPool3DGrad).apply(null,arguments)},s._MaxPoolGrad=function(){return(s._MaxPoolGrad=s.asm.MaxPoolGrad).apply(null,arguments)},s._MaxPoolWithArgmax=function(){return(s._MaxPoolWithArgmax=s.asm.MaxPoolWithArgmax).apply(null,arguments)},s._Maximum=function(){return(s._Maximum=s.asm.Maximum).apply(null,arguments)},s._Mean=function(){return(s._Mean=s.asm.Mean).apply(null,arguments)},s._Min=function(){return(s._Min=s.asm.Min).apply(null,arguments)},s._Minimum=function(){return(s._Minimum=s.asm.Minimum).apply(null,arguments)},s._MirrorPad=function(){return(s._MirrorPad=s.asm.MirrorPad).apply(null,arguments)},s._Mod=function(){return(s._Mod=s.asm.Mod).apply(null,arguments)},s._Multinomial=function(){return(s._Multinomial=s.asm.Multinomial).apply(null,arguments)},s._Multiply=function(){return(s._Multiply=s.asm.Multiply).apply(null,arguments)},s._Neg=function(){return(s._Neg=s.asm.Neg).apply(null,arguments)},s._NonMaxSuppressionV3=function(){return(s._NonMaxSuppressionV3=s.asm.NonMaxSuppressionV3).apply(null,arguments)},s._NonMaxSuppressionV4=function(){return(s._NonMaxSuppressionV4=s.asm.NonMaxSuppressionV4).apply(null,arguments)},s._NonMaxSuppressionV5=function(){return(s._NonMaxSuppressionV5=s.asm.NonMaxSuppressionV5).apply(null,arguments)},s._NotEqual=function(){return(s._NotEqual=s.asm.NotEqual).apply(null,arguments)},s._OneHot=function(){return(s._OneHot=s.asm.OneHot).apply(null,arguments)},s._PadV2=function(){return(s._PadV2=s.asm.PadV2).apply(null,arguments)},s._Pow=function(){return(s._Pow=s.asm.Pow).apply(null,arguments)},s._Prelu=function(){return(s._Prelu=s.asm.Prelu).apply(null,arguments)},s._Prod=function(){return(s._Prod=s.asm.Prod).apply(null,arguments)},s._RealDiv=function(){return(s._RealDiv=s.asm.RealDiv).apply(null,arguments)},s._Reciprocal=function(){return(s._Reciprocal=s.asm.Reciprocal).apply(null,arguments)},s._Relu=function(){return(s._Relu=s.asm.Relu).apply(null,arguments)},s._Relu6=function(){return(s._Relu6=s.asm.Relu6).apply(null,arguments)},s._ResizeBilinear=function(){return(s._ResizeBilinear=s.asm.ResizeBilinear).apply(null,arguments)},s._ResizeBilinearGrad=function(){return(s._ResizeBilinearGrad=s.asm.ResizeBilinearGrad).apply(null,arguments)},s._ResizeNearestNeighbor=function(){return(s._ResizeNearestNeighbor=s.asm.ResizeNearestNeighbor).apply(null,arguments)},s._ResizeNearestNeighborGrad=function(){return(s._ResizeNearestNeighborGrad=s.asm.ResizeNearestNeighborGrad).apply(null,arguments)},s._Reverse=function(){return(s._Reverse=s.asm.Reverse).apply(null,arguments)},s._RotateWithOffset=function(){return(s._RotateWithOffset=s.asm.RotateWithOffset).apply(null,arguments)},s._Round=function(){return(s._Round=s.asm.Round).apply(null,arguments)},s._Rsqrt=function(){return(s._Rsqrt=s.asm.Rsqrt).apply(null,arguments)},s._ScatterNd=function(){return(s._ScatterNd=s.asm.ScatterNd).apply(null,arguments)},s._SearchSorted=function(){return(s._SearchSorted=s.asm.SearchSorted).apply(null,arguments)},s._SelectV2=function(){return(s._SelectV2=s.asm.SelectV2).apply(null,arguments)},s._Selu=function(){return(s._Selu=s.asm.Selu).apply(null,arguments)},s._Sigmoid=function(){return(s._Sigmoid=s.asm.Sigmoid).apply(null,arguments)},s._Sign=function(){return(s._Sign=s.asm.Sign).apply(null,arguments)},s._Sin=function(){return(s._Sin=s.asm.Sin).apply(null,arguments)},s._Sinh=function(){return(s._Sinh=s.asm.Sinh).apply(null,arguments)},s._Softmax=function(){return(s._Softmax=s.asm.Softmax).apply(null,arguments)},s._Softplus=function(){return(s._Softplus=s.asm.Softplus).apply(null,arguments)},s._SparseFillEmptyRows=function(){return(s._SparseFillEmptyRows=s.asm.SparseFillEmptyRows).apply(null,arguments)},s._SparseReshape=function(){return(s._SparseReshape=s.asm.SparseReshape).apply(null,arguments)},s._SparseSegmentReduction=function(){return(s._SparseSegmentReduction=s.asm.SparseSegmentReduction).apply(null,arguments)},s._SparseToDense=function(){return(s._SparseToDense=s.asm.SparseToDense).apply(null,arguments)},s._Sqrt=function(){return(s._Sqrt=s.asm.Sqrt).apply(null,arguments)},s._Square=function(){return(s._Square=s.asm.Square).apply(null,arguments)},s._SquaredDifference=function(){return(s._SquaredDifference=s.asm.SquaredDifference).apply(null,arguments)},s._Step=function(){return(s._Step=s.asm.Step).apply(null,arguments)},s._StridedSlice=function(){return(s._StridedSlice=s.asm.StridedSlice).apply(null,arguments)},s._Sub=function(){return(s._Sub=s.asm.Sub).apply(null,arguments)},s._Sum=function(){return(s._Sum=s.asm.Sum).apply(null,arguments)},s._Tan=function(){return(s._Tan=s.asm.Tan).apply(null,arguments)},s._Tanh=function(){return(s._Tanh=s.asm.Tanh).apply(null,arguments)},s._TensorScatterUpdate=function(){return(s._TensorScatterUpdate=s.asm.TensorScatterUpdate).apply(null,arguments)},s._Tile=function(){return(s._Tile=s.asm.Tile).apply(null,arguments)},s._TopK=function(){return(s._TopK=s.asm.TopK).apply(null,arguments)},s._Transform=function(){return(s._Transform=s.asm.Transform).apply(null,arguments)},s._Transpose=function(){return(s._Transpose=s.asm.Transpose).apply(null,arguments)},s.__FusedMatMul=function(){return(s.__FusedMatMul=s.asm._FusedMatMul).apply(null,arguments)},s._malloc=function(){return(s._malloc=s.asm.malloc).apply(null,arguments)},s._free=function(){return(s._free=s.asm.free).apply(null,arguments)},s.___errno_location=function(){return(s.___errno_location=s.asm.__errno_location).apply(null,arguments)};var _d=s.stackSave=function(){return(_d=s.stackSave=s.asm.stackSave).apply(null,arguments)},Ed=s.stackRestore=function(){return(Ed=s.stackRestore=s.asm.stackRestore).apply(null,arguments)},Yr=s.stackAlloc=function(){return(Yr=s.stackAlloc=s.asm.stackAlloc).apply(null,arguments)};s.dynCall_iijjiiii=function(){return(s.dynCall_iijjiiii=s.asm.dynCall_iijjiiii).apply(null,arguments)},s.dynCall_jiji=function(){return(s.dynCall_jiji=s.asm.dynCall_jiji).apply(null,arguments)},s.cwrap=Td;var $o;Ie=function Q(){$o||$d(),$o||(Ie=Q)};function $d(Q){if(he>0||(re(),he>0))return;function oe(){$o||($o=!0,s.calledRun=!0,!E&&(te(),i(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),ae()))}s.setStatus?(s.setStatus("Running..."),setTimeout(function(){setTimeout(function(){s.setStatus("")},1),oe()},1)):oe()}if(s.preInit)for(typeof s.preInit=="function"&&(s.preInit=[s.preInit]);s.preInit.length>0;)s.preInit.pop()();$d();var fs;l&&(fs={uncaughtException:process.listeners("uncaughtException").filter(function(Q){return!l.uncaughtException.indexOf(Q)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(Q){return!l.unhandledRejection.indexOf(Q)>-1})});var ms;if(typeof a<"u")ms=a;else if(typeof WasmBackendModuleThreadedSimd<"u")ms=WasmBackendModuleThreadedSimd;else throw new Error("Could not find wasm module in post.js");if(fs){var Ad=ms._dispose;ms._dispose=function(){Ad(),fs.uncaughtException.forEach(function(Q){process.removeListener("uncaughtException",Q)}),fs.unhandledRejection.forEach(function(Q){process.removeListener("unhandledRejection",Q)})}}return a.ready}})();typeof e=="object"&&typeof t=="object"?t.exports=n:typeof define=="function"&&define.amd?define([],function(){return n}):typeof e=="object"&&(e.WasmBackendModule=n)}),jh=class{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},wp=class{refCount(e){return Dn("refCount")}incRef(e){return Dn("incRef")}timerAvailable(){return!0}time(e){return Dn("time")}read(e){return Dn("read")}readSync(e){return Dn("readSync")}readToGPU(e,t){return Dn("readToGPU")}numDataIds(){return Dn("numDataIds")}disposeData(e,t){return Dn("disposeData")}write(e,t,n){return Dn("write")}move(e,t,n,r,a){return Dn("move")}createTensorFromGPUData(e,t,n){return Dn("createTensorFromGPUData")}memory(){return Dn("memory")}floatPrecision(){return Dn("floatPrecision")}epsilon(){return this.floatPrecision()===32?1e-7:1e-4}dispose(){return Dn("dispose")}};function Dn(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function I0(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,ch(e,t,n)}function k$(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,ch(e,n,r),ch(t,n,r)}function rp(e,t,n){return Math.max(e,Math.min(t,n))}function I$(e){return e%2===0?e:e+1}function ch(e,t,n){let r=e[t];e[t]=e[n],e[n]=r}function S$(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function N$(e,t){let n=Math.random();return t*n+(1-n)*e}function T$(e,t){let n=0;for(let r=0;r<e.length;r++){let a=Number(e[r])-Number(t[r]);n+=a*a}return n}function $(e,t){if(!e)throw new Error(typeof t=="string"?t:t())}function yn(e,t,n=""){$(pa(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function Ys(e){$(e!=null,()=>"The input to the tensor constructor must be a non-null value.")}function tt(e){if(e.length===0)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function C$(e){return e.length===0}function S0(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==null&&t[n]!==null&&e[n]!==t[n])return!1;return!0}function pa(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function Ho(e){return e%1===0}function _$(e){if(Math.tanh!=null)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{let t=Math.exp(2*e);return(t-1)/(t+1)}}function E$(e){let t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function $$(e){let t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return I0(t),t}function Yu(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function A$(e,t=a=>0,n,r){return new Promise((a,s)=>{let i=0,o=()=>{if(e()){a();return}i++;let l=t(i);if(n!=null&&i>=n){s();return}r!=null?r(o,l):setTimeout(o,l)};o()})}function F$(e,t){let n=1,r=-1;for(let s=0;s<e.length;++s)if(e[s]>=0)n*=e[s];else if(e[s]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${s}`);r=s}else if(e[s]<0)throw Error(`Shapes can not be < 0. Found ${e[s]} at dim ${s}`);if(r===-1){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(n===0)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);let a=e.slice();return a[r]=t/n,a}function hr(e,t){let n=t.length;return e=e==null?t.map((r,a)=>a):[].concat(e),$(e.every(r=>r>=-n&&r<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),$(e.every(r=>Ho(r)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(r=>r<0?n+r:r)}function N0(e,t){let n=[],r=[],a=t!=null&&Array.isArray(t)&&t.length===0,s=t==null||a?null:hr(t,e).sort(),i=0;for(let o=0;o<e.length;++o){if(s!=null){if(s[i]===o&&e[o]!==1)throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(s[i]==null||s[i]>o)&&e[o]===1&&(n.push(e[o]),r.push(o)),s[i]<=o&&i++}e[o]!==1&&(n.push(e[o]),r.push(o))}return{newShape:n,keptDims:r}}function T0(e,t){return rg(e,t)}function rg(e,t){let n=null;if(e==null||e==="float32")n=new Float32Array(t);else if(e==="int32")n=new Int32Array(t);else if(e==="bool")n=new Uint8Array(t);else if(e==="string")n=new Array(t);else throw new Error(`Unknown data type ${e}`);return n}function C0(e,t){for(let n=0;n<e.length;n++){let r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function _0(e){return e==="bool"||e==="complex64"||e==="float32"||e==="int32"||e==="string"}function R$(e,t){return!(t==="complex64"||t==="float32"&&e!=="complex64"||t==="int32"&&e!=="float32"&&e!=="complex64"||t==="bool"&&e==="bool")}function fh(e){if(e==="float32"||e==="int32")return 4;if(e==="complex64")return 8;if(e==="bool")return 1;throw new Error(`Unknown dtype ${e}`)}function E0(e){if(e==null)return 0;let t=0;return e.forEach(n=>t+=n.length),t}function Ea(e){return typeof e=="string"||e instanceof String}function $0(e){return typeof e=="boolean"}function A0(e){return typeof e=="number"}function kp(e){return Array.isArray(e)?kp(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":A0(e)?"float32":Ea(e)?"string":$0(e)?"bool":"float32"}function Oa(e){return!!(e&&e.constructor&&e.call&&e.apply)}function mh(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function ul(e){let t=e.length;if(t<2)return[];let n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function F0(e,t,n,r=!1){let a=new Array;if(t.length===1){let s=t[0]*(r?2:1);for(let i=0;i<s;i++)a[i]=n[e+i]}else{let s=t[0],i=t.slice(1),o=i.reduce((l,p)=>l*p)*(r?2:1);for(let l=0;l<s;l++)a[l]=F0(e+l*o,i,n,r)}return a}function Bo(e,t,n=!1){if(e.length===0)return t[0];let r=e.reduce((a,s)=>a*s)*(n?2:1);if(r===0)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return F0(0,e,t,n)}function D$(e,t){if(Array.isArray(e))return e;if(t==="float32")return e instanceof Float32Array?e:new Float32Array(e);if(t==="int32")return e instanceof Int32Array?e:new Int32Array(e);if(t==="bool"||t==="string")return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function ag(e,t){let n=qh(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function qh(e,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool")return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function M$(e,t){let n=e.reduce((r,a)=>r*a,1);if(t==null||t==="float32")return Bo(e,new Float32Array(n));if(t==="int32")return Bo(e,new Int32Array(n));if(t==="bool")return Bo(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function Hn(e){e.forEach(t=>{$(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function O$(e,t,n){if(t===0)return 0;if(t===1)return e[0];let r=e[e.length-1];for(let a=0;a<e.length-1;++a)r+=n[a]*e[a];return r}function L$(e,t,n){if(t===0)return[];if(t===1)return[e];let r=new Array(t);for(let a=0;a<r.length-1;++a)r[a]=Math.floor(e/n[a]),e-=r[a]*n[a];return r[r.length-1]=e,r}function Kh(e){return e&&e.then&&typeof e.then=="function"}var Dv="tfjsflags",R0=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=z$,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(G().getBool("IS_TEST")||G().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},this.urlFlags[e]!=null){let r=this.urlFlags[e];G().getBool("IS_TEST")||G().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${r}.`),this.set(e,r)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(Kh(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;let e=this.getQueryParams(this.global.location.search);Dv in e&&e[Dv].split(",").forEach(t=>{let[n,r]=t.split(":");this.urlFlags[n]=B$(n,r)})}};function z$(e){let t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...r)=>(P$(t,r[0],r[1]),r.join("="))),t}function P$(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}function B$(e,t){let n=t.toLowerCase();return n==="true"||n==="false"?n==="true":`${+n}`===n?+n:t}function G(){return sg}var sg=null;function W$(e){sg=e}var _f;function D0(){if(_f==null){let e;if(typeof window<"u")e=window;else if(typeof global<"u")e=global;else if(typeof process<"u")e=process;else if(typeof self<"u")e=self;else throw new Error("Could not find a global object");_f=e}return _f}function V$(){let e=D0();return e._tfGlobals==null&&(e._tfGlobals=new Map),e._tfGlobals}function ig(e,t){let n=V$();if(n.has(e))return n.get(e);{let r=t();return n.set(e,r),n.get(e)}}var pl="Abs",Qs="Acos",ei="Acosh",Ya="Add",ti="AddN",dl="All",hl="Any",cl="ArgMax",fl="ArgMin",ni="Asin",ri="Asinh",ai="Atan",si="Atanh",ii="Atan2",oi="AvgPool",Ip="AvgPoolGrad",ml="AvgPool3D",Sp="AvgPool3DGrad",li="BatchMatMul",gl="BatchToSpaceND",yl="Bincount",bl="BitwiseAnd",M0="BroadcastTo",Np="BroadcastArgs",ui="Cast",pi="Ceil",Qa="ClipByValue",Xh="Complex",Tp="ComplexAbs",xl="Concat",di="Conv2D",Zh="Conv2DBackpropFilter",hi="Conv2DBackpropInput",ci="Conv3D",vl="Conv3DBackpropFilterV2",wl="Conv3DBackpropInputV2",fi="Cos",mi="Cosh",kl="Cumprod",gi="Cumsum",Il="CropAndResize",Cp="DenseBincount",Sl="DepthToSpace",yi="DepthwiseConv2dNative",Jh="DepthwiseConv2dNativeBackpropFilter",Yh="DepthwiseConv2dNativeBackpropInput",_p="Diag",bi="Dilation2D",jo="Dilation2DBackpropInput",qo="Dilation2DBackpropFilter",Qh="Draw",xi="RealDiv",ec="Einsum",vi="Elu",Nl="EluGrad",wi="Erf",Tl="Equal",ki="Exp",Cl="ExpandDims",Ii="Expm1",tc="FFT",Ep="Fill",_l="FlipLeftRight",Si="Floor",Ni="FloorDiv",Ti="FusedBatchNorm",El="GatherV2",$l="GatherNd",Al="Greater",Ci="GreaterEqual",_i="Identity",nc="IFFT",rc="Imag",Ei="IsFinite",$i="IsInf",Ai="IsNan",Fi="LeakyRelu",Fl="Less",Rl="LessEqual",Dl="LinSpace",Ri="Log",Di="Log1p",Ml="LogicalAnd",Ol="LogicalNot",Ll="LogicalOr",O0="LogicalXor",L0="LogSoftmax",U$="LowerBound",Mi="LRN",zl="LRNGrad",G$="MatrixBandPart",Oi="Max",Li="Maximum",zi="MaxPool",$p="MaxPoolGrad",Pl="MaxPool3D",Ap="MaxPool3DGrad",Fp="MaxPoolWithArgmax",Pi="Mean",Bi="Min",Wi="Minimum",Vi="MirrorPad",Ui="Mod",Bl="Multinomial",Gi="Multiply",Wl="Neg",Vl="NotEqual",Ul="NonMaxSuppressionV3",Gl="NonMaxSuppressionV4",Hl="NonMaxSuppressionV5",jl="OnesLike",Hi="OneHot",ql="Pack",ji="PadV2",H$="Pool",qi="Pow",Ki="Prelu",Xi="Prod",ac="RaggedGather",sc="RaggedRange",ic="RaggedTensorToTensor",Rp="Range",oc="Real",Zi="Reciprocal",Ji="Relu",Kl="Reshape",Yi="ResizeNearestNeighbor",Xl="ResizeNearestNeighborGrad",Qi="ResizeBilinear",Zl="ResizeBilinearGrad",eo="Relu6",to="Reverse",no="Round",ro="Rsqrt",Jl="ScatterNd",Yl="TensorScatterUpdate",Ql="SearchSorted",eu="Select",ao="Selu",tu="Slice",so="Sin",io="Sinh",oo="Sign",lo="Sigmoid",uo="Softplus",po="Sqrt",ho="Sum",nu="SpaceToBatchND",ru="SplitV",co="Softmax",Dp="SparseFillEmptyRows",au="SparseReshape",Mp="SparseSegmentMean",Op="SparseSegmentSum",su="SparseToDense",fo="SquaredDifference",Lp="Square",zp="StaticRegexReplace",iu="StridedSlice",Pp="StringNGrams",Bp="StringSplit",Wp="StringToHashBucketFast",mo="Sub",go="Tan",yo="Tanh",es="Tile",ou="TopK",lu="Transform",sa="Transpose",Vp="Unique",uu="Unpack",Up="UnsortedSegmentSum",j$="UpperBound",pu="ZerosLike",ts="Step",gh="FromPixels",du="RotateWithOffset",Fs="_FusedMatMul",Rs="FusedConv2D",Ds="FusedDepthwiseConv2D";function _a(...e){G().getBool("IS_TEST")||G().getBool("PROD")||console.warn(...e)}function q$(...e){G().getBool("IS_TEST")||G().getBool("PROD")||console.log(...e)}var Ko=ig("kernelRegistry",()=>new Map),ap=ig("gradRegistry",()=>new Map);function sp(e,t){let n=og(e,t);return Ko.get(n)}function qf(e){return ap.get(e)}function yh(e){let t=Ko.entries(),n=[];for(;;){let{done:r,value:a}=t.next();if(r)break;let[s,i]=a,[o]=s.split("_");o===e&&n.push(i)}return n}function Gp(e){let{kernelName:t,backendName:n}=e,r=og(t,n);Ko.has(r)&&_a(`The kernel '${t}' for backend '${n}' is already registered`),Ko.set(r,e)}function z0(e){let{kernelName:t}=e;ap.has(t)&&G().getBool("DEBUG")&&_a(`Overriding the gradient for '${t}'`),ap.set(t,e)}function K$(e,t){let n=og(e,t);if(!Ko.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);Ko.delete(n)}function X$(e){if(!ap.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);ap.delete(e)}function Z$(e,t){yh(e).forEach(n=>{let r=Object.assign({},n,{backendName:t});Gp(r)})}function og(e,t){return`${t}_${e}`}var w={};Ee(w,{arraysEqual:()=>pa,arraysEqualWithNull:()=>S0,assert:()=>$,assertNonNegativeIntegerDimensions:()=>Hn,assertNonNull:()=>Ys,assertShapesMatch:()=>yn,bytesFromStringArray:()=>E0,bytesPerElement:()=>fh,checkConversionForErrors:()=>C0,clamp:()=>rp,computeStrides:()=>ul,convertBackendValuesAndArrayBuffer:()=>D$,createScalarValue:()=>nA,createShuffledIndices:()=>$$,decodeString:()=>bh,distSquared:()=>T$,encodeString:()=>jp,fetch:()=>aA,fingerPrint64:()=>tA,flatten:()=>La,getArrayFromDType:()=>rg,getTypedArrayFromDType:()=>T0,hasEncodingLoss:()=>R$,hexToLong:()=>Hp,indexToLoc:()=>L$,inferDtype:()=>kp,inferFromImplicitShape:()=>F$,isBoolean:()=>$0,isFunction:()=>Oa,isInt:()=>Ho,isNumber:()=>A0,isPromise:()=>Kh,isScalarShape:()=>C$,isString:()=>Ea,isTypedArray:()=>Gt,isValidDtype:()=>_0,locToIndex:()=>O$,makeOnesTypedArray:()=>ag,makeZerosNestedTypedArray:()=>M$,makeZerosTypedArray:()=>qh,nearestDivisor:()=>mh,nearestLargerEven:()=>I$,now:()=>ip,parseAxisParam:()=>hr,randUniform:()=>N$,repeatedTry:()=>A$,rightPad:()=>Yu,shuffle:()=>I0,shuffleCombo:()=>k$,sizeFromShape:()=>tt,sizeToSquarishShape:()=>E$,squeezeShape:()=>N0,sum:()=>S$,swap:()=>ch,tanh:()=>_$,toNestedArray:()=>Bo,toTypedArray:()=>lc});function P0(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var Mv=Ja(s$()),ws=Mv.default||Mv;function Hp(e){return ws.fromString(e,!0,16)}var B0=Hp("c3a5c85c97cb3127"),bs=Hp("b492b66fbe98f273"),pn=Hp("9ae16a3b2f90404f");function Kf(e){return e.xor(e.shru(47))}function W0(e,t,n){let r=e.slice(t,t+n);return ws.fromBytes(Array.from(r),!0,!0)}function ht(e,t){return W0(e,t,8)}function Ov(e,t){return W0(e,t,4)}function Ut(e,t){return t===0?e:e.shru(t).or(e.shl(64-t))}function Ra(e,t,n=Hp("9ddfea08eb382d69")){let r=e.xor(t).mul(n);r=r.xor(r.shru(47));let a=t.xor(r).mul(n);return a=a.xor(a.shru(47)),a=a.mul(n),a}function J$(e,t,n,r,a,s){a=a.add(e),s=Ut(s.add(a).add(r),21);let i=a;return a=a.add(t),a=a.add(n),s=s.add(Ut(a,44)),[a.add(r),s.add(i)]}function Wd(e,t,n,r){return J$(ht(e,t),ht(e,t+8),ht(e,t+16),ht(e,t+24),n,r)}function Y$(e,t=e.length){if(t>=8){let n=pn.add(t*2),r=ht(e,0).add(pn),a=ht(e,t-8),s=Ut(a,37).mul(n).add(r),i=Ut(r,25).add(a).mul(n);return Ra(s,i,n)}if(t>=4){let n=pn.add(t*2),r=Ov(e,0);return Ra(r.shl(3).add(t),Ov(e,t-4),n)}if(t>0){let n=e[0],r=e[t>>1],a=e[t-1],s=n+(r<<8),i=t+(a<<2);return Kf(pn.mul(s).xor(B0.mul(i))).mul(pn)}return pn}function Q$(e,t=e.length){let n=pn.add(t*2),r=ht(e,0).mul(bs),a=ht(e,8),s=ht(e,t-8).mul(n),i=ht(e,t-16).mul(pn);return Ra(Ut(r.add(a),43).add(Ut(s,30)).add(i),r.add(Ut(a.add(pn),18)).add(s),n)}function eA(e,t=e.length){let n=pn.add(t*2),r=ht(e,0).mul(pn),a=ht(e,8),s=ht(e,t-8).mul(n),i=ht(e,t-16).mul(pn),o=Ut(r.add(a),43).add(Ut(s,30)).add(i),l=Ra(o,r.add(Ut(a.add(pn),18)).add(s),n),p=ht(e,16).mul(n),u=ht(e,24),d=o.add(ht(e,t-32)).mul(n),h=l.add(ht(e,t-24)).mul(n);return Ra(Ut(p.add(u),43).add(Ut(d,30)).add(h),p.add(Ut(u.add(r),18)).add(d),n)}function tA(e,t=e.length){let n=ws.fromNumber(81,!0);if(t<=32)return t<=16?Y$(e,t):Q$(e,t);if(t<=64)return eA(e,t);let r=n,a=n.mul(bs).add(113),s=Kf(a.mul(pn).add(113)).mul(pn),i=[ws.UZERO,ws.UZERO],o=[ws.UZERO,ws.UZERO];r=r.mul(pn).add(ht(e,0));let l=0,p=(t-1>>6)*64,u=p+(t-1&63)-63;do r=Ut(r.add(a).add(i[0]).add(ht(e,l+8)),37).mul(bs),a=Ut(a.add(i[1]).add(ht(e,l+48)),42).mul(bs),r=r.xor(o[1]),a=a.add(i[0]).add(ht(e,l+40)),s=Ut(s.add(o[0]),33).mul(bs),i=Wd(e,l,i[1].mul(bs),r.add(o[0])),o=Wd(e,l+32,s.add(o[1]),a.add(ht(e,l+16))),[s,r]=[r,s],l+=64;while(l!==p);let d=bs.add(s.and(255).shl(1));return l=u,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),r=Ut(r.add(a).add(i[0]).add(ht(e,l+8)),37).mul(d),a=Ut(a.add(i[1]).add(ht(e,l+48)),42).mul(d),r=r.xor(o[1].mul(9)),a=a.add(i[0].mul(9).add(ht(e,l+40))),s=Ut(s.add(o[0]),33).mul(d),i=Wd(e,l,i[1].mul(d),r.add(o[0])),o=Wd(e,l+32,s.add(o[1]),a.add(ht(e,l+16))),[s,r]=[r,s],Ra(Ra(i[0],o[0],d).add(Kf(a).mul(B0)).add(s),Ra(i[1],o[1],d).add(r),d)}function nA(e,t){return t==="string"?jp(e):lc([e],t)}function rA(e,t){return e instanceof Float32Array&&t==="float32"||e instanceof Int32Array&&t==="int32"||e instanceof Uint8Array&&t==="bool"}function lc(e,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=La(e)),G().getBool("DEBUG")&&C0(e,t),rA(e,t))return e;if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool"){let n=new Uint8Array(e.length);for(let r=0;r<n.length;++r)Math.round(e[r])!==0&&(n[r]=1);return n}else throw new Error(`Unknown data type ${t}`)}function ip(){return G().platform.now()}function aA(e,t){return G().platform.fetch(e,t)}function jp(e,t="utf-8"){return t=t||"utf-8",G().platform.encode(e,t)}function bh(e,t="utf-8"){return t=t||"utf-8",G().platform.decode(e,t)}function Gt(e){return G().platform.isTypedArray!=null?G().platform.isTypedArray(e):P0(e)}function La(e,t=[],n=!1){if(t==null&&(t=[]),typeof e=="boolean"||typeof e=="number"||typeof e=="string"||Kh(e)||e==null||Gt(e)&&n)t.push(e);else if(Array.isArray(e)||Gt(e))for(let r=0;r<e.length;++r)La(e[r],t,n);else{let r=-1;for(let a of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(a)&&(r=Math.max(r,Number(a)));for(let a=0;a<=r;a++)La(e[a],t,n)}return t}var sA=class{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new oA)}profileKernel(e,t,n){let r,a=()=>{r=n()},s,i=ip();if(this.backendTimer.timerAvailable())s=this.backendTimer.time(a);else{a();for(let o of r)o.dataSync();s=Promise.resolve({kernelMs:ip()-i})}if(G().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let o=0;o<r.length;o++){let l=r[o];l.data().then(p=>{iA(p,l.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:s.then(o=>o.kernelMs),extraInfo:s.then(o=>o.getExtraProfileInfo!=null?o.getExtraProfileInfo():"")}}logKernelProfile(e){let{kernelName:t,outputs:n,timeMs:r,inputs:a,extraInfo:s}=e;n.forEach(i=>{Promise.all([i.data(),r,s]).then(o=>{this.logger.logKernelProfile(t,i,o[0],o[1],a,o[2])})})}};function iA(e,t,n){if(t!=="float32")return!1;for(let r=0;r<e.length;r++){let a=e[r];if(isNaN(a)||!isFinite(a))return console.warn(`Found ${a} in the result of '${n}'`),!0}return!1}var oA=class{logKernelProfile(e,t,n,r,a,s){let i=typeof r=="number"?Yu(`${r}ms`,9):r.error,o=Yu(e,25),l=t.rank,p=t.size,u=Yu(t.shape.toString(),14),d="";for(let h in a){let c=a[h];if(c!=null){let f=c.shape||t.shape,m=f.length;d+=`${h}: ${m}D ${m>0?f:""} `}}console.log(`%c${o}	%c${i}	%c${l}D ${u}	%c${p}	%c${d}	%c${s}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function lA(e,t,n){let r={},a={};for(let l=0;l<t.length;l++)r[t[l].id]=!0;for(let l=0;l<e.length;l++){let p=e[l],u=p.inputs;for(let d in u){let h=u[d],c=!1;for(let f=0;f<t.length;f++)if(r[h.id]){p.outputs.forEach(m=>r[m.id]=!0),c=!0,a[p.id]=!0;break}if(c)break}}let s={};s[n.id]=!0;let i={};for(let l=e.length-1;l>=0;l--){let p=e[l],u=p.inputs;for(let d=0;d<p.outputs.length;d++)if(s[p.outputs[d].id]){for(let h in u)s[u[h].id]=!0,i[p.id]=!0;break}}let o=[];for(let l=0;l<e.length;l++){let p=e[l];if(a[p.id]&&i[p.id]){let u={};for(let h in p.inputs){let c=p.inputs[h];r[c.id]&&(u[h]=c)}let d=Object.assign({},p);d.inputs=u,d.outputs=p.outputs,o.push(d)}}return o}function uA(e,t,n,r){for(let a=t.length-1;a>=0;a--){let s=t[a],i=[];if(s.outputs.forEach(l=>{let p=e[l.id];p!=null?i.push(p):i.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let o=s.gradient(i);for(let l in s.inputs){if(!(l in o))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(o)}.`);let p=n(()=>o[l]());if(p.dtype!=="float32")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${p.dtype}'`);let u=s.inputs[l];if(!pa(p.shape,u.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${l}' has shape '${p.shape}', which does not match the shape of the input '${u.shape}'`);if(e[u.id]==null)e[u.id]=p;else{let d=e[u.id];e[u.id]=r(d,p),d.dispose()}}}}var Lv=20,Lu=3,Ef=7;function pA(e,t,n,r){let a=ul(t),s=dA(e,t,n,a),i=t.length,o=ah(e,t,n,a,s),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${i}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(o.map(p=>"    "+p).join(`
`)),l.join(`
`)}function dA(e,t,n,r){let a=tt(t),s=r[r.length-1],i=new Array(s).fill(0),o=t.length,l=n==="complex64"?Uu(e):e;if(o>1)for(let p=0;p<a/s;p++){let u=p*s;for(let d=0;d<s;d++)i[d]=Math.max(i[d],Vu(l[u+d],0,n).length)}return i}function Vu(e,t,n){let r;return Array.isArray(e)?r=`${parseFloat(e[0].toFixed(Ef))} + ${parseFloat(e[1].toFixed(Ef))}j`:Ea(e)?r=`'${e}'`:n==="bool"?r=V0(e):r=parseFloat(e.toFixed(Ef)).toString(),Yu(r,t)}function V0(e){return e===0?"false":"true"}function ah(e,t,n,r,a,s=!0){let i=n==="complex64"?2:1,o=t[0],l=t.length;if(l===0){if(n==="complex64"){let m=Uu(e);return[Vu(m[0],0,n)]}return n==="bool"?[V0(e[0])]:[e[0].toString()]}if(l===1){if(o>Lv){let m=Lu*i,g=Array.from(e.slice(0,m)),y=Array.from(e.slice((o-Lu)*i,o*i));return n==="complex64"&&(g=Uu(g),y=Uu(y)),["["+g.map((b,x)=>Vu(b,a[x],n)).join(", ")+", ..., "+y.map((b,x)=>Vu(b,a[o-Lu+x],n)).join(", ")+"]"]}return["["+(n==="complex64"?Uu(e):Array.from(e)).map((m,g)=>Vu(m,a[g],n)).join(", ")+"]"]}let p=t.slice(1),u=r.slice(1),d=r[0]*i,h=[];if(o>Lv){for(let m=0;m<Lu;m++){let g=m*d,y=g+d;h.push(...ah(e.slice(g,y),p,n,u,a,!1))}h.push("...");for(let m=o-Lu;m<o;m++){let g=m*d,y=g+d;h.push(...ah(e.slice(g,y),p,n,u,a,m===o-1))}}else for(let m=0;m<o;m++){let g=m*d,y=g+d;h.push(...ah(e.slice(g,y),p,n,u,a,m===o-1))}let c=l===2?",":"";h[0]="["+(o>0?h[0]+c:"");for(let m=1;m<h.length-1;m++)h[m]=" "+h[m]+c;let f=`,
`;for(let m=2;m<l;m++)f+=`
`;return h[h.length-1]=" "+h[h.length-1]+"]"+(s?"":f),h}function Uu(e){let t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var $t=class{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=tt(e),n!=null){let r=n.length;$(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||rg(t,this.size),this.strides=ul(e)}set(e,...t){t.length===0&&(t=[0]),$(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);let n=this.locToIndex(t);this.values[n]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(let r of e){if(r<0||r>=this.shape[t]){let a=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(a)}t++}let n=e[e.length-1];for(let r=0;r<e.length-1;++r)n+=this.strides[r]*e[r];return this.values[n]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];let t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return br().makeTensor(this.values,this.shape,this.dtype)}},br=null,Oo=null;function hA(e){br=e}function cA(e){Oo=e}var Fe=class{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=tt(e),this.strides=ul(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return Oo.buffer(this.shape,this.dtype,e)}bufferSync(){return Oo.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return Bo(this.shape,e,this.dtype==="complex64")}arraySync(){return Bo(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();let e=br().read(this.dataId);if(this.dtype==="string"){let t=await e;try{return t.map(n=>bh(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),br().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();let e=br().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>bh(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();let e=await br().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),br().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Oo.print(this,e)}clone(){return this.throwIfDisposed(),Oo.clone(this)}toString(e=!1){let t=this.dataSync();return pA(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Oo.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),br().makeVariable(this,e,t,n)}};Object.defineProperty(Fe,Symbol.hasInstance,{value:e=>!!e&&e.data!=null&&e.dataSync!=null&&e.throwIfDisposed!=null});function J(){return ig("Tensor",()=>Fe)}J();var Ms=class extends Fe{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!pa(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);br().disposeTensor(this),this.dataId=e.dataId,br().incRef(this,null)}dispose(){br().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(Ms,Symbol.hasInstance,{value:e=>e instanceof Fe&&e.assign!=null&&e.assign instanceof Function});var xr={};Ee(xr,{assertTypesMatch:()=>H0,getTensorsInContainer:()=>lg,isTensorInList:()=>mA,makeTypesMatch:()=>kt});var Xf;(function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"})(Xf||(Xf={}));var Zf;(function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"})(Zf||(Zf={}));var Jf;(function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"})(Jf||(Jf={}));var Yf;(function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"})(Yf||(Yf={}));var Qf;(function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"})(Qf||(Qf={}));var fA={float32:Yf,int32:Zf,bool:Jf,complex64:Qf};function tr(e,t){if(e==="string"||t==="string"){if(e==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return fA[e][t]}function uc(e){return tr(e,"int32")}function U0(e){return e!=null&&typeof e=="object"&&"texture"in e&&e.texture instanceof WebGLTexture}function G0(e){return typeof GPUBuffer<"u"&&e!=null&&typeof e=="object"&&"buffer"in e&&e.buffer instanceof GPUBuffer}function kt(e,t){if(e.dtype===t.dtype)return[e,t];let n=tr(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function H0(e,t){$(e.dtype===t.dtype,()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`)}function mA(e,t){return t.some(n=>n.id===e.id)}function lg(e){let t=[];return j0(e,t,new Set),t}function j0(e,t,n){if(e==null)return;if(e instanceof Fe){t.push(e);return}if(!gA(e))return;let r=e;for(let a in r){let s=r[a];n.has(s)||(n.add(s),j0(s,t,n))}}function gA(e){return Array.isArray(e)||typeof e=="object"}function $f(e){return e.kernelName!=null}var zv=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}},ug=class em{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new zv}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let t=this.getSortedBackends();for(let n=0;n<t.length;n++){let r=t[n];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:t,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){let{asyncInit:n}=this.initializeBackend(t);if(n)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,n,r=1){return t in this.registryFactory?(_a(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:n,priority:r},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;let{success:n,asyncInit:r}=this.initializeBackend(t);if(!(r?await n:n))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new sA(this.backendInstance),!0}setupRegisteredKernels(){yh(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){yh(t).forEach(n=>{n.disposeFunc!=null&&n.disposeFunc(this.registry[t])})}initializeBackend(t){let n=this.registryFactory[t];if(n==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{let r=n.factory();if(r&&!(r instanceof wp)&&typeof r.then=="function"){let a=++this.pendingBackendInitId,s=r.then(i=>a<this.pendingBackendInitId?!1:(this.registry[t]=i,this.pendingBackendInit=null,!0)).catch(i=>(a<this.pendingBackendInitId||(this.pendingBackendInit=null,_a(`Initialization of backend ${t} failed`),_a(i.stack||i.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}else return this.registry[t]=r,{success:!0,asyncInit:!1}}catch(r){return _a(`Initialization of backend ${t} failed`),_a(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,n)=>this.registryFactory[n].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){let t=this.getSortedBackends();for(let n=0;n<t.length;n++){let r=t[n],{success:a,asyncInit:s}=this.initializeBackend(r);if(s||a)return{name:r,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,n){let r=this.state.tensorInfo.get(n),a=r.backend,s=this.readSync(n),i=a.refCount(n);a.disposeData(n,!0),r.backend=t,t.move(n,s,r.shape,r.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,n){let r=null;if(n==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");n=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=t}let a;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(a),()=>(a=n(),a instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),a))}scopedRun(t,n,r){t();try{let a=r();return n(),a}catch(a){throw n(),a}}nextTensorId(){return em.nextTensorId++}nextVariableId(){return em.nextVariableId++}clone(t){let n=O.runKernel(_i,{x:t}),r={x:t},a=i=>({x:()=>{let o="float32",l={x:i},p={dtype:o};return O.runKernel(ui,l,p)}}),s=[];return this.addTapeNode(this.state.activeScope.name,r,[n],a,s,{}),n}runKernel(t,n,r){if(this.backendName==null&&this.backend,sp(t,this.backendName)==null)throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:n,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,n,r){let a=this.backend.numDataIds(),s=0;r.forEach(l=>{s+=l.dtype==="complex64"?3:1});let i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=a-n-s-i;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${t}'`)}runKernelFunc(t){let n,r=[],a=this.isTapeOn(),s=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let o;this.backendName==null&&this.backend;let l,p=$f(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if($f(t)){let{kernelName:f,inputs:m,attrs:g}=t;this.backendName==null&&this.backend;let y=sp(f,this.backendName);$(y!=null,()=>`Cannot find registered kernel '${f}' for backend '${this.backendName}'`),o=()=>{let b=this.backend.numDataIds();l=y.kernelFunc({inputs:m,attrs:g,backend:this.backend});let x=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(f,b,x);let v=x.map(I=>I.rank!=null?I:this.makeTensorFromTensorInfo(I));if(a){let I=this.getTensorsForGradient(f,m,v);r=this.saveTensorsForBackwardMode(I)}return v}}else{let{forwardFunc:f}=t,m=g=>{a&&(r=g.map(y=>this.keep(this.clone(y))))};o=()=>{let g=this.backend.numDataIds();l=this.tidy(()=>f(this.backend,m));let y=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(p,g,y),y}}let{inputs:u,attrs:d}=t,h=$f(t)?null:t.backwardsFunc,c;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=o():(c=this.profiler.profileKernel(p,u,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(c),n=c.outputs)}),a&&this.addTapeNode(p,u,n,h,r,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:p,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map(f=>u[f]!=null?u[f].shape:null),outputShapes:n.map(f=>f.shape),kernelTimeMs:c.timeMs,extraInfo:c.extraInfo}),Array.isArray(l)?n:n[0]}saveTensorsForBackwardMode(t){return t.map(n=>this.keep(this.clone(n)))}getTensorsForGradient(t,n,r){let a=qf(t);if(a!=null){let s=a.inputsToSave||[],i=a.outputsToSave||[],o;a.saveAllInputs?($(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(n).map(p=>n[p])):o=s.map(p=>n[p]);let l=r.filter((p,u)=>i[u]);return o.concat(l)}return[]}makeTensor(t,n,r,a){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",a=a||this.backend;let s=t;r==="string"&&Ea(t[0])&&(s=t.map(l=>jp(l)));let i=a.write(s,n,r),o=new Fe(n,r,i,this.nextTensorId());if(this.trackTensor(o,a),r==="string"){let l=this.state.tensorInfo.get(i),p=E0(s);this.state.numBytes+=p-l.bytes,l.bytes=p}return o}makeTensorFromDataId(t,n,r,a){r=r||"float32";let s={dataId:t,shape:n,dtype:r};return this.makeTensorFromTensorInfo(s,a)}makeTensorFromTensorInfo(t,n){let{dataId:r,shape:a,dtype:s}=t,i=new Fe(a,s,r,this.nextTensorId());return this.trackTensor(i,n),i}makeVariable(t,n=!0,r,a){r=r||this.nextVariableId().toString(),a!=null&&a!==t.dtype&&(t=t.cast(a));let s=new Ms(t,n,r,this.nextTensorId());if(this.state.registeredVariables[s.name]!=null)throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(t,n){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let r=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(r=t.size*fh(t.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:n||this.backend,dtype:t.dtype,shape:t.shape,bytes:r})),t instanceof Ms||this.track(t)}incRef(t,n){this.trackTensor(t,n),this.backend.incRef(t.dataId)}removeDataId(t,n){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===n&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;let n=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){let r=t.size*fh(t.dtype);this.state.numBytes-=r}n.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,n.backend)}disposeVariables(){for(let t in this.state.registeredVariables){let n=this.state.registeredVariables[t];this.disposeVariable(n)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){let t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;let n=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(a=>a.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-r;for(let a of this.state.activeProfile.kernels)a.kernelTimeMs=await a.kernelTimeMs,a.extraInfo=await a.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,n,r,a,s,i){let o={id:this.state.nextTapeNodeId++,kernelName:t,inputs:n,outputs:r,saved:s},l=qf(t);l!=null&&(a=l.gradFunc),a!=null&&(o.gradient=p=>(p=p.map((u,d)=>{if(u==null){let h=r[d],c=qh(h.size,h.dtype);return this.makeTensor(c,h.shape,h.dtype)}return u}),a(p.length>1?p:p[0],s,i))),this.state.activeTape.push(o)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){let n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(n.name=t),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(t){let n=lg(t),r=new Set(n.map(s=>s.id));for(let s=0;s<this.state.activeScope.track.length;s++){let i=this.state.activeScope.track[s];!i.kept&&!r.has(i.id)&&i.dispose()}let a=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(s=>{!s.kept&&s.scopeId===a.id&&this.track(s)})}gradients(t,n,r,a=!1){if($(n.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);let s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));$(s instanceof Fe,()=>"The result y returned by f() must be a tensor.");let i=lA(this.state.activeTape,n,s);if(!a&&i.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let o={};o[s.id]=r??yA(s.shape),uA(o,i,p=>this.tidy(p),bA);let l=n.map(p=>o[p.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(p=>{for(let u of p.saved)u.dispose()}),this.state.activeTape=null),{value:s,grads:l}})}customGrad(t){return $(Oa(t),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{$(n.every(o=>o instanceof Fe),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r,a={};n.forEach((o,l)=>{a[l]=o});let s=(o,l)=>(r=t(...n,l),$(r.value instanceof Fe,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),$(Oa(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),i=(o,l)=>{let p=r.gradFunc(o,l),u=Array.isArray(p)?p:[p];$(u.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),$(u.every(h=>h instanceof Fe),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let d={};return u.forEach((h,c)=>{d[c]=()=>h}),d};return this.runKernelFunc({forwardFunc:s,backwardsFunc:i,inputs:a})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,n){return this.state.tensorInfo.get(t).backend.readToGPU(t,n)}async time(t){let n=ip(),r=await this.backend.time(t);return r.wallMs=ip()-n,r}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new zv;for(let t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};ug.nextTensorId=0;ug.nextVariableId=0;function yA(e){let t=ag(tt(e),"float32");return O.makeTensor(t,e,"float32")}function q0(){let e=D0();if(e._tfengine==null){let t=new R0(e);e._tfengine=new ug(t)}return W$(e._tfengine.ENV),hA(()=>e._tfengine),e._tfengine}var O=q0();function bA(e,t){let n={a:e,b:t};return O.runKernel(Ya,n)}var qp={};Ee(qp,{isBrowser:()=>K0,isMobile:()=>wA,mockIsMobile:()=>vA});function xA(){return typeof navigator<"u"&&navigator!=null}var tm;function vA(e){tm=e}function wA(e){if(tm!==void 0)return tm;if(e||xA()){if(e||(e=navigator),e.product==="ReactNative")return!0;let t=e.userAgent||e.vendor||(typeof window<"u"?window.opera:"");if(!t){let n=e;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function K0(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}var _n=G();_n.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});_n.registerFlag("IS_BROWSER",()=>K0());_n.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");_n.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));_n.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));_n.registerFlag("PROD",()=>!1);_n.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>_n.getBool("DEBUG"));_n.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);_n.registerFlag("IS_TEST",()=>!1);_n.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>_n.getBool("DEBUG"));_n.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);_n.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);_n.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function Ur(e,t){let n=e;if(Gt(e))return t==="string"?[]:[e.length];if(U0(e)){let a=e.channels||"RGBA";return[e.height,e.width*a.length]}else if(G0(e))return[e.buffer.size/(t==null?4:fh(t))];if(!Array.isArray(e))return[];let r=[];for(;Array.isArray(n)||Gt(n)&&t!=="string";)r.push(n.length),n=n[0];return Array.isArray(e)&&G().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&X0(e,r,[]),r}function X0(e,t,n){if(n=n||[],!Array.isArray(e)&&!Gt(e)){$(t.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}$(t.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`),$(e.length===t[0],()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);let r=t.slice(1);for(let a=0;a<e.length;++a)X0(e[a],r,n.concat(a))}function Pv(e,t,n,r){if(e!=="string_or_numeric"){if(e==null)throw new Error("Expected dtype cannot be null.");if(e!=="numeric"&&e!==t||e==="numeric"&&t==="string")throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function C(e,t,n,r="numeric"){if(e instanceof J())return Pv(r,e.dtype,t,n),e;let a=kp(e);if(a!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(a=r),Pv(r,a,t,n),e==null||!Gt(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string"){let o=e==null?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${o}'`)}let s=Ur(e,a);!Gt(e)&&!Array.isArray(e)&&(e=[e]);let i=a!=="string"?lc(e,a):La(e,[],!0);return O.makeTensor(i,s,a)}function op(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((a,s)=>C(a,`${t}[${s}]`,n,r))}var pg="__op";function L(e){let t=Object.keys(e);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0],r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+pg;let a=(...s)=>{O.startScope(n);try{let i=r(...s);return Kh(i)&&console.error("Cannot return a Promise inside of tidy."),O.endScope(i),i}catch(i){throw O.endScope(null),i}};return Object.defineProperty(a,"name",{value:n,configurable:!0}),a}function kA(e,t){let n=C(e,"real","complex"),r=C(t,"imag","complex");yn(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);let a={real:n,imag:r};return O.runKernel(Xh,a)}var la=L({complex_:kA});function ns(e,t,n,r){if(r==null)r=kp(e);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(G0(e)||U0(e)){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return O.backend.createTensorFromGPUData(e,t||n,r)}if(!Gt(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){Hn(t);let a=tt(t),s=tt(n);$(a===s,()=>`Based on the provided shape, [${t}], the tensor should have ${a} values but has ${s}`);for(let i=0;i<n.length;++i){let o=n[i],l=i===n.length-1?o!==tt(t.slice(i)):!0;$(n[i]===t[i]||!l,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return!Gt(e)&&!Array.isArray(e)&&(e=[e]),t=t||n,e=r!=="string"?lc(e,r):La(e,[],!0),O.makeTensor(e,t,r)}function cn(e,t,n){let r=Ur(e,n);return ns(e,t,r,n)}var Os={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},da=class Z0{static join(t){return new Z0(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,t==null||(t instanceof Array||(t=[t]),t=t.map(r=>Gt(r)?r.buffer:r),t.length===0))return;this.bufferUniformSize=t[0].byteLength;let n=0;for(let r=0;r<t.length;r++){let a=t[r];r!==t.length-1&&a.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);let s=n+a.byteLength;this.shards.push({buffer:a,start:n,end:s}),n=s}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,n=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,n=isNaN(Number(n))?0:n,t=Math.max(0,t),n=Math.min(this.byteLength,n),n<=t)return new ArrayBuffer(0);let r=this.findShardForByte(t);if(r===-1)throw new Error(`Could not find start shard for byte ${t}`);let a=n-t,s=new ArrayBuffer(a),i=new Uint8Array(s),o=0;for(let l=r;l<this.shards.length;l++){let p=this.shards[l],u=t+o-p.start,d=o,h=Math.min(n,p.end)-p.start,c=new Uint8Array(p.buffer,u,h-u);if(i.set(c,d),o+=c.length,n<p.end)break}return s}findShardForByte(t){if(this.shards.length===0||t<0||t>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function n(a){return t<a.start?-1:t>=a.end?1:0}if(n(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;let r=IA(this.shards,n);return r===-1?-1:(this.previousShardIndex=r,this.previousShardIndex)}};function IA(e,t){let n=0,r=e.length;for(;n<=r;){let a=Math.floor((r-n)/2)+n,s=t(e[a]);if(s===0)return a;s<0?r=a:n=a+1}return-1}function SA(){G().set("PROD",!0)}function NA(){G().set("DEBUG",!0)}function TA(){G().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function J0(e){G().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function CA(){O.disposeVariables()}function lr(){return O}function nm(){return O.memory()}function _A(e){return O.profile(e)}function B(e,t){return O.tidy(e,t)}function _e(e){lg(e).forEach(t=>t.dispose())}function Mt(e){return O.keep(e)}function EA(e){return O.time(e)}function $A(e){return O.setBackend(e)}function AA(){return O.ready()}function Y0(){return O.backendName}function FA(e){O.removeBackend(e)}function RA(e){return O.findBackend(e)}function DA(e){return O.findBackendFactory(e)}function pc(e,t,n=1){return O.registerBackend(e,t,n)}function dg(){return O.backend}function MA(e,t){G().setPlatform(e,t)}var za=4;async function OA(e,t){let n=[],r=[],a=Array.isArray(e)?e.map(i=>i.name):Object.keys(e);for(let i=0;i<a.length;++i){let o=a[i],l=Array.isArray(e)?e[i].tensor:e[o];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${o}': ${l.dtype}`);let p={name:o,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){let u=new Promise(async d=>{let h=await l.bytes(),c=h.reduce((g,y)=>g+y.length,0)+za*h.length,f=new Uint8Array(c),m=0;for(let g=0;g<h.length;g++){let y=h[g],b=new Uint8Array(new Uint32Array([y.length]).buffer);f.set(b,m),m+=za,f.set(y,m),m+=y.length}d(f)});r.push(u)}else r.push(l.data());t!=null&&(p.group=t),n.push(p)}let s=await Promise.all(r);return{data:PA(s),specs:n}}function Q0(e,t){let n=new da(e),r={},a=0;for(let s of t){let i=LA(s,(o,l)=>n.slice(a+o,a+l));r[s.name]=e1(s,n.slice(a,a+i)),a+=i}return r}function LA(e,t){let n=tt(e.shape),r;if("quantization"in e){let a=e.quantization;r=Os[a.dtype]}else if(e.dtype==="string"){let a=0;for(let s=0;s<n;s++)a+=za+new Uint32Array(t(a,a+za))[0];return a}else r=Os[e.dtype];return n*r}async function zA(e,t){let n=tt(e.shape),r;if("quantization"in e){let a=e.quantization;r=Os[a.dtype]}else if(e.dtype==="string"){let a=0;for(let s=0;s<n;s++)a+=za+new Uint32Array(await t(a,a+za))[0];return a}else r=Os[e.dtype];return n*r}function e1(e,t){let n=e.name,r=e.dtype,a=e.shape,s=tt(a),i,o=0;if("quantization"in e){let l=e.quantization;if(l.dtype==="uint8"||l.dtype==="uint16"){if(!("min"in l&&"scale"in l))throw new Error(`Weight ${e.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else if(l.dtype==="float16"){if(r!=="float32")throw new Error(`Weight ${e.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${r}.`)}else throw new Error(`Weight ${e.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let p=Os[l.dtype],u=l.dtype==="uint8"?new Uint8Array(t):new Uint16Array(t);if(r==="float32")if(l.dtype==="uint8"||l.dtype==="uint16"){i=new Float32Array(u.length);for(let d=0;d<u.length;d++){let h=u[d];i[d]=h*l.scale+l.min}}else if(l.dtype==="float16")i=jA()(u);else throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);else if(r==="int32"){if(l.dtype!=="uint8"&&l.dtype!=="uint16")throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);i=new Int32Array(u.length);for(let d=0;d<u.length;d++){let h=u[d];i[d]=Math.round(h*l.scale+l.min)}}else throw new Error(`Unsupported dtype in weight '${n}': ${r}`);o+=s*p}else if(r==="string"){let l=tt(e.shape);i=[];for(let p=0;p<l;p++){let u=new Uint32Array(t.slice(o,o+za))[0];o+=za;let d=new Uint8Array(t.slice(o,o+u));i.push(d),o+=u}}else{let l=Os[r];if(r==="float32")i=new Float32Array(t);else if(r==="int32")i=new Int32Array(t);else if(r==="bool")i=new Uint8Array(t);else if(r==="complex64"){i=new Float32Array(t);let p=new Float32Array(i.length/2),u=new Float32Array(i.length/2);for(let f=0;f<p.length;f++)p[f]=i[f*2],u[f]=i[f*2+1];let d=cn(p,a,"float32"),h=cn(u,a,"float32"),c=la(d,h);return d.dispose(),h.dispose(),c}else throw new Error(`Unsupported dtype in weight '${n}': ${r}`);o+=s*l}return cn(i,a,r)}async function Bv(e,t,n){let r=new Uint8Array(t);for(;r.byteLength<n;){let{done:a,value:s}=await e.read();if(a&&s==null){let o=n-r.byteLength;throw new Error(`Reader is done but ${o} bytes are still expected`)}let i=new Uint8Array(r.length+s.byteLength);i.set(r,0),i.set(new Uint8Array(s),r.length),r=i}return r.buffer}async function t1(e,t){let n={},r=e.getReader(),a=new ArrayBuffer(0);for(let s of t){let i=await zA(s,async(p,u)=>(a=await Bv(r,a,u),a.slice(p,u)));a=await Bv(r,a,i);let o=a.slice(0,i);a=a.slice(i);let l=e1(s,o);if(n[s.name]=l,Y0()==="webgpu"){let p=dg();"uploadToGPU"in p&&tt(l.shape)>=G().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&p.uploadToGPU(l.dataId)}}return n}function PA(e){if(e===null)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0,n=[];e.forEach(s=>{if(t+=s.byteLength,n.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});let r=new Uint8Array(t),a=0;return n.forEach(s=>{r.set(new Uint8Array(s.buffer),a),a+=s.byteLength}),r.buffer}var hg=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function Wv(e){return hg?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function BA(e){if(hg)return Buffer.from(e).toString("base64");let t=new Uint8Array(e),n="";for(let r=0,a=t.length;r<a;r++)n+=String.fromCharCode(t[r]);return btoa(n)}function WA(e){if(hg){let r=Buffer.from(e,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}let t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}function VA(e){return da.join(e)}function Vv(e){let t="/";for(e=e.trim();e.endsWith(t);)e=e.slice(0,e.length-1);let n=e.split(t);return n[n.length-1]}function n1(e,t){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return e.signature!=null&&(n.signature=e.signature),e.userDefinedMetadata!=null&&(n.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(n.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(n.initializerSignature=e.initializerSignature),e.trainingConfig!=null&&(n.trainingConfig=e.trainingConfig),n}function r1(e,t,n){let r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(e.trainingConfig!=null&&(r.trainingConfig=e.trainingConfig),e.weightsManifest!=null){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return e.signature!=null&&(r.signature=e.signature),e.userDefinedMetadata!=null&&(r.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(r.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(r.initializerSignature=e.initializerSignature),r}async function cg(e,t){let n,r;return e.weightsManifest!=null&&([n,r]=await t(e.weightsManifest)),r1(e,n,r)}function Kp(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:e.modelTopology==null?0:Wv(JSON.stringify(e.modelTopology)),weightSpecsBytes:e.weightSpecs==null?0:Wv(JSON.stringify(e.weightSpecs)),weightDataBytes:e.weightData==null?0:new da(e.weightData).byteLength}}function rm(e){let t=[];for(let n of e)t.push(...n.weights);return t}function UA(){let e=n=>{let r=n<<13,a=0;for(;!(r&8388608);)a-=8388608,r<<=1;return r&=-8388609,a+=947912704,r|a},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}function GA(){let e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}function HA(){let e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}function jA(){let e=UA(),t=GA(),n=HA();return r=>{let a=new ArrayBuffer(4*r.length),s=new Uint32Array(a);for(let i=0;i<r.length;i++){let o=r[i],l=e[n[o>>10]+(o&1023)]+t[o>>10];s[i]=l}return new Float32Array(a)}}var nr=class gr{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return gr.instance==null&&(gr.instance=new gr),gr.instance}static registerSaveRouter(t){gr.getInstance().saveRouters.push(t)}static registerLoadRouter(t){gr.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return gr.getHandlers(t,"save")}static getLoadHandlers(t,n){return gr.getHandlers(t,"load",n)}static getHandlers(t,n,r){let a=[];return(n==="load"?gr.getInstance().loadRouters:gr.getInstance().saveRouters).forEach(s=>{let i=s(t,r);i!==null&&a.push(i)}),a}},qA=e=>nr.registerSaveRouter(e),KA=e=>nr.registerLoadRouter(e),XA=e=>nr.getSaveHandlers(e),ZA=(e,t)=>nr.getLoadHandlers(e,t),am="tensorflowjs",sm=1,Ts="models_store",$a="model_info_store";function a1(){if(!G().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let e=typeof window>"u"?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function im(e){let t=e.result;t.createObjectStore(Ts,{keyPath:"modelPath"}),t.createObjectStore($a,{keyPath:"modelPath"})}var Ls=class{constructor(e){if(this.indexedDB=a1(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((n,r)=>{let a=this.indexedDB.open(am,sm);a.onupgradeneeded=()=>im(a),a.onsuccess=()=>{let s=a.result;if(t==null){let i=s.transaction(Ts,"readonly"),o=i.objectStore(Ts).get(this.modelPath);o.onsuccess=()=>{if(o.result==null)return s.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));n(o.result.modelArtifacts)},o.onerror=l=>(s.close(),r(o.error)),i.oncomplete=()=>s.close()}else{t.weightData=da.join(t.weightData);let i=Kp(t),o=s.transaction($a,"readwrite"),l=o.objectStore($a),p;try{p=l.put({modelPath:this.modelPath,modelArtifactsInfo:i})}catch(d){return r(d)}let u;p.onsuccess=()=>{u=s.transaction(Ts,"readwrite");let d=u.objectStore(Ts),h;try{h=d.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:i})}catch(c){return r(c)}h.onsuccess=()=>n({modelArtifactsInfo:i}),h.onerror=c=>{l=o.objectStore($a);let f=l.delete(this.modelPath);f.onsuccess=()=>(s.close(),r(h.error)),f.onerror=m=>(s.close(),r(h.error))}},p.onerror=d=>(s.close(),r(p.error)),o.oncomplete=()=>{u==null?s.close():u.oncomplete=()=>s.close()}}},a.onerror=s=>r(a.error)})}};Ls.URL_SCHEME="indexeddb://";var s1=e=>G().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Ls.URL_SCHEME)?JA(e.slice(Ls.URL_SCHEME.length)):null;nr.registerSaveRouter(s1);nr.registerLoadRouter(s1);function JA(e){return new Ls(e)}function YA(e){return e.startsWith(Ls.URL_SCHEME)?e.slice(Ls.URL_SCHEME.length):e}var QA=class{constructor(){this.indexedDB=a1()}async listModels(){return new Promise((e,t)=>{let n=this.indexedDB.open(am,sm);n.onupgradeneeded=()=>im(n),n.onsuccess=()=>{let r=n.result,a=r.transaction($a,"readonly"),s=a.objectStore($a).getAll();s.onsuccess=()=>{let i={};for(let o of s.result)i[o.modelPath]=o.modelArtifactsInfo;e(i)},s.onerror=i=>(r.close(),t(s.error)),a.oncomplete=()=>r.close()},n.onerror=r=>t(n.error)})}async removeModel(e){return e=YA(e),new Promise((t,n)=>{let r=this.indexedDB.open(am,sm);r.onupgradeneeded=()=>im(r),r.onsuccess=()=>{let a=r.result,s=a.transaction($a,"readwrite"),i=s.objectStore($a),o=i.get(e),l;o.onsuccess=()=>{if(o.result==null)return a.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{let p=i.delete(e),u=()=>{l=a.transaction(Ts,"readwrite");let d=l.objectStore(Ts).delete(e);d.onsuccess=()=>t(o.result.modelArtifactsInfo),d.onerror=h=>n(o.error)};p.onsuccess=u,p.onerror=d=>(u(),a.close(),n(o.error))}},o.onerror=p=>(a.close(),n(o.error)),s.oncomplete=()=>{l==null?a.close():l.oncomplete=()=>a.close()}},r.onerror=a=>n(r.error)})}},aa="/",Lo="tensorflowjs_models",i1="info",eF="model_topology",tF="weight_specs",nF="weight_data",rF="model_metadata";function o1(e){return{info:[Lo,e,i1].join(aa),topology:[Lo,e,eF].join(aa),weightSpecs:[Lo,e,tF].join(aa),weightData:[Lo,e,nF].join(aa),modelMetadata:[Lo,e,rF].join(aa)}}function l1(e){for(let t of Object.values(e))window.localStorage.removeItem(t)}function aF(e){let t=e.split(aa);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(aa)}function sF(e){return e.startsWith(zs.URL_SCHEME)?e.slice(zs.URL_SCHEME.length):e}var zs=class{constructor(e){if(!G().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=o1(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),r=Kp(e),a=da.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,BA(a));let s={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:r}}catch{throw l1(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;let r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;let a=this.LS.getItem(this.keys.modelMetadata);if(a!=null){let i=JSON.parse(a);t.format=i.format,t.generatedBy=i.generatedBy,t.convertedBy=i.convertedBy,i.signature!=null&&(t.signature=i.signature),i.userDefinedMetadata!=null&&(t.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(t.modelInitializer=i.modelInitializer),i.initializerSignature!=null&&(t.initializerSignature=i.initializerSignature),i.trainingConfig!=null&&(t.trainingConfig=i.trainingConfig)}let s=this.LS.getItem(this.keys.weightData);if(s==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=WA(s),t}};zs.URL_SCHEME="localstorage://";var u1=e=>G().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(zs.URL_SCHEME)?iF(e.slice(zs.URL_SCHEME.length)):null;nr.registerSaveRouter(u1);nr.registerLoadRouter(u1);function iF(e){return new zs(e)}var oF=class{constructor(){$(G().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),$(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let e={},t=Lo+aa,n=aa+i1;for(let r=0;r<this.LS.length;++r){let a=this.LS.key(r);if(a.startsWith(t)&&a.endsWith(n)){let s=aF(a);e[s]=JSON.parse(this.LS.getItem(a))}}return e}async removeModel(e){e=sF(e);let t=o1(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);let n=JSON.parse(this.LS.getItem(t.info));return l1(t),n}},Wo="://",Pa=class Ia{constructor(){this.managers={}}static getInstance(){return Ia.instance==null&&(Ia.instance=new Ia),Ia.instance}static registerManager(t,n){$(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(Wo)&&(t=t.slice(0,t.indexOf(Wo))),$(t.length>0,()=>"scheme must not be an empty string.");let r=Ia.getInstance();$(r.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),r.managers[t]=n}static getManager(t){let n=Ia.getInstance().managers[t];if(n==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return n}static getSchemes(){return Object.keys(Ia.getInstance().managers)}};function sh(e){if(e.indexOf(Wo)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Pa.getSchemes().join(",")}`);return{scheme:e.split(Wo)[0],path:e.split(Wo)[1]}}async function p1(e,t,n=!1){$(e!==t,()=>`Old path and new path are the same: '${e}'`);let r=nr.getLoadHandlers(e);$(r.length>0,()=>`Copying failed because no load handler is found for source URL ${e}.`),$(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`);let a=r[0],s=nr.getSaveHandlers(t);$(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),$(s.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`);let i=s[0],o=sh(e).scheme,l=sh(e).path,p=o===sh(e).scheme,u=await a.load();n&&p&&await Pa.getManager(o).removeModel(l);let d=await i.save(u);return n&&!p&&await Pa.getManager(o).removeModel(l),d.modelArtifactsInfo}async function lF(){let e=Pa.getSchemes(),t={};for(let n of e){let r=await Pa.getManager(n).listModels();for(let a in r){let s=n+Wo+a;t[s]=r[a]}}return t}async function uF(e){let t=sh(e);return Pa.getManager(t.scheme).removeModel(t.path)}async function pF(e,t){return p1(e,t,!1)}async function dF(e,t){return p1(e,t,!0)}var hF=class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!G().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",n=>{if(n.source===window&&n.data.name===this.messageName){n.stopPropagation();let r=this.functionRefs[n.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return P0(e)}};if(G().get("IS_BROWSER")){G().setPlatform("browser",new hF);try{Pa.registerManager(zs.URL_SCHEME,new oF)}catch{}try{Pa.registerManager(Ls.URL_SCHEME,new QA)}catch{}}var cF={importFetch:()=>i$()},Af,fF=class{constructor(){this.util=o$(),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return G().global.fetch!=null?G().global.fetch(e,t):(Af==null&&(Af=cF.importFetch()),Af(e,t))}now(){let e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}};G().get("IS_NODE")&&!G().get("IS_BROWSER")&&G().setPlatform("node",new fF);function ze(e,t="float32",n){return t=t||"float32",Hn(e),new $t(e,t,n)}function mF(e,t){let n=C(e,"x","cast");if(!_0(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&n.dtype!=="string"||t!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");let r={x:n},a={dtype:t};return O.runKernel(ui,r,a)}var se=L({cast_:mF});function gF(e){let t={x:C(e,"x","clone","string_or_numeric")};return O.runKernel(_i,t)}var Br=L({clone_:gF});function fg(e,t=!1){console.log(e.toString(t))}q0();var yF={buffer:ze,cast:se,clone:Br,print:fg};cA(yF);function bF(e,t){let n=C(e,"a","add"),r=C(t,"b","add");[n,r]=kt(n,r);let a={a:n,b:r};return O.runKernel(Ya,a)}var X=L({add_:bF});function xF(e,t){let n=C(e,"a","floorDiv"),r=C(t,"b","floorDiv");[n,r]=kt(n,r);let a={a:n,b:r};return O.runKernel(Ni,a)}var dc=L({floorDiv_:xF});function vF(e,t){let n=C(e,"a","div"),r=C(t,"b","div");if([n,r]=kt(n,r),n.dtype==="int32"&&r.dtype==="int32")return dc(n,r);let a={a:n,b:r},s={};return O.runKernel(xi,a,s)}var fe=L({div_:vF});function wF(e,t){let n=C(e,"a","mul"),r=C(t,"b","mul");[n,r]=kt(n,r);let a={a:n,b:r};return O.runKernel(Gi,a)}var z=L({mul_:wF});function kF(e){let t=C(e,"x","abs");if(t.dtype==="complex64"){let n={x:t};return O.runKernel(Tp,n)}else{let n={x:t};return O.runKernel(pl,n)}}var _t=L({abs_:kF});function IF(e){let t={x:C(e,"x","acos")};return O.runKernel(Qs,t)}var mg=L({acos_:IF});function SF(e){let t={x:C(e,"x","acosh")};return O.runKernel(ei,t)}var gg=L({acosh_:SF});function NF(e){$(Array.isArray(e),()=>"The argument passed to tf.addN() must be a list of tensors"),$(e.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`);let t=e.map((a,s)=>C(a,`tensors${s}`,"addN")),n=t[0];t.forEach(a=>{if(a.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(a=>{if(!pa(a.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let r=t;return O.runKernel(ti,r)}var d1=L({addN_:NF});function TF(e,t=null,n=!1){let r={x:C(e,"x","all","bool")},a={axis:t,keepDims:n};return O.runKernel(dl,r,a)}var hc=L({all_:TF});function CF(e,t=null,n=!1){let r={x:C(e,"x","any","bool")},a={axis:t,keepDims:n};return O.runKernel(hl,r,a)}var lp=L({any_:CF});function _F(e,t=0){let n={x:C(e,"x","argMax")},r={axis:t};return O.runKernel(cl,n,r)}var Ps=L({argMax_:_F});function EF(e,t=0){let n={x:C(e,"x","argMin")},r={axis:t};return O.runKernel(fl,n,r)}var yg=L({argMin_:EF});function $F(e){let t={x:C(e,"x","asin")};return O.runKernel(ni,t)}var bg=L({asin_:$F});function AF(e){let t={x:C(e,"x","asinh")};return O.runKernel(ri,t)}var xg=L({asinh_:AF});function FF(e){let t={x:C(e,"x","atan")};return O.runKernel(ai,t)}var vg=L({atan_:FF});function RF(e,t){let n=C(e,"a","atan2"),r=C(t,"b","atan2");[n,r]=kt(n,r);let a={a:n,b:r};return O.runKernel(ii,a)}var wg=L({atan2_:RF});function DF(e){let t={x:C(e,"x","atanh")};return O.runKernel(si,t)}var kg=L({atanh_:DF});function MF(e,t,n,r,a="NHWC",s){let i=e[3],o=[...t,i],l=f1(a);return Xp(e,o,n,s,r,null,null,l)}function h1(e,t,n,r,a,s,i="channelsLast"){let[o,l]=up(t),p;if(i==="channelsLast")p=[o,l,e[3],e[3]];else if(i==="channelsFirst")p=[o,l,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return Xp(e,p,n,r,a,s,!1,i)}function OF(e,t,n,r,a,s,i="NDHWC"){let[o,l,p]=om(t),u,d;if(i==="NDHWC")d="channelsLast",u=[o,l,p,e[4],e[4]];else if(i==="NCDHW")d="channelsFirst",u=[o,l,p,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return c1(e,u,n,r,a,!1,d,s)}function Xp(e,t,n,r,a,s,i=!1,o="channelsLast"){let[l,p,u,d]=[-1,-1,-1,-1];if(o==="channelsLast")[l,p,u,d]=e;else if(o==="channelsFirst")[l,d,p,u]=e;else throw new Error(`Unknown dataFormat ${o}`);let[h,c,,f]=t,[m,g]=up(n),[y,b]=up(r),x=Vo(h,y),v=Vo(c,b),{padInfo:I,outHeight:T,outWidth:_}=PF(a,p,u,m,g,x,v,s,o),E=i?f*d:f,A;return o==="channelsFirst"?A=[l,E,T,_]:o==="channelsLast"&&(A=[l,T,_,E]),{batchSize:l,dataFormat:o,inHeight:p,inWidth:u,inChannels:d,outHeight:T,outWidth:_,outChannels:E,padInfo:I,strideHeight:m,strideWidth:g,filterHeight:h,filterWidth:c,effectiveFilterHeight:x,effectiveFilterWidth:v,dilationHeight:y,dilationWidth:b,inShape:e,outShape:A,filterShape:t}}function c1(e,t,n,r,a,s=!1,i="channelsLast",o){let[l,p,u,d,h]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[l,p,u,d,h]=e;else if(i==="channelsFirst")[l,h,p,u,d]=e;else throw new Error(`Unknown dataFormat ${i}`);let[c,f,m,,g]=t,[y,b,x]=om(n),[v,I,T]=om(r),_=Vo(c,v),E=Vo(f,I),A=Vo(m,T),{padInfo:R,outDepth:F,outHeight:S,outWidth:M}=BF(a,p,u,d,y,b,x,_,E,A,o),W=s?g*h:g,U;return i==="channelsFirst"?U=[l,W,F,S,M]:i==="channelsLast"&&(U=[l,F,S,M,W]),{batchSize:l,dataFormat:i,inDepth:p,inHeight:u,inWidth:d,inChannels:h,outDepth:F,outHeight:S,outWidth:M,outChannels:W,padInfo:R,strideDepth:y,strideHeight:b,strideWidth:x,filterDepth:c,filterHeight:f,filterWidth:m,effectiveFilterDepth:_,effectiveFilterHeight:E,effectiveFilterWidth:A,dilationDepth:v,dilationHeight:I,dilationWidth:T,inShape:e,outShape:U,filterShape:t}}function LF(e,t,n,r,a){r==null&&(r=Ig(e,t,n));let s=e[0],i=e[1],o=pp((s-t+2*r)/n+1,a),l=pp((i-t+2*r)/n+1,a);return[o,l]}function zF(e,t,n,r,a,s){a==null&&(a=Ig(e,t[0],r[0]));let i=[0,0,0,n];for(let o=0;o<3;o++)e[o]+2*a>=t[o]&&(i[o]=pp((e[o]-t[o]+2*a)/r[o]+1,s));return i}function Ig(e,t,n,r=1){let a=Vo(t,r);return Math.floor((e[0]*(n-1)-n+a)/2)}function up(e){return typeof e=="number"?[e,e,e]:e.length===2?[e[0],e[1],1]:e}function om(e){return typeof e=="number"?[e,e,e]:e}function Vo(e,t){return t<=1?e:e+(e-1)*(t-1)}function PF(e,t,n,r,a,s,i,o,l){let p,u,d;if(typeof e=="number"){p={top:e,bottom:e,left:e,right:e,type:e===0?"VALID":"NUMBER"};let h=LF([t,n],s,r,e,o);u=h[0],d=h[1]}else if(e==="same"){u=Math.ceil(t/r),d=Math.ceil(n/a);let h=Math.max(0,(u-1)*r+s-t),c=Math.max(0,(d-1)*a+i-n),f=Math.floor(h/2),m=h-f,g=Math.floor(c/2),y=c-g;p={top:f,bottom:m,left:g,right:y,type:"SAME"}}else if(e==="valid")p={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((t-s+1)/r),d=Math.ceil((n-i+1)/a);else if(typeof e=="object"){let h=l==="channelsLast"?e[1][0]:e[2][0],c=l==="channelsLast"?e[1][1]:e[2][1],f=l==="channelsLast"?e[2][0]:e[3][0],m=l==="channelsLast"?e[2][1]:e[3][1];p={top:h,bottom:c,left:f,right:m,type:h===0&&c===0&&f===0&&m===0?"VALID":"EXPLICIT"},u=pp((t-s+h+c)/r+1,o),d=pp((n-i+f+m)/a+1,o)}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:p,outHeight:u,outWidth:d}}function BF(e,t,n,r,a,s,i,o,l,p,u){let d,h,c,f;if(e==="valid"&&(e=0),typeof e=="number"){d={top:e,bottom:e,left:e,right:e,front:e,back:e,type:e===0?"VALID":"NUMBER"};let m=zF([t,n,r,1],[o,l,p],1,[a,s,i],e,u);h=m[0],c=m[1],f=m[2]}else if(e==="same"){h=Math.ceil(t/a),c=Math.ceil(n/s),f=Math.ceil(r/i);let m=(h-1)*a+o-t,g=(c-1)*s+l-n,y=(f-1)*i+p-r,b=Math.floor(m/2),x=m-b,v=Math.floor(g/2),I=g-v,T=Math.floor(y/2),_=y-T;d={top:v,bottom:I,left:T,right:_,front:b,back:x,type:"SAME"}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:d,outDepth:h,outHeight:c,outWidth:f}}function pp(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function Ba(e){let[t,n,r]=up(e);return t===1&&n===1&&r===1}function qr(e,t){return Ba(e)||Ba(t)}function Bs(e){return up(e).every(t=>t>0)}function f1(e){if(e==="NHWC")return"channelsLast";if(e==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function bn(e,t,n){if(n!=null){if(typeof t=="string")throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if(typeof t=="number")$(Ho(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);else if(typeof t=="object")t.forEach(r=>{r.forEach(a=>{$(Ho(a),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${a}.`)})});else throw Error(`Error in ${e}: Unknown padding parameter: ${t}`)}}function WF(e,t){let n={x:C(e,"x","reshape","string_or_numeric")},r={shape:t};return O.runKernel(Kl,n,r)}var P=L({reshape_:WF});function VF(e,t,n,r,a){let s=C(e,"x","avgPool","float32"),i=1;$(qr(n,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);let o=s,l=!1;s.rank===3&&(l=!0,o=P(s,[1,s.shape[0],s.shape[1],s.shape[2]])),$(o.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),bn("avgPool",r,a);let p={x:o},u={filterSize:t,strides:n,pad:r,dimRoundingMode:a},d=O.runKernel(oi,p,u);return d=se(d,s.dtype),l?P(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var ha=L({avgPool_:VF});function UF(e,t,n,r,a,s="NDHWC"){let i=C(e,"x","avgPool3d","float32"),o=i,l=!1;i.rank===4&&(l=!0,o=P(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),$(o.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),$(s==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),$(typeof n=="number"&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),bn("avgPool3d",r,a);let p={x:o},u={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:s},d=O.runKernel(ml,p,u);return d=se(d,o.dtype),l?P(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var Sg=L({avgPool3d_:UF});function GF(e,t=0){$(e.length>=1,()=>"Pass at least one tensor to concat");let n=op(e,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(s=>{if(s.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `)}),n.length===1)return Br(n[0]);let r=n,a={axis:t};return O.runKernel(xl,r,a)}var it=L({concat_:GF});function HF(e,t,n=!1,r=!1){let a=C(e,"a","matMul"),s=C(t,"b","matMul");[a,s]=kt(a,s);let i={a,b:s},o={transposeA:n,transposeB:r};return O.runKernel(li,i,o)}var Oe=L({matMul_:HF});function jF(e){let t={x:C(e,"x","sigmoid","float32")};return O.runKernel(lo,t)}var pr=L({sigmoid_:jF});function qF(e,t,n){let r=C(e,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");let a={x:r},s={begin:t,size:n};return O.runKernel(tu,a,s)}var Ue=L({slice_:qF});function KF(e){let t={x:C(e,"x","tanh","float32")};return O.runKernel(yo,t)}var Wa=L({tanh_:KF});function XF(e,t,n,r,a,s){let i=C(e,"forgetBias","basicLSTMCell"),o=C(t,"lstmKernel","basicLSTMCell"),l=C(n,"lstmBias","basicLSTMCell"),p=C(r,"data","basicLSTMCell"),u=C(a,"c","basicLSTMCell"),d=C(s,"h","basicLSTMCell"),h=it([p,d],1),c=Oe(h,o),f=X(c,l),m=f.shape[0],g=f.shape[1]/4,y=[m,g],b=Ue(f,[0,0],y),x=Ue(f,[0,g],y),v=Ue(f,[0,g*2],y),I=Ue(f,[0,g*3],y),T=X(z(pr(b),Wa(x)),z(u,pr(X(i,v)))),_=z(Wa(T),pr(I));return[T,_]}var m1=L({basicLSTMCell_:XF});function ZF(e,t,n){let r=C(e,"x","batchToSpaceND"),a=t.reduce((o,l)=>o*l);$(r.rank>=1+t.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`),$(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),$(r.shape[0]%a===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${a}`);let s={x:r},i={blockShape:t,crops:n};return O.runKernel(gl,s,i)}var Zp=L({batchToSpaceND_:ZF});function JF(e){let t;return e.rank===0||e.rank===1?t=P(e,[1,1,1,e.size]):e.rank===2?t=P(e,[1,1,e.shape[0],e.shape[1]]):e.rank===3?t=P(e,[1,e.shape[0],e.shape[1],e.shape[2]]):t=e,t}function YF(e,t,n,r,a,s){s==null&&(s=.001);let i=C(e,"x","batchNorm"),o=C(t,"mean","batchNorm"),l=C(n,"variance","batchNorm"),p;a!=null&&(p=C(a,"scale","batchNorm"));let u;r!=null&&(u=C(r,"offset","batchNorm")),$(o.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),$(u==null||o.rank===u.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),$(p==null||o.rank===p.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let d={x:JF(i),scale:p,offset:u,mean:o,variance:l},h={varianceEpsilon:s},c=O.runKernel(Ti,d,h);return P(c,i.shape)}var bo=L({batchNorm_:YF});function QF(e,t,n,r,a,s){let i=C(e,"x","batchNorm"),o=C(t,"mean","batchNorm"),l=C(n,"variance","batchNorm"),p;a!=null&&(p=C(a,"scale","batchNorm"));let u;return r!=null&&(u=C(r,"offset","batchNorm")),$(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),$(o.rank===2||o.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),$(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),p!=null&&$(p.rank===2||p.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${p.rank}.`),u!=null&&$(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${u.rank}.`),bo(i,o,l,u,p,s)}var Ng=L({batchNorm2d_:QF});function eR(e,t,n,r,a,s){let i=C(e,"x","batchNorm"),o=C(t,"mean","batchNorm"),l=C(n,"variance","batchNorm"),p;a!=null&&(p=C(a,"scale","batchNorm"));let u;return r!=null&&(u=C(r,"offset","batchNorm")),$(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),$(o.rank===3||o.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),$(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),p!=null&&$(p.rank===3||p.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${p.rank}.`),u!=null&&$(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${u.rank}.`),bo(i,o,l,u,p,s)}var Tg=L({batchNorm3d_:eR});function tR(e,t,n,r,a,s){let i=C(e,"x","batchNorm"),o=C(t,"mean","batchNorm"),l=C(n,"variance","batchNorm"),p;a!=null&&(p=C(a,"scale","batchNorm"));let u;return r!=null&&(u=C(r,"offset","batchNorm")),$(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),$(o.rank===4||o.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),$(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),p!=null&&$(p.rank===4||p.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${p.rank}.`),u!=null&&$(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${u.rank}.`),bo(i,o,l,u,p,s)}var Cg=L({batchNorm4d_:tR});function nR(e,t,n){let r=C(e,"x","bincount"),a=C(t,"weights","bincount");$(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),$(n>=0,()=>`size must be non-negative, but got ${n}.`),$(a.size===r.size||a.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${a.shape}.`);let s={x:r,weights:a},i={size:n};return O.runKernel(yl,s,i)}var _g=L({bincount_:nR});function rR(e,t){let n=C(e,"x","bitwiseAnd"),r=C(t,"y","bitwiseAnd");if(!pa(n.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${r.shape}`);if(n.dtype!=="int32"||r.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${r.dtype}`);let a={a:n,b:r};return O.runKernel(bl,a)}var g1=L({bitwiseAnd_:rR});function aR(e,t){let n=C(e,"s0","broadcastArgs","int32"),r=C(t,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);let a={s0:n,s1:r};return O.runKernel(Np,a)}var y1=L({broadcastArgs_:aR});function sR(e,t){let n=C(e,"broadcastTo","x"),r=n.shape;if(Hn(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){let l=n.shape.slice();for(;l.length<t.length;)l.unshift(1);n=P(n,l)}let a=n.shape,s=Array.from(t);for(let l=t.length-1;l>=0;l--)if(a[l]===t[l])s[l]=1;else if(n.shape[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(s.map((l,p)=>l>1?p:-1).filter(l=>l>=0).length===0)return Br(n);let i={x:n},o={reps:s};return O.runKernel(es,i,o)}var _s=L({broadcastTo_:sR});function iR(e){let t={x:C(e,"x","ceil","float32")};return O.runKernel(pi,t)}var Eg=L({ceil_:iR});function Bn(e,t,n){Hn(e),n=n||kp(t);let r={shape:e,value:t,dtype:n};return O.runKernel(Ep,{},r)}function oR(e,t,n){let r=C(e,"x","clipByValue");if($(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`),t===n)return Bn(r.shape,t,r.dtype);let a={x:r},s={clipValueMin:t,clipValueMax:n};return O.runKernel(Qa,a,s)}var an=L({clipByValue_:oR});function lR(e){return it(e,0)}var $g=L({concat1d_:lR});function uR(e,t){return it(e,t)}var Ag=L({concat2d_:uR});function pR(e,t){return it(e,t)}var Fg=L({concat3d_:pR});function dR(e,t){return it(e,t)}var Rg=L({concat4d_:dR});function hR(e,t,n,r,a="NHWC",s=[1,1],i){let o=C(e,"x","conv2d","float32"),l=C(t,"filter","conv2d","float32"),p=o,u=!1;o.rank===3&&(u=!0,p=P(o,[1,o.shape[0],o.shape[1],o.shape[2]])),$(p.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${p.rank}.`),$(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),bn("conv2d",r,i);let d=a==="NHWC"?p.shape[3]:p.shape[1];$(d===l.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`),$(qr(n,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),$(Bs(s),()=>"Error in conv2D: Dilated rates should be larger than 0."),$(Bs(n),()=>"Error in conv2D: Strides should be larger than 0.");let h={x:p,filter:l},c={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i},f=O.runKernel(di,h,c);return u?P(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var fn=L({conv2d_:hR});function cR(e,t,n,r,a="NWC",s=1,i){let o=C(e,"x","conv1d"),l=C(t,"filter","conv1d"),p=o,u=!1;o.rank===2&&(u=!0,p=P(o,[1,o.shape[0],o.shape[1]])),$(p.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${p.rank}.`),$(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),bn("conv1d",r,i),$(p.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${p.shape[2]}) must match input depth for filter ${l.shape[1]}.`),$(qr(n,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${s}'`),$(Bs(s),()=>"Error in conv1D: Dilated rates should be larger than 0."),$(Bs(n),()=>"Error in conv1D: Stride should be larger than 0."),$(a==="NWC",()=>`Error in conv1d: got dataFormat of ${a} but only NWC is currently supported.`);let d=P(l,[1,l.shape[0],l.shape[1],l.shape[2]]),h=P(p,[p.shape[0],1,p.shape[1],p.shape[2]]),c=fn(h,d,[1,n],r,"NHWC",[1,s],i);return u?P(c,[c.shape[2],c.shape[3]]):P(c,[c.shape[0],c.shape[2],c.shape[3]])}var cc=L({conv1d_:cR});function fR(e,t,n,r,a,s="NHWC",i){$(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let o=e,l=t,p=!1;t.rank===3&&(p=!0,l=P(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),$(o.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),$(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),$(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);let u=s==="NHWC"?o[3]:o[1],d=s==="NHWC"?l.shape[3]:l.shape[1];$(u===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[2]}.`),$(d===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[3]}.`),bn("conv2dDerInput",a,i);let h={dy:l,filter:n},c={strides:r,pad:a,dataFormat:s,dimRoundingMode:i,inputShape:o},f=O.runKernel(hi,h,c);return p?P(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var Dg=L({conv2DBackpropInput_:fR});function mR(e,t,n,r,a,s){let i=C(e,"x","conv2dTranspose"),o=C(t,"filter","conv2dTranspose");return Dg(n,i,o,r,a,"NHWC",s)}var fc=L({conv2dTranspose_:mR});function gR(e,t,n,r,a="NDHWC",s=[1,1,1]){let i=C(e,"x","conv3d"),o=C(t,"filter","conv3d"),l=i,p=!1;i.rank===4&&(p=!0,l=P(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),$(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),$(o.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),$(l.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`),$(qr(n,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),$(a==="NDHWC",()=>`Error in conv3d: got dataFormat of ${a} but only NDHWC is currently supported.`),$(Bs(s),()=>"Error in conv3D: Dilated rates should be larger than 0."),$(Bs(n),()=>"Error in conv3D: Strides should be larger than 0.");let u={x:l,filter:o},d={strides:n,pad:r,dataFormat:a,dilations:s},h=O.runKernel(ci,u,d);return p?P(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}var Mg=L({conv3d_:gR});function yR(e,t,n,r,a){$(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let s=e,i=t,o=!1;t.rank===4&&(o=!0,i=P(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,e[0],e[1],e[2],e[3]]);let l=s[4],p=i.shape[4];$(s.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),$(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),$(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),$(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),$(p===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${p}) must match output depth for filter ${n.shape[4]}.`);let u={dy:i,filter:n},d={pad:a,strides:r,inputShape:s},h=O.runKernel(wl,u,d);return o?P(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}var b1=L({conv3DBackpropInput_:yR});function bR(e,t,n,r,a){let s=C(e,"x","conv3dTranspose"),i=C(t,"filter","conv3dTranspose");return b1(n,s,i,r,a)}var Og=L({conv3dTranspose_:bR});function xR(e){let t={x:C(e,"x","cos","float32")};return O.runKernel(fi,t)}var Jp=L({cos_:xR});function vR(e){let t={x:C(e,"x","cosh","float32")};return O.runKernel(mi,t)}var mc=L({cosh_:vR});function wR(e,t=0,n=!1,r=!1){let a={x:C(e,"x","cumprod")},s={axis:t,exclusive:n,reverse:r};return O.runKernel(kl,a,s)}var dp=L({cumprod_:wR});function kR(e,t=0,n=!1,r=!1){let a={x:C(e,"x","cumsum")},s={axis:t,exclusive:n,reverse:r};return O.runKernel(gi,a,s)}var gc=L({cumsum_:kR});function IR(e,t,n,r=!1){let a=C(e,"x","denseBincount"),s=C(t,"weights","denseBincount");$(a.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${a.dtype}`),$(a.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${a.rank}.`),$(n>=0,()=>`size must be non-negative, but got ${n}.`),$(s.size===a.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${a.shape}, weights shape: ${s.shape}.`);let i={x:a,weights:s},o={size:n,binaryOutput:r};return O.runKernel(Cp,i,o)}var xh=L({denseBincount_:IR});function SR(e,t,n="NHWC"){let r=C(e,"x","depthToSpace","float32"),a=n==="NHWC"?r.shape[1]:r.shape[2],s=n==="NHWC"?r.shape[2]:r.shape[3],i=n==="NHWC"?r.shape[3]:r.shape[1];$(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),$(a*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${a} and ${t}  for depthToSpace with input shape
    ${r.shape}`),$(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${t} for depthToSpace with input shape
        ${r.shape}`),$(i%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`);let o={x:r},l={blockSize:t,dataFormat:n};return O.runKernel(Sl,o,l)}var Lg=L({depthToSpace_:SR});function NR(e,t,n,r,a="NHWC",s=[1,1],i){let o=C(e,"x","depthwiseConv2d","float32"),l=C(t,"filter","depthwiseConv2d","float32"),p=o,u=!1;o.rank===3&&(u=!0,p=P(o,[1,o.shape[0],o.shape[1],o.shape[2]])),$(p.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),$(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);let d=a==="NHWC"?p.shape[3]:p.shape[1];$(d===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`),bn("depthwiseConv2d",r,i);let h={x:p,filter:l},c={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i},f=O.runKernel(yi,h,c);return u?P(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var xo=L({depthwiseConv2d_:NR});function TR(e){let t={x:C(e,"x","diag")};return O.runKernel(_p,t)}var x1=L({diag_:TR});function CR(e,t,n,r,a=[1,1],s="NHWC"){let i=C(e,"x","dilation2d"),o=C(t,"filter","dilation2d");$(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),$(o.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),$(s==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let l=i,p=!1;i.rank===3&&(l=P(i,[1,i.shape[0],i.shape[1],i.shape[2]]),p=!0),$(l.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`);let u={x:l,filter:o},d={strides:n,pad:r,dilations:a},h=O.runKernel(bi,u,d);return p?P(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var zg=L({dilation2d_:CR}),hu={};Ee(hu,{assertAndGetBroadcastShape:()=>ot,getBroadcastDims:()=>v1,getReductionAxes:()=>Ft});function v1(e,t){let n=e.length,r=[];for(let a=0;a<n;a++){let s=n-1-a,i=e[s]||1;(t[t.length-1-a]||1)>1&&i===1&&r.unshift(s)}return r}function Ft(e,t){let n=[];for(let r=0;r<t.length;r++){let a=e[e.length-r-1],s=t.length-r-1,i=t[s];(a==null||a===1&&i>1)&&n.unshift(s)}return n}function ot(e,t){let n=Math.max(e.length,t.length),r=new Array(n);for(let a=0;a<n;a++){let s=e[e.length-a-1];s==null&&(s=1);let i=t[t.length-a-1];if(i==null&&(i=1),s===1)r[n-a-1]=i;else if(i===1)r[n-a-1]=s;else if(s!==i){let o=`Operands could not be broadcast together with shapes ${e} and ${t}.`;throw Error(o)}else r[n-a-1]=s}return r}function _R(e,t){let n=C(e,"a","equal","string_or_numeric"),r=C(t,"b","equal","string_or_numeric");[n,r]=kt(n,r),ot(n.shape,r.shape);let a={a:n,b:r};return O.runKernel(Tl,a)}var Wn=L({equal_:_R});function ER(e,t,n){let r=C(t,"a","where"),a=C(n,"b","where"),s=C(e,"condition","where","bool"),i=ot(ot(s.shape,r.shape),a.shape),o=_s(s,i),l=_s(r,i),p=_s(a,i),u={condition:o,t:l,e:p};return O.runKernel(eu,u)}var qt=L({where_:ER});function $R(e){let t={x:C(e,"x","zerosLike")};return O.runKernel(pu,t)}var He=L({zerosLike_:$R});function AR(e,t){let n=C(e,"a","div"),r=C(t,"b","div");[n,r]=kt(n,r);let a=fe(n,r),s=He(a),i=Wn(r,s);return qt(i,s,a)}var Pg=L({divNoNan_:AR});function FR(e,t){let n=C(e,"t1","dot"),r=C(t,"t2","dot");$((n.rank===1||n.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);let a=n.rank===1?n.size:n.shape[1],s=r.rank===1?r.size:r.shape[0];if($(a===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${a} and ${s}.`),n.rank===1&&r.rank===1){let i=P(n,[1,-1]),o=P(r,[-1,1]),l=Oe(i,o);return P(l,[])}else if(n.rank===1&&r.rank===2){let i=P(n,[1,-1]),o=P(r,[r.shape[0],r.shape[1]]),l=Oe(i,o);return P(l,[l.size])}else if(n.rank===2&&r.rank===1){let i=P(r,[-1,1]),o=Oe(n,i);return P(o,[o.size])}else{let i=P(r,[r.shape[0],r.shape[1]]);return Oe(n,i)}}var Bg=L({dot_:FR});function RR(e,...t){let n=t.map((a,s)=>C(a,`tensors${s}`,"einsum")),r={equation:e};return O.runKernel(ec,n,r)}var ks=L({einsum_:RR});function DR(e){let t={x:C(e,"x","elu","float32")};return O.runKernel(vi,t)}var cu=L({elu_:DR});function MR(e,t){let n=C(e,"x","ensureShape","string_or_numeric");if(!S0(n.shape,t))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);return e}var w1=L({ensureShape_:MR});function OR(e){let t=C(e,"x","erf");$(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=se(t,"float32"));let n={x:t};return O.runKernel(wi,n)}var yc=L({erf_:OR});function Wg(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function k1(e,t,n){let r=e.length+t.length,a=[],s=0,i=0;for(let o=0;o<r;o++)n.indexOf(o)===-1?a.push(e[s++]):a.push(t[i++]);return a}function I1(e,t){let n=[],r=e.length;for(let s=0;s<r;s++)t.indexOf(s)===-1&&n.push(e[s]);let a=t.map(s=>e[s]);return[n,a]}function Ws(e,t){let n=t.map(r=>1);return k1(e,n,t)}function LR(e,t,n){$(Wg(t,n),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function S1(e,t){if(Wg(e,t))return null;let n=[];for(let r=0;r<t;++r)e.indexOf(r)===-1&&n.push(r);return e.forEach(r=>n.push(r)),n}function Vg(e){return e.map((t,n)=>[n,t]).sort((t,n)=>t[1]-n[1]).map(t=>t[0])}function zR(e,t){let n=[];for(let r=t-e;r<t;++r)n.push(r);return n}function PR(e,t=null,n=!1){let r={x:C(e,"x","max")},a={reductionIndices:t,keepDims:n};return O.runKernel(Oi,r,a)}var er=L({max_:PR});function BR(e,t=null,n=!1){let r={x:C(e,"x","min")},a={axis:t,keepDims:n};return O.runKernel(Bi,r,a)}var Xo=L({min_:BR});function WR(e,t){let n=C(e,"base","pow"),r=C(t,"exp","pow");[n,r]=kt(n,r);let a={a:n,b:r};return O.runKernel(qi,a)}var Gr=L({pow_:WR});function we(e,t){if((Gt(e)&&t!=="string"||Array.isArray(e))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&Gt(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return ns(e,[],[],t)}function VR(e){let t={x:C(e,"x","sqrt","float32")};return O.runKernel(po,t)}var Kt=L({sqrt_:VR});function UR(e){let t=C(e,"x","square"),n={};return O.runKernel("Square",{x:t},n)}var st=L({square_:UR});function GR(e,t=null,n=!1){let r=C(e,"x","sum");r.dtype==="bool"&&(r=se(r,"int32"));let a={x:r},s={axis:t,keepDims:n};return O.runKernel(ho,a,s)}var ge=L({sum_:GR});function HR(e,t="euclidean",n=null,r=!1){e=C(e,"x","norm");let a=N1(e,t,n),s=a.shape;if(r){let i=hr(n,e.shape);s=Ws(a.shape,i)}return P(a,s)}function N1(e,t,n=null){if(e.rank===0)return _t(e);if(e.rank!==1&&n===null)return N1(P(e,[-1]),t,n);if(e.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(t===1)return ge(_t(e),n);if(t===1/0)return er(_t(e),n);if(t===-1/0)return Xo(_t(e),n);if(t==="euclidean"||t===2)return Kt(ge(Gr(_t(e),we(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&n.length===2){if(t===1)return er(ge(_t(e),n[0]),n[1]-1);if(t===1/0)return er(ge(_t(e),n[1]),n[0]);if(t===-1/0)return Xo(ge(_t(e),n[1]),n[0]);if(t==="fro"||t==="euclidean")return Kt(ge(st(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}var fu=L({norm_:HR});function jR(e,t=null,n=!1){return fu(e,"euclidean",t,n)}var Ug=L({euclideanNorm_:jR});function qR(e){let t={x:C(e,"x","exp")};return O.runKernel(ki,t)}var sn=L({exp_:qR});function KR(e,t=0){let n=C(e,"x","expandDims","string_or_numeric");$(t<=n.rank,()=>"Axis must be <= rank of the tensor");let r={input:n},a={dim:t};return O.runKernel(Cl,r,a)}var Ht=L({expandDims_:KR});function XR(e){let t={x:C(e,"x","expm1")};return O.runKernel(Ii,t)}var Gg=L({expm1_:XR});function ZR(e,t){let n=C(e,"x","tile","string_or_numeric");$(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`);let r={x:n},a={reps:t};return O.runKernel(es,r,a)}var Pn=L({tile_:ZR});function JR(e,t,n,r="float32"){t==null&&(t=e);let a=ze([e,t],r),s=e<=t?e:t;for(let o=0;o<s;++o)a.set(1,o,o);let i=P(a.toTensor(),[e,t]);if(n==null)return i;if(n.length===1)return Pn(Ht(i,0),[n[0],1,1]);if(n.length===2)return Pn(Ht(Ht(i,0),0),[n[0],n[1],1,1]);if(n.length===3)return Pn(Ht(Ht(Ht(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}var bc=L({eye_:JR});function YR(e){let t={x:C(e,"x","floor","float32")};return O.runKernel(Si,t)}var mu=L({floor_:YR});function QR(e,t,n=0,r=0){let a=C(e,"x","gather"),s=C(t,"indices","gather","int32"),i={x:a,indices:s},o={axis:n,batchDims:r};return O.runKernel(El,i,o)}var gu=L({gather_:QR});function eD(e,t){let n=C(e,"a","greater","string_or_numeric"),r=C(t,"b","greater","string_or_numeric");[n,r]=kt(n,r),ot(n.shape,r.shape);let a={a:n,b:r};return O.runKernel(Al,a)}var xn=L({greater_:eD});function tD(e,t){let n=C(e,"a","greaterEqual","string_or_numeric"),r=C(t,"b","greaterEqual","string_or_numeric");[n,r]=kt(n,r),ot(n.shape,r.shape);let a={a:n,b:r};return O.runKernel(Ci,a)}var ca=L({greaterEqual_:tD});function nD(e){let t={input:C(e,"input","imag")};return O.runKernel(rc,t)}var Yp=L({imag_:nD});function rD(e){let t={x:C(e,"x","isFinite")};return O.runKernel(Ei,t)}var Hg=L({isFinite_:rD});function aD(e){let t={x:C(e,"x","isInf")};return O.runKernel($i,t)}var jg=L({isInf_:aD});function sD(e){let t={x:C(e,"x","isNaN")};return O.runKernel(Ai,t)}var qg=L({isNaN_:sD});function iD(e,t=.2){let n={x:C(e,"x","leakyRelu")},r={alpha:t};return O.runKernel(Fi,n,r)}var Qp=L({leakyRelu_:iD});function oD(e,t){let n=C(e,"a","less","string_or_numeric"),r=C(t,"b","less","string_or_numeric");[n,r]=kt(n,r),ot(n.shape,r.shape);let a={a:n,b:r};return O.runKernel(Fl,a)}var Zo=L({less_:oD});function lD(e,t){let n=C(e,"a","lessEqual","string_or_numeric"),r=C(t,"b","lessEqual","string_or_numeric");[n,r]=kt(n,r),ot(n.shape,r.shape);let a={a:n,b:r};return O.runKernel(Rl,a)}var rs=L({lessEqual_:lD});function T1(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");let r={start:e,stop:t,num:n};return O.runKernel(Dl,{},r)}function uD(e,t=5,n=1,r=1,a=.5){let s=C(e,"x","localResponseNormalization");$(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),$(Ho(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let i=s,o=!1;s.rank===3&&(o=!0,i=P(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let l={x:i},p={depthRadius:t,bias:n,alpha:r,beta:a},u=O.runKernel(Mi,l,p);return o?P(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var Kg=L({localResponseNormalization_:uD});function pD(e){let t={x:C(e,"x","log","float32")};return O.runKernel(Ri,t)}var Vn=L({log_:pD});function dD(e){let t={x:C(e,"x","log1p")};return O.runKernel(Di,t)}var ed=L({log1p_:dD});function hD(e){return $(Oa(e),()=>"The f passed in grad(f) must be a function"),(t,n)=>{let r=C(t,"x","tf.grad","string_or_numeric"),a=n!=null?C(n,"dy","tf.grad"):null;return O.tidy(()=>{let{value:s,grads:i}=O.gradients(()=>e(r),[r],a);return a!=null&&yn(s.shape,a.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),xc(i),i[0]})}}function cD(e){return $(Oa(e),()=>"The f passed in grads(f) must be a function"),(t,n)=>{$(Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let r=op(t,"args","tf.grads","string_or_numeric"),a=n!=null?C(n,"dy","tf.grads"):null;return O.tidy(()=>{let{value:s,grads:i}=O.gradients(()=>e(...r),r,a);return a!=null&&yn(s.shape,a.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),xc(i),i})}}function fD(e){return $(Oa(e),()=>"The f passed in valueAndGrad(f) must be a function"),(t,n)=>{$(t instanceof Fe,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),$(n==null||n instanceof Fe,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");let{grads:r,value:a}=O.gradients(()=>e(t),[t],n);return xc(r),{grad:r[0],value:a}}}function mD(e){return $(Oa(e),()=>"The f passed in valueAndGrads(f) must be a function"),(t,n)=>{$(Array.isArray(t)&&t.every(a=>a instanceof Fe),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),$(n==null||n instanceof Fe,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");let r=O.gradients(()=>e(...t),t,n);return n!=null&&yn(r.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),xc(r.grads),r}}function C1(e,t){$(Oa(e),()=>"The f passed in variableGrads(f) must be a function"),$(t==null||Array.isArray(t)&&t.every(p=>p instanceof Ms),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let n=t!=null;if(!n){t=[];for(let p in O.registeredVariables)t.push(O.registeredVariables[p])}let r=n?t.filter(p=>!p.trainable):null,a=t.length;t=t.filter(p=>p.trainable),$(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${a} variables is trainable.`);let s=!0,{value:i,grads:o}=O.gradients(e,t,null,s);$(o.some(p=>p!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),$(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);let l={};return t.forEach((p,u)=>{o[u]!=null&&(l[p.name]=o[u])}),r!=null&&r.forEach(p=>l[p.name]=null),{value:i,grads:l}}function Hr(e){return O.customGrad(e)}function xc(e){if(e.filter(t=>t==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function gD(e){let t={x:C(e,"x","neg")};return O.runKernel(Wl,t)}var ct=L({neg_:gD});function yD(e){let t={x:C(e,"x","softplus")};return O.runKernel(uo,t)}var vo=L({softplus_:yD});function bD(e){let t=C(e,"x","logSigmoid");return Hr(n=>({value:ct(vo(ct(n))),gradFunc:r=>z(r,pr(ct(n)))}))(t)}var Xg=L({logSigmoid_:bD});function xD(e,t){let n=C(e,"a","sub"),r=C(t,"b","sub");[n,r]=kt(n,r);let a={a:n,b:r};return O.runKernel(mo,a)}var de=L({sub_:xD});function vD(e,t=-1){let n=C(e,"logits","logSoftmax");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return Hr((r,a)=>{let s=er(r,t,!0),i=de(r,s),o=de(se(i,"float32"),Vn(ge(sn(i),t,!0)));return a([o]),{value:o,gradFunc:(l,p)=>{let[u]=p,d=!0,h=sn(u);return de(l,z(ge(l,t,d),h))}}})(n)}var vc=L({logSoftmax_:vD});function wD(e,t=null,n=!1){let r=C(e,"x","logSumExp"),a=hr(t,r.shape),s=er(r,a,!0),i=de(r,s),o=sn(i),l=ge(o,a),p=Vn(l),u=X(P(s,p.shape),p);if(n){let d=Ws(u.shape,a);return P(u,d)}return u}var td=L({logSumExp_:wD});function kD(e,t){let n=C(e,"a","logicalAnd","bool"),r=C(t,"b","logicalAnd","bool");ot(n.shape,r.shape);let a={a:n,b:r};return O.runKernel(Ml,a)}var dr=L({logicalAnd_:kD});function ID(e){let t={x:C(e,"x","logicalNot","bool")};return O.runKernel(Ol,t)}var nd=L({logicalNot_:ID});function SD(e,t){let n=C(e,"a","logicalOr","bool"),r=C(t,"b","logicalOr","bool");ot(n.shape,r.shape);let a={a:n,b:r};return O.runKernel(Ll,a)}var wc=L({logicalOr_:SD});function ND(e,t){let n=C(e,"a","logicalXor","bool"),r=C(t,"b","logicalXor","bool");return ot(n.shape,r.shape),dr(wc(e,t),nd(dr(e,t)))}var Zg=L({logicalXor_:ND}),Vd=2147483648;function TD(e,t,n="left"){let r=C(e,"sortedSequence","searchSorted"),a=C(t,"values","searchSorted"),s=r.shape[r.shape.length-1],i=a.shape[a.shape.length-1],o=P(r,[-1,s]),l=P(a,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(tt(l.shape)>=Vd)throw new Error(`values tensor size must less than ${Vd}`);if(o.shape[1]>=Vd)throw new Error(`trailing dim_size must less than ${Vd} for int32 output type, was ${o.shape[1]}`);let p={sortedSequence:o,values:l},u={side:n};return O.runKernel(Ql,p,u)}var kc=L({searchSorted_:TD});function _1(e,t){return kc(e,t,"left")}function CD(e,t,n,r,a){let s=C(e,"x","maxPool"),i=1,o=s,l=!1;s.rank===3&&(l=!0,o=P(s,[1,s.shape[0],s.shape[1],s.shape[2]])),$(o.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),$(qr(n,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),bn("maxPool",r,a);let p={x:o},u={filterSize:t,strides:n,pad:r,dimRoundingMode:a},d=O.runKernel(zi,p,u);return l?P(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var Vt=L({maxPool_:CD});function _D(e,t=[1,1,1],n,r,a,s="NDHWC"){let i=C(e,"x","maxPool3d"),o=i,l=!1;i.rank===4&&(l=!0,o=P(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),$(o.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),$(s==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),bn("maxPool3d",r,a);let p={x:o},u={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:s},d=O.runKernel(Pl,p,u);return l?P(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var Jg=L({maxPool3d_:_D});function ED(e,t,n,r,a=!1){let s={x:C(e,"x","maxPoolWithArgmax")},i={filterSize:t,strides:n,pad:r,includeBatchInIndex:a},o=O.runKernel(Fp,s,i);return{result:o[0],indexes:o[1]}}var E1=L({maxPoolWithArgmax_:ED});function $D(e,t){let n=C(e,"a","maximum"),r=C(t,"b","maximum");[n,r]=kt(n,r),n.dtype==="bool"&&(n=se(n,"int32"),r=se(r,"int32")),ot(n.shape,r.shape);let a={a:n,b:r};return O.runKernel(Li,a)}var Kr=L({maximum_:$D});function AD(e,t=null,n=!1){let r={x:C(e,"x","mean")},a={axis:t,keepDims:n};return O.runKernel(Pi,r,a)}var xt=L({mean_:AD});function vt(e,t="float32"){if(Hn(e),t==="complex64"){let r=vt(e,"float32"),a=vt(e,"float32");return la(r,a)}let n=qh(tt(e),t);return O.makeTensor(n,e,t)}function Nn(e,t="float32"){if(Hn(e),t==="complex64"){let r=Nn(e,"float32"),a=vt(e,"float32");return la(r,a)}let n=ag(tt(e),t);return O.makeTensor(n,e,t)}function $1(e,t,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(e===void 0)return[];let r=C(e,"x","meshgrid",e instanceof Fe?e.dtype:"float32");if(t===void 0)return[r];let a=C(t,"y","meshgrid",t instanceof Fe?t.dtype:"float32"),s=tt(r.shape),i=tt(a.shape);return n==="xy"?(r=P(r,[1,-1]),a=P(a,[-1,1]),[Oe(Nn([i,1],r.dtype),r),Oe(a,Nn([1,s],a.dtype))]):(r=P(r,[-1,1]),a=P(a,[1,-1]),[Oe(r,Nn([1,i],r.dtype)),Oe(Nn([s,1],a.dtype),a)])}function FD(e,t){let n=C(e,"a","minimum"),r=C(t,"b","minimum");[n,r]=kt(n,r),n.dtype==="bool"&&(n=se(n,"int32"),r=se(r,"int32")),ot(n.shape,r.shape);let a={a:n,b:r};return O.runKernel(Wi,a)}var Va=L({minimum_:FD});function RD(e,t,n){$(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);let r=C(e,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");$(t.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);let a=n==="reflect"?1:0;for(let o=0;o<r.rank;o++)$(t[o].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),$(t[o][0]>=0&&t[o][0]<=r.shape[o]-a&&t[o][1]>=0&&t[o][1]<=r.shape[o]-a,()=>`Padding in dimension ${o} cannot be greater than or equal to ${r.shape[o]-a} or less than 0 for input of shape ${r.shape}`);let s={paddings:t,mode:n},i={x:r};return O.runKernel(Vi,i,s)}var Yg=L({mirrorPad_:RD});function DD(e,t){let n=C(e,"a","mod"),r=C(t,"b","mod");[n,r]=kt(n,r);let a={a:n,b:r};return O.runKernel(Ui,a)}var Qg=L({mod_:DD});function MD(e,t=null,n=!1){e=C(e,"x","moments");let r=hr(t,e.shape),a=xt(e,r,n),s=a.shape;n||(s=Ws(a.shape,r));let i=st(de(se(e,"float32"),P(a,s))),o=xt(i,r,n);return{mean:a,variance:o}}var rd=L({moments_:MD});function OD(e,t,n,r){let a=C(t,"data","multiRNNCell"),s=op(n,"c","multiRNNCell"),i=op(r,"h","multiRNNCell"),o=a,l=[];for(let d=0;d<e.length;d++){let h=e[d](o,s[d],i[d]);l.push(h[0]),l.push(h[1]),o=h[1]}let p=[],u=[];for(let d=0;d<l.length;d+=2)p.push(l[d]),u.push(l[d+1]);return[p,u]}var A1=L({multiRNNCell_:OD});function LD(e,t,n,r=!1){let a=C(e,"logits","multinomial"),s=a.size,i=a.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();let o={logits:i===1?P(a,[1,-1]):a},l={numSamples:t,seed:n,normalized:r},p=O.runKernel(Bl,o,l);return i===1?P(p,[p.size]):p}var F1=L({multinomial_:LD});function zD(e,t){let n=C(e,"a","notEqual","string_or_numeric"),r=C(t,"b","notEqual","string_or_numeric");[n,r]=kt(n,r),ot(n.shape,r.shape);let a={a:n,b:r};return O.runKernel(Vl,a)}var Vs=L({notEqual_:zD});function PD(e,t,n=1,r=0,a="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let s={indices:C(e,"indices","oneHot","int32")},i={dtype:a,depth:t,onValue:n,offValue:r};return O.runKernel(Hi,s,i)}var Jo=L({oneHot_:PD});function BD(e){let t={x:C(e,"x","onesLike")};return O.runKernel(jl,t)}var Un=L({onesLike_:BD});function WD(e,t){let n=C(e,"v1","outerProduct"),r=C(t,"v2","outerProduct");$(n.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`);let a=P(n,[-1,1]),s=P(r,[1,-1]);return Oe(a,s)}var R1=L({outerProduct_:WD});function VD(e,t,n=0){let r=C(e,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let a={paddings:t,constantValue:n},s={x:r};return O.runKernel(ji,s,a)}var _r=L({pad_:VD});function UD(e,t,n=0){return $(t.length===2,()=>"Invalid number of paddings. Must be length of 2."),_r(e,[t],n)}var D1=L({pad1d_:UD});function GD(e,t,n=0){return $(t.length===2&&t[0].length===2&&t[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),_r(e,t,n)}var M1=L({pad2d_:GD});function HD(e,t,n=0){return $(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),_r(e,t,n)}var O1=L({pad3d_:HD});function jD(e,t,n=0){return $(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),_r(e,t,n)}var L1=L({pad4d_:jD});function qD(e,t,n){let r=C(e,"x","spaceToBatchND");$(r.rank>=1+t.length,()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`),$(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),$(r.shape.reduce((i,o,l)=>l>0&&l<=t.length?i&&(o+n[l-1][0]+n[l-1][1])%t[l-1]===0:i,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`);let a={x:r},s={blockShape:t,paddings:n};return O.runKernel(nu,a,s)}var ad=L({spaceToBatchND_:qD});function KD(e,t,n,r,a,s,i){a==null&&(a=[1,1]),s==null&&(s=1),r===0&&(r="valid");let o=C(e,"x","maxPool"),l=o,p=!1;o.rank===3&&(p=!0,l=P(o,[1,o.shape[0],o.shape[1],o.shape[2]])),$(qr(s,a),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${a}'`);let u=h1(l.shape,t,s,a,r),d=[u.dilationHeight,u.dilationWidth],h;r==="same"?h=ZD([u.filterHeight,u.filterWidth],d):h=[[0,0],[0,0]];let c=d[0]===1&&d[1]===1,[f,m]=XD([u.inHeight,u.inWidth],d,h),g=c?r:"valid",y=c?l:ad(l,d,f),b=(n==="avg"?()=>ha(y,t,s,g,i):()=>Vt(y,t,s,g,i))(),x=c?b:Zp(b,d,m);return p?P(x,[x.shape[1],x.shape[2],x.shape[3]]):x}function XD(e,t,n){let r=n.map(u=>u[0]),a=n.map(u=>u[1]),s=e.concat(r,a),i=t.map((u,d)=>(u-s[d]%u)%u),o=a.map((u,d)=>u+i[d]),l=t.map((u,d)=>[r[d],o[d]]),p=t.map((u,d)=>[0,i[d]]);return[l,p]}function ZD(e,t){let n=e.map((s,i)=>s+(s-1)*(t[i]-1)).map(s=>s-1),r=n.map(s=>Math.floor(s/2)),a=n.map((s,i)=>s-r[i]);return n.map((s,i)=>[r[i],a[i]])}var ey=L({pool_:KD});function JD(e,t){let n=C(e,"x","prelu"),r=C(t,"alpha","prelu"),a={x:n,alpha:r};return O.runKernel(Ki,a)}var sd=L({prelu_:JD});function YD(e,t=null,n=!1){let r=C(e,"x","prod");r.dtype==="bool"&&(r=se(r,"int32"));let a={x:r},s={axis:t,keepDims:n};return O.runKernel(Xi,a,s)}var ty=L({prod_:YD});function QD(e,t,n,r){let a=e.map((u,d)=>C(u,`tensors${d}`,"raggedGather","int32")),s=C(t,"paramsDenseValues","raggedGather"),i=C(n,"indices","raggedGather","int32"),o={paramsNestedSplits:a,paramsDenseValues:s,indices:i},l={outputRaggedRank:r},p=O.runKernel(ac,o,l);return{outputNestedSplits:p.slice(0,p.length-1),outputDenseValues:p[p.length-1]}}var z1=L({raggedGather_:QD});function eM(e,t,n){let r=C(e,"starts","raggedRange"),a=C(t,"limits","raggedRange",r.dtype),s=C(n,"deltas","raggedRange",r.dtype),i={starts:r,limits:a,deltas:s},o=O.runKernel(sc,i);return{rtNestedSplits:o[0],rtDenseValues:o[1]}}var P1=L({raggedRange_:eM});function tM(e,t,n,r,a){let s=C(e,"shape","raggedTensorToTensor","int32"),i=C(t,"values","raggedTensorToTensor"),o=C(n,"defaultValue","raggedTensorToTensor",i.dtype),l=r.map((d,h)=>C(d,`tensors${h}`,"raggedTensorToTensor","int32")),p={shape:s,values:i,defaultValue:o,rowPartitionTensors:l},u={rowPartitionTypes:a};return O.runKernel(ic,p,u)}var B1=L({raggedTensorToTensor_:tM});function nM(e,t,n){Hn(e);let r=tt(e),a=null;if(n==null||n==="float32")a=new Float32Array(r);else if(n==="int32")a=new Int32Array(r);else if(n==="bool")a=new Uint8Array(r);else throw new Error(`Unknown data type ${n}`);for(let s=0;s<r;s++)a[s]=t();return O.makeTensor(a,e,n)}var W1=L({rand_:nM}),ny=Ja(Hh()),V1={};Ee(V1,{TEST_EPSILON_FLOAT16:()=>U1,createVideoElement:()=>pM,encodeStrings:()=>G1,expectArrayBuffersEqual:()=>uM,expectArraysClose:()=>aM,expectArraysEqual:()=>iM,expectNumbersClose:()=>oM,expectPromiseToFail:()=>sM,expectValuesInRange:()=>lM,play:()=>dM,testEpsilon:()=>ry});var rM=.001,U1=.1;function aM(e,t,n){return n==null&&(n=ry()),lm(e,t,(r,a)=>ay(r,a,n))}function ry(){return O.backend.floatPrecision()===32?rM:U1}function lm(e,t,n){let r=!0;if((Gt(e)||Gt(t))&&(r=!1),Gt(e)&&Gt(t)&&(r=!0),r){let i=e.constructor.name,o=t.constructor.name;if(i!==o)throw new Error(`Arrays are of different type. Actual: ${i}. Expected: ${o}`)}if(Array.isArray(e)&&Array.isArray(t)){let i=Ur(e),o=Ur(t);if(!pa(i,o))throw new Error(`Arrays have different shapes. Actual: [${i}]. Expected: [${o}]`)}let a=Gt(e)?e:La(e),s=Gt(t)?t:La(t);if(a.length!==s.length)throw new Error(`Arrays have different lengths actual: ${a.length} vs expected: ${s.length}.
Actual:   ${a}.
Expected: ${s}.`);for(let i=0;i<s.length;++i){let o=a[i],l=s[i];if(!n(o,l))throw new Error(`Arrays differ: actual[${i}] = ${o}, expected[${i}] = ${l}.
Actual:   ${a}.
Expected: ${s}.`)}typeof expect<"u"&&expect().nothing()}function sM(e,t){e().then(()=>t.fail(),()=>t()),typeof expect<"u"&&expect().nothing()}function iM(e,t){let n=typeof t=="string"||typeof t=="number"||typeof t=="boolean"?[t]:t;return Ea(e)||Ea(e[0])||Ea(t)||Ea(t[0])?lm(e,n,(r,a)=>r==a):lm(e,t,(r,a)=>ay(r,a,0))}function oM(e,t,n){if(n==null&&(n=ry()),!ay(e,t,n))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`);typeof expect<"u"&&expect().nothing()}function ay(e,t,n){return!isFinite(e)&&!isFinite(t)?!0:!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function lM(e,t,n){for(let r=0;r<e.length;r++)if(e[r]<t||e[r]>n)throw new Error(`Value out of range:${e[r]} low: ${t}, high: ${n}`)}function uM(e,t){let n=new Float32Array(e),r=new Float32Array(t);if(n.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${n.length}`);for(let a=0;a<r.length;a++)if(n[a]!==r[a])throw new Error(`Expected ArrayBuffer value at ${a} to be ${r[a]} but got ${n[a]} instead`)}function G1(e){for(let t=0;t<e.length;t++){let n=e[t];Array.isArray(n)?G1(n):e[t]=jp(n)}return e}function pM(e){let t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(e),new Promise(n=>{t.addEventListener("loadeddata",r=>n(t)),t.load()})}async function dM(e){await e.play(),"requestVideoFrameCallback"in e&&await new Promise(t=>{e.requestVideoFrameCallback(t)})}var sy=class{constructor(e,t,n,r,a){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let s=a||Math.random();this.random=ny.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){let r=this.nextVal;return this.nextVal=NaN,r}let e,t,n=!1;for(;!n;){let r,a,s;do r=2*this.random()-1,a=2*this.random()-1,s=r*r+a*a;while(s>=1||s===0);let i=Math.sqrt(-2*Math.log(s)/s);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*a*i,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},hM=class{constructor(e,t,n,r){this.alpha=e,this.beta=1/t,this.dtype=n;let a=r||Math.random();this.randu=ny.alea(a.toString()),this.randn=new sy(0,1,n,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,a,s;for(;;){do r=this.randn.nextValue(),s=1+this.c*r;while(s<=0);if(s*=s*s,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-s+Math.log(s)),a=this.randu(),a<t||Math.log(a)<n)break}return s=1/this.beta*this.d*s,this.alpha<1&&(s*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(s)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}},cM=class{constructor(e=0,t=1,n,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=n,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=ny.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function fM(e,t,n=1,r="float32",a){if(Hn(e),n==null&&(n=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);let s=new hM(t,n,r,a),i=ze(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var H1=L({randomGamma_:fM});function mM(e,t=0,n=1,r,a){if(Hn(e),r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);let s=new sy(t,n,r,!1,a),i=ze(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var Ic=L({randomNormal_:mM});function gM(e,t,n){if(t!=null&&t==="bool")throw new Error(`Unsupported data type ${t}`);return Ic(e,0,1,t,n)}var j1=L({randomStandardNormal_:gM});function yM(e,t=0,n=1,r="float32",a){Hn(e);let s=ze(e,r),i=new cM(t,n,null,a);for(let o=0;o<s.values.length;o++)s.values[o]=i.nextValue();return s.toTensor()}var as=L({randomUniform_:yM});function bM(e,t,n,r){return as(e,t,n,"int32",r)}var q1=L({randomUniformInt_:bM});function Us(e,t,n=1,r="float32"){if(n===0)throw new Error("Cannot have a step of zero");let a={start:e,stop:t,step:n,dtype:r};return O.runKernel(Rp,{},a)}function xM(e){let t={input:C(e,"input","real")};return O.runKernel(oc,t)}var Yo=L({real_:xM});function vM(e){let t={x:C(e,"x","reciprocal")};return O.runKernel(Zi,t)}var iy=L({reciprocal_:vM});function wM(e){let t={x:C(e,"x","relu")};return O.runKernel(Ji,t)}var et=L({relu_:wM});function kM(e){let t={x:C(e,"x","relu6")};return O.runKernel(eo,t)}var Sc=L({relu6_:kM});function IM(e,t){let n={x:C(e,"x","reverse")},r={dims:t};return O.runKernel(to,n,r)}var rr=L({reverse_:IM});function SM(e){let t=C(e,"x","reverse");return $(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),rr(t,0)}var K1=L({reverse1d_:SM});function NM(e,t){let n=C(e,"x","reverse");return $(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),rr(n,t)}var X1=L({reverse2d_:NM});function TM(e,t){let n=C(e,"x","reverse");return $(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),rr(n,t)}var Z1=L({reverse3d_:TM});function CM(e,t){let n=C(e,"x","reverse");return $(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),rr(n,t)}var J1=L({reverse4d_:CM});function _M(e){let t={x:C(e,"x","round")};return O.runKernel(no,t)}var Nc=L({round_:_M});function EM(e){let t={x:C(e,"x","rsqrt","float32")};return O.runKernel(ro,t)}var Tc=L({rsqrt_:EM});function $M(e){let t={x:C(e,"x","selu")};return O.runKernel(ao,t)}var Cc=L({selu_:$M});function AM(e,t,n,r,a,s=[1,1],i="NHWC"){let o=C(e,"x","separableConv2d"),l=C(t,"depthwiseFilter","separableConv2d"),p=C(n,"pointwiseFilter","separableConv2d"),u=o,d=!1;if(o.rank===3&&(d=!0,u=P(o,[1,o.shape[0],o.shape[1],o.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");$(u.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${u.rank}.`),$(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),$(p.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),$(p.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${p.shape[0]}.`),$(p.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${p.shape[1]}.`);let h=l.shape[2],c=l.shape[3];$(p.shape[2]===h*c,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${h*c}, but got ${p.shape[2]}.`);let f=xo(u,l,r,a,i,s),m=fn(f,p,1,"valid",i);return d?P(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var yu=L({separableConv2d_:AM});async function FM(e,t){let n=C(e,"x","setdiff1d"),r=C(t,"y","setdiff1d");$(n.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`),$(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),$(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);let a=await n.data(),s=await r.data(),i=new Set(s),o=0;for(let u=0;u<a.length;u++)i.has(a[u])||o++;let l=new $t([o],n.dtype),p=new $t([o],"int32");for(let u=0,d=0;u<a.length;u++)i.has(a[u])||(l.values[d]=a[u],p.values[d]=u,d++);return[l.toTensor(),p.toTensor()]}var Y1=FM;function RM(e){let t={x:C(e,"x","sign")};return O.runKernel(oo,t)}var oy=L({sign_:RM});function DM(e){let t={x:C(e,"x","sin","float32")};return O.runKernel(so,t)}var _c=L({sin_:DM});function MM(e){let t={x:C(e,"x","sinh")};return O.runKernel(io,t)}var Ec=L({sinh_:MM});function OM(e,t,n){let r=C(e,"x","slice1d");return $(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),Ue(r,[t],[n])}var id=L({slice1d_:OM});function LM(e,t,n){let r=C(e,"x","slice2d");return $(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),Ue(r,t,n)}var $c=L({slice2d_:LM});function zM(e,t,n){let r=C(e,"x","slice3d");return $(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),Ue(r,t,n)}var bu=L({slice3d_:zM});function PM(e,t,n){let r=C(e,"x","slice4d");return $(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),Ue(r,t,n)}var Qo=L({slice4d_:PM});function BM(e,t=-1){let n=C(e,"logits","softmax","float32");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);let r={logits:n},a={dim:t};return O.runKernel(co,r,a)}var ss=L({softmax_:BM});function WM(e){$(e.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`);let t={input:e};return O.runKernel(tc,t)}var od=L({fft_:WM});function VM(e){$(e.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`);let t={input:e};return O.runKernel(nc,t)}var el=L({ifft_:VM});function UM(e){let t=e.shape[e.shape.length-1],n=e.size/t,r;if(t<=2){let a=P(e,[n,t]);r=el(a)}else{let a=[n,2*(t-1)],s=P(Yo(e),[n,t]),i=P(Yp(e),[n,t]),o=rr(Ue(s,[0,1],[n,t-2]),1),l=z(rr(Ue(i,[0,1],[n,t-2]),1),we(-1)),p=it([s,o],1),u=it([i,l],1),d=P(la(p,u),[a[0],a[1]]);r=el(d)}if(r=Yo(r),e.rank===3&&e.shape[0]!==0){let a=r,s=e.shape[0];r=P(r,[s,r.shape[0]/s,r.shape[1]]),a.dispose()}return r}var Ac=L({irfft_:UM});function GM(e,t,n=0){let r={x:C(e,"x","split")},a={numOrSizeSplits:t,axis:n};return O.runKernel(ru,r,a)}var Tn=L({split_:GM});function HM(e,t){$(e.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let n=e.shape[e.shape.length-1],r=e.size/n,a;if(t!=null&&t<n){let f=e.shape.map(g=>0),m=e.shape.map(g=>g);m[e.shape.length-1]=t,a=Ue(e,f,m),n=t}else if(t!=null&&t>n){let f=e.shape.map(m=>m);f[e.shape.length-1]=t-n,a=it([e,vt(f)],e.shape.length-1),n=t}else a=e;let s=He(a),i=P(la(a,s),[r,n]),o=od(i),l=Math.floor(n/2)+1,p=Yo(o),u=Yp(o),d=Tn(p,[l,n-l],p.shape.length-1),h=Tn(u,[l,n-l],u.shape.length-1),c=a.shape.slice();return c[a.shape.length-1]=l,P(la(d[0],h[0]),c)}var ld=L({rfft_:HM});function jM(e,t){let n=C(e,"a","squaredDifference"),r=C(t,"b","squaredDifference");[n,r]=kt(n,r),ot(n.shape,r.shape);let a={a:n,b:r},s={};return O.runKernel(fo,a,s)}var Fc=L({squaredDifference_:jM});function qM(e,t){let n=C(e,"x","squeeze","string_or_numeric");return P(n,N0(n.shape,t).newShape)}var is=L({squeeze_:qM});function KM(e,t=0){let n=op(e,"tensors","stack","string_or_numeric");$(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&$(t<=n[0].rank,()=>"Axis must be <= rank of the tensor");let r=n,a={axis:t};return O.runKernel(ql,r,a)}var At=L({stack_:KM});function XM(e,t=0){let n={x:C(e,"x","step")},r={alpha:t};return O.runKernel(ts,n,r)}var wo=L({step_:XM});function ZM(e,t,n,r,a=0,s=0,i=0,o=0,l=0){let p={x:C(e,"x","stridedSlice","string_or_numeric")},u={begin:t,end:n,strides:r,beginMask:a,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};return O.runKernel(iu,p,u)}var ly=L({stridedSlice_:ZM});function JM(e){let t={x:C(e,"x","tan","float32")};return O.runKernel(go,t)}var uy=L({tan_:JM});function Ye(e,t){Ys(e);let n=Ur(e,t);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return ns(e,null,n,t)}function Wr(e,t,n){if(Ys(e),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let r=Ur(e,n);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return ns(e,t,r,n)}function Rc(e,t,n){if(Ys(e),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let r=Ur(e,n);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return ns(e,t,r,n)}function Ua(e,t,n){if(Ys(e),t!=null&&t.length!==4)throw new Error("tensor4d() requires shape to have four numbers");let r=Ur(e,n);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return ns(e,t,r,n)}function Q1(e,t,n){if(Ys(e),t!=null&&t.length!==5)throw new Error("tensor5d() requires shape to have five numbers");let r=Ur(e,n);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return ns(e,t,r,n)}function ek(e,t,n){if(Ys(e),t!=null&&t.length!==6)throw new Error("tensor6d() requires shape to have six numbers");let r=Ur(e,n);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||r,ns(e,t,r,n)}var Dc={};Ee(Dc,{calculateShapes:()=>tk,validateInput:()=>Mc,validateUpdateShape:()=>py});function py(e,t,n){let r=t.rank>1?t.shape[t.rank-1]:1,a=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${a}.`;if(n.rank<a)throw new Error(s+` update.rank < ${a}. `);if(e.length<r+(n.rank-a))throw new Error(s+` Output shape length < ${r+(n.rank-a)}`);if(n.rank!==a+e.length-r)throw new Error(s+` update.rank != ${a+e.length-r}`);for(let i=0;i<a;++i)if(n.shape[i]!==t.shape[i])throw new Error(s+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<n.rank-a;++i)if(n.shape[i+a]!==e[i+r])throw new Error(s+` updates.shape[${i+a}] (${n.shape[i+a]}) != shape[${i+a}] (${e[i+a]})`)}function Mc(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(e.size===0)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}py(n,t,e)}function tk(e,t,n){let r=t.shape.length,a=r>1?t.shape[r-1]:1,s=n.length,i=1;for(let d=a;d<s;++d)i*=n[d];let o=a<1?1:a,l=tt(t.shape)/o,p=[...ul(n.slice(0,a)),1],u=tt(n);return{sliceRank:a,numUpdates:l,sliceSize:i,strides:p,outputSize:u}}function YM(e,t,n){let r=C(e,"tensor","tensorScatterupdate"),a=C(t,"indices","tensorScatterupdate","int32"),s=C(n,"updates","tensorScatterupdate");if(Mc(s,a,r.shape),r.dtype!==s.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${s.dtype}.`);let i={tensor:r,indices:a,updates:s},o={};return O.runKernel(Yl,i,o)}var nk=L({tensorScatterUpdate_:YM});function QM(e,t=1,n=!0){let r=C(e,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let a=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>a)throw new Error(`'k' passed to topk() must be <= the last dimension (${a}) but got ${t}`);let s={x:r},i={k:t,sorted:n},[o,l]=O.runKernel(ou,s,i);return{values:o,indices:l}}var dy=L({topk_:QM});function eO(e,t=0,n=1,r,a){if(Hn(e),r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");let s=new sy(t,n,r,!0,a),i=ze(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var Oc=L({truncatedNormal_:eO});function tO(e,t=0){let n=C(e,"x","unique","string_or_numeric");$(n.rank>0,()=>"The input tensor must be at least 1D");let r={x:n},a={axis:t},[s,i]=O.runKernel(Vp,r,a);return{values:s,indices:i}}var hy=L({unique_:tO});function nO(e,t,n){let r=C(e,"x","unsortedSegmentSum"),a=C(t,"segmentIds","unsortedSegmentSum","int32");$(Ho(n),()=>"numSegments must be of dtype int");let s={x:r,segmentIds:a},i={numSegments:n};return O.runKernel(Up,s,i)}var Lc=L({unsortedSegmentSum_:nO});function rO(e,t=0){let n=C(e,"x","unstack","string_or_numeric");$(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`);let r={value:n},a={axis:t};return O.runKernel(uu,r,a)}var St=L({unstack_:rO});function rk(e,t){return kc(e,t,"right")}function cy(e,t=!0,n,r){return O.makeVariable(e,t,n,r)}function ak(e,t){let n=[];for(let s=0;s<t.length;s++)t[s]&&n.push(s);let r=ze(e,"int32"),a=ze([n.length,e.length],"int32");for(let s=0;s<n.length;s++){let i=r.indexToLoc(n[s]),o=s*e.length;a.values.set(i,o)}return a.toTensor()}async function aO(e){let t=C(e,"condition","whereAsync","bool"),n=await t.data(),r=ak(t.shape,n);return e!==t&&t.dispose(),r}var fy=aO;async function sO(e,t,n){let r=C(e,"tensor","boolMask"),a=C(t,"mask","boolMask","bool"),s=n??0,i=a.rank,o=r.shape;$(i>0,()=>"mask cannot be scalar"),yn(o.slice(s,s+i),a.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=s;m<s+i;m++)l*=o[m];let p=o.slice(0,s).concat([l],o.slice(s+i)),u=P(r,p),d=P(a,[-1]),h=await fy(d),c=is(h,[1]),f=gu(u,c,s);return e!==r&&r.dispose(),t!==a&&a.dispose(),c.dispose(),u.dispose(),d.dispose(),h.dispose(),f}var sk=sO;function iO(e,t,n){let r=C(e,"x","transpose");if(t==null&&(t=r.shape.map((i,o)=>o).reverse()),$(r.rank===t.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`),t.forEach(i=>{$(i>=0&&i<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${t}`)}),r.rank<=1)return r.clone();let a={x:r},s={perm:t};return r.dtype==="complex64"?B(()=>{let i=Yo(r),o=Yp(r);return i=O.runKernel(sa,{x:i},s),o=O.runKernel(sa,{x:o},s),n&&(o=ct(o)),la(i,o)}):O.runKernel(sa,a,s)}var Le=L({transpose_:iO});function oO(e,t,n,r,a=!0){let s=C(e,"v","movingAverage"),i=C(t,"x","movingAverage"),o=C(n,"decay","movingAverage");H0(s,i),$(pa(s.shape,i.shape),()=>"Shape mismatch in v and x");let l=we(1),p=de(l,o),u=z(de(i,s),p);if(a){$(r!=null,()=>"When using zeroDebias: true, step is required.");let d=C(r,"step","movingAverage");u=fe(u,de(l,Gr(o,d)))}return X(s,u)}var ik=L({movingAverage_:oO});function lO(e,t,n){Hn(n);let r=C(e,"indices","scatterND","int32"),a=C(t,"updates","scatterND");Mc(a,r,n);let s={indices:r,updates:a},i={shape:n};return O.runKernel(Jl,s,i)}var ok=L({scatterND_:lO});function uO(e,t,n,r){if(e.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);let a=e.rank>0?e.shape[0]:1,s=e.rank>1?e.shape[1]:1;if(n.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${s}.`);let i=t.size;if(!(t.rank===0||t.rank===1&&i===a))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${a}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function pO(e,t,n,r=0){Hn(n);let a=C(e,"sparseIndices","sparseToDense","int32"),s=C(t,"sparseValues","sparseToDense","string_or_numeric"),i=C(r,"defaultValue","sparseToDense",s.dtype);uO(a,s,n,i);let o={sparseIndices:a,sparseValues:s,defaultValue:i},l={outputShape:n};return O.runKernel(su,o,l)}var lk=L({sparseToDense_:pO});function dO(e,t){let n=C(t,"indices","gatherND","int32"),r={params:C(e,"x","gatherND","string_or_numeric"),indices:n};return O.runKernel($l,r)}var uk=L({gatherND_:dO});function hO(e,t){if(t==null)return e.shape.slice();if(pa(e.shape,t))return t;if(e.shape.length===t.length){let n=[];for(let r=0;r<e.shape.length;r++)t[r]==null&&e.shape[r]!=null?n.push(e.shape[r]):n.push(t[r]);return n}return t}function cO(e,t,n,r){let a=C(e,"x","dropout");if($(a.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${a.dtype} tensor instead.`),$(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return e instanceof Fe?a.clone():a;let s=hO(a,n),i=1-t,o=fe(mu(X(as(s,0,1,"float32",r),i)),i);return z(a,o)}var my=L({dropout_:cO});function gy(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function zc(e,t,n){let r=1-e%2,a=new Float32Array(e);for(let s=0;s<e;++s){let i=2*Math.PI*s/(e+r-1);a[s]=t-n*Math.cos(i)}return Ye(a,"float32")}async function fO(e,t,n=1){let r=C(e,"predictions","inTopK"),a=C(t,"targets","inTopK");$(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),$(r.rank-1===a.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${a.rank}`),yn(r.shape.slice(0,r.shape.length-1),a.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let s=r.shape[r.shape.length-1];$(n>0&&n<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${n}`);let i=await r.data(),o=await a.data(),[l,p]=[i.length/s,s],u=T0("bool",l);for(let d=0;d<l;d++){let h=d*p,c=i.subarray(h,h+p),f=[];for(let m=0;m<c.length;m++)f.push({value:c[m],index:m});f.sort((m,g)=>g.value-m.value),u[d]=0;for(let m=0;m<n;m++)if(f[m].index===o[d]){u[d]=1;break}}return e!==r&&r.dispose(),t!==a&&a.dispose(),cn(u,a.shape,"bool")}var pk=fO,tl={};Ee(tl,{conv2d:()=>yO,depthwiseConv2d:()=>wO,matMul:()=>IO});function mO(e,t,n,r,a,s="NHWC",i){let o=e;e.rank===3&&(o=P(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=P(t,[1,t.shape[0],t.shape[1],t.shape[2]])),$(o.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),$(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),$(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);let p=s==="NHWC"?o.shape[3]:o.shape[1],u=s==="NHWC"?l.shape[3]:l.shape[1];$(p===n[2],()=>`Error in conv2dDerFilter: depth of input ${p}) must match input depth in filter (${n[2]}.`),$(u===n[3],()=>`Error in conv2dDerFilter: depth of dy (${u}) must match output depth for filter (${n[3]}).`),bn("conv2dDerFilter",a,i);let d={x:o,dy:l},h={strides:r,pad:a,dataFormat:s,dimRoundingMode:i,filterShape:n};return O.runKernel(Zh,d,h)}var yy=L({conv2DBackpropFilter_:mO});function Pc(e,t,n){if(n==null||n==="linear")return e;if(n==="relu")return z(e,wo(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function Bc(e,t){let n=t,r=Ft(e.shape,t.shape);return r.length>0&&(n=ge(n,r)),P(n,e.shape)}function Wc(e,t,n,r){if(t==="linear")return e;if(t==="relu")return et(e);if(t==="elu")return cu(e);if(t==="relu6")return Sc(e);if(t==="prelu")return sd(e,n);if(t==="leakyrelu")return Qp(e,r);if(t==="sigmoid")return pr(e);throw new Error(`Unknown fused activation ${t}.`)}var Vc=(e,t)=>!(e>0)||t==="linear";function gO({x:e,filter:t,strides:n,pad:r,dataFormat:a="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:p,leakyreluAlpha:u}){if(l=l||"linear",Vc(O.state.gradientDepth,l)===!1){$(a==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${a} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let T=fn(e,t,n,r,a,s,i);return o!=null&&(T=X(T,o)),Wc(T,l,p,u)}let d=C(e,"x","conv2d","float32"),h=C(t,"filter","conv2d","float32"),c=d,f=!1;d.rank===3&&(f=!0,c=P(d,[1,d.shape[0],d.shape[1],d.shape[2]])),$(c.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${c.rank}.`),$(h.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${h.rank}.`),bn("fused conv2d",r,i);let m=a==="NHWC"?c.shape[3]:c.shape[1];$(h.shape[2]===m,()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${h.shape[2]}.`),$(qr(n,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`);let g=Xp(c.shape,h.shape,n,s,r,i),y;o!=null&&(y=C(o,"bias","fused conv2d"),[y]=kt(y,d),a==="NHWC"?ot(g.outShape,y.shape):($(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),$(y.shape.length===0||y.shape[0]===g.outChannels||y.shape[0]===1,()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${g.outChannels})`)));let b;if(p!=null){let T=p.shape;if($(T.length<=1||T.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${T.length}.`),T.length===1)$(T[0]===1||T[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${T}) is not compatible with the number of output channels (${g.outChannels}).`);else if(T.length===3)try{ot(T,g.outShape)}catch{let E=`Error in fused conv2d: PReLU activation weights (${T}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error(E)}b=C(p,"prelu weights","fused conv2d")}let x=(T,_)=>{$(a==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${a} but only NHWC is currently supported.`);let[E,A,R,F]=_,S=Pc(T,R,l);$(Ba(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);let M=Dg(A.shape,S,E,n,r),W=yy(A,S,E.shape,n,r),U=[M,W];if(F!=null){let H=Bc(F,S);U.push(H)}return U},v={x:c,filter:h,bias:y,preluActivationWeights:b},I={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:u};return o==null?Hr((T,_,E)=>{let A=O.runKernel(Rs,v,I);return E([_,T,A]),f&&(A=P(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:x}})(c,h):Hr((T,_,E,A)=>{let R=O.runKernel(Rs,v,I);return A([_,T,R,E]),f&&(R=P(R,[R.shape[1],R.shape[2],R.shape[3]])),{value:R,gradFunc:x}})(c,h,y)}var yO=L({fusedConv2d_:gO});function bO(e,t,n,r,a,s=[1,1],i){let o=e;e.rank===3&&(o=P(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=P(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let p={x:o,dy:l},u={strides:r,pad:a,dimRoundingMode:i,dilations:s,filterShape:n};return O.runKernel(Jh,p,u)}var dk=L({depthwiseConv2dNativeBackpropFilter_:bO});function xO(e,t,n,r,a,s=[1,1],i){let o=t,l=!1;t.rank===3&&(l=!0,o=P(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let p={dy:o,filter:n},u={strides:r,pad:a,dimRoundingMode:i,dilations:s,inputShape:e},d=O.runKernel(Yh,p,u);return l?P(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var hk=L({depthwiseConv2dNativeBackpropInput_:xO});function vO({x:e,filter:t,strides:n,pad:r,dataFormat:a="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:p,leakyreluAlpha:u}){if(Vc(O.state.gradientDepth,l)===!1){let I=xo(e,t,n,r,a,s,i);return o!=null&&(I=X(I,o)),Wc(I,l,p,u)}let d=C(e,"x","depthwiseConv2d","float32"),h=C(t,"filter","depthwiseConv2d","float32"),c=d,f=!1;d.rank===3&&(f=!0,c=P(d,[1,d.shape[0],d.shape[1],d.shape[2]])),$(c.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),$(h.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${h.rank}.`),$(c.shape[3]===h.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${c.shape[3]}) must match the inChannels dimension in filter ${h.shape[2]}.`),s==null&&(s=[1,1]),$(qr(n,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),bn("fused depthwiseConv2d",r,i);let m=Xp(c.shape,h.shape,n,s,r,i,!0),g;o!=null&&(g=C(o,"bias","fused conv2d"),[g]=kt(g,d),ot(m.outShape,g.shape));let y;p!=null&&(y=C(p,"prelu weights","fused depthwiseConv2d"));let b=(I,T)=>{$(Ba(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);let[_,E,A,R]=T,F=Pc(I,A,l),S=hk(E.shape,F,_,n,r,s,i),M=dk(E,F,_.shape,n,r,s,i);if(R!=null){let W=Bc(g,F);return[S,M,W]}return[S,M]},x={x:c,filter:h,bias:g,preluActivationWeights:y},v={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:u};return o==null?Hr((I,T,_)=>{let E=O.runKernel(Ds,x,v);return _([T,I,E]),f&&(E=P(E,[E.shape[1],E.shape[2],E.shape[3]])),{value:E,gradFunc:b}})(c,h):Hr((I,T,_,E)=>{let A=O.runKernel(Ds,x,v);return E([T,I,A,_]),f&&(A=P(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:b}})(c,h,g)}var wO=L({fusedDepthwiseConv2d_:vO});function kO({a:e,b:t,transposeA:n=!1,transposeB:r=!1,bias:a,activation:s="linear",preluActivationWeights:i,leakyreluAlpha:o=.2}){if(Vc(O.state.gradientDepth,s)===!1){let R=Oe(e,t,n,r);return a!=null&&(R=X(R,a)),Wc(R,s,i,o)}let l=C(e,"a","fused matMul"),p=C(t,"b","fused matMul");[l,p]=kt(l,p);let u=n?l.shape[l.rank-2]:l.shape[l.rank-1],d=r?p.shape[p.rank-1]:p.shape[p.rank-2],h=n?l.shape[l.rank-1]:l.shape[l.rank-2],c=r?p.shape[p.rank-2]:p.shape[p.rank-1],f=l.shape.slice(0,-2),m=p.shape.slice(0,-2),g=tt(f),y=tt(m);$(u===d,()=>`Error in fused matMul: inner shapes (${u}) and (${d}) of Tensors with shapes ${l.shape} and ${p.shape} and transposeA=${n} and transposeB=${r} must match.`);let b=ot(l.shape.slice(0,-2),p.shape.slice(0,-2)).concat([h,c]),x=n?P(l,[g,u,h]):P(l,[g,h,u]),v=r?P(p,[y,c,d]):P(p,[y,d,c]),I;a!=null&&(I=C(a,"bias","fused matMul"),[I]=kt(I,l),ot(b,I.shape));let T;i!=null&&(T=C(i,"prelu weights","fused matMul"));let _=(R,F)=>{let[S,M,W,U]=F,H=Pc(P(R,W.shape),W,s),K,j;if(!n&&!r?(K=Oe(H,M,!1,!0),j=Oe(S,H,!0,!1)):!n&&r?(K=Oe(H,M,!1,!1),j=Oe(H,S,!0,!1)):n&&!r?(K=Oe(M,H,!1,!0),j=Oe(S,H,!1,!1)):(K=Oe(M,H,!0,!0),j=Oe(H,S,!0,!0)),a!=null){let Z=Bc(U,H);return[K,j,Z]}else return[K,j]},E={a:x,b:v,bias:I,preluActivationWeights:T},A={transposeA:n,transposeB:r,activation:s,leakyreluAlpha:o};return a==null?Hr((R,F,S)=>{let M=O.runKernel(Fs,E,A);return S([R,F,M]),{value:P(M,b),gradFunc:_}})(x,v):Hr((R,F,S,M)=>{let W=O.runKernel(Fs,E,A);return M([R,F,W,S]),{value:P(W,b),gradFunc:_}})(x,v,I)}var IO=L({fusedMatMul_:kO});function SO(e){return zc(e,.54,.46)}var NO=L({hammingWindow_:SO});function TO(e){return zc(e,.5,.5)}var ck=L({hannWindow_:TO});function CO(e,t,n,r=!1,a=0){let s=0,i=[];for(;s+t<=e.size;)i.push(Ue(e,s,t)),s+=n;if(r)for(;s<e.size;){let o=s+t-e.size,l=it([Ue(e,s,t-o),Bn([o],a)]);i.push(l),s+=n}return i.length===0?Wr([],[0,t]):P(it(i),[i.length,t])}var fk=L({frame_:CO});function _O(e,t,n,r,a=ck){r==null&&(r=gy(t));let s=fk(e,t,n),i=z(s,a(t));return ld(i,r)}var EO=L({stft_:_O});function $O(e,t,n,r,a="bilinear",s=0){let i=C(e,"image","cropAndResize"),o=C(t,"boxes","cropAndResize","float32"),l=C(n,"boxInd","cropAndResize","int32"),p=o.shape[0];$(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),$(o.rank===2&&o.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${p},4] but had shape ${o.shape}.`),$(l.rank===1&&l.shape[0]===p,()=>`Error in cropAndResize: boxInd must be have size [${p}] but had shape ${o.shape}.`),$(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),$(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),$(a==="bilinear"||a==="nearest",()=>`method must be bilinear or nearest, but was ${a}`);let u={image:i,boxes:o,boxInd:l},d={method:a,extrapolationValue:s,cropSize:r};return O.runKernel(Il,u,d)}var AO=L({cropAndResize_:$O});function FO(e){let t=C(e,"image","flipLeftRight","float32");$(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);let n={image:t};return O.runKernel(_l,n,{})}var RO=L({flipLeftRight_:FO});function DO(e){let t=C(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];$(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),$(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);let a=new Array(t.rank);return a.fill(1,0,n),a[n]=3,Pn(t,a)}var MO=L({grayscaleToRGB_:DO});function OO(e){let t=C(e,"image","RGBToGrayscale"),n=t.rank-1,r=t.shape[n];$(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),$(r===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);let a=t.dtype,s=se(t,"float32"),i=Ye([.2989,.587,.114]),o;switch(t.rank){case 2:o=ks("ij,j->i",s,i);break;case 3:o=ks("ijk,k->ij",s,i);break;case 4:o=ks("ijkl,l->ijk",s,i);break;case 5:o=ks("ijklm,m->ijkl",s,i);break;case 6:o=ks("ijklmn,n->ijklm",s,i);break;default:throw new Error("Not a valid tensor rank.")}return o=Ht(o,-1),se(o,a)}var LO=L({rgbToGrayscale_:OO});function zO(e,t,n=0,r=.5){let a=C(e,"image","rotateWithOffset","float32");$(a.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${a.rank}.`);let s={image:a},i={radians:t,fillValue:n,center:r};return O.runKernel(du,s,i)}var PO=L({rotateWithOffset_:zO});function xu(e,t,n,r,a,s){r==null&&(r=.5),a==null&&(a=Number.NEGATIVE_INFINITY),s==null&&(s=0);let i=e.shape[0];return n=Math.min(n,i),$(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),$(e.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),$(e.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),$(t.rank===1,()=>"scores must be a 1D tensor"),$(t.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`),$(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s}}function BO(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY){let s=C(e,"boxes","nonMaxSuppression","float32"),i=C(t,"scores","nonMaxSuppression","float32"),o=xu(s,i,n,r,a);n=o.maxOutputSize,r=o.iouThreshold,a=o.scoreThreshold;let l={maxOutputSize:n,iouThreshold:r,scoreThreshold:a};return O.runKernel(Ul,{boxes:s,scores:i},l)}var WO=L({nonMaxSuppression_:BO});function VO(e,t,n){let r=UO(e,t,n),a=r<0?-(r+1):r;e.splice(a,0,t)}function UO(e,t,n){return HO(e,t,n||GO)}function GO(e,t){return e>t?1:e<t?-1:0}function HO(e,t,n){let r=0,a=e.length,s=0,i=!1;for(;r<a;){s=r+(a-r>>>1);let o=n(t,e[s]);o>0?r=s+1:(a=s,i=!o)}return i?r:-r-1}function mk(e,t,n,r,a){return by(e,t,n,r,a,0)}function gk(e,t,n,r,a,s){return by(e,t,n,r,a,0,!1,s,!0)}function yk(e,t,n,r,a,s){return by(e,t,n,r,a,s,!0)}function by(e,t,n,r,a,s,i=!1,o=!1,l=!1){let p=[];for(let g=0;g<t.length;g++)t[g]>a&&p.push({score:t[g],boxIndex:g,suppressBeginIndex:0});p.sort(Uv);let u=s>0?-.5/s:0,d=[],h=[];for(;d.length<n&&p.length>0;){let g=p.pop(),{score:y,boxIndex:b,suppressBeginIndex:x}=g;if(y<a)break;let v=!1;for(let I=d.length-1;I>=x;--I){let T=jO(e,b,d[I]);if(T>=r){v=!0;break}if(g.score=g.score*qO(r,u,T),g.score<=a)break}g.suppressBeginIndex=d.length,v||(g.score===y?(d.push(b),h.push(g.score)):g.score>a&&VO(p,g,Uv))}let c=d.length,f=n-c;o&&f>0&&(d.push(...new Array(f).fill(0)),h.push(...new Array(f).fill(0)));let m={selectedIndices:d};return i&&(m.selectedScores=h),l&&(m.validOutputs=c),m}function jO(e,t,n){let r=e.subarray(t*4,t*4+4),a=e.subarray(n*4,n*4+4),s=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),p=Math.min(a[0],a[2]),u=Math.min(a[1],a[3]),d=Math.max(a[0],a[2]),h=Math.max(a[1],a[3]),c=(o-s)*(l-i),f=(d-p)*(h-u);if(c<=0||f<=0)return 0;let m=Math.max(s,p),g=Math.max(i,u),y=Math.min(o,d),b=Math.min(l,h),x=Math.max(y-m,0)*Math.max(b-g,0);return x/(c+f-x)}function qO(e,t,n){let r=Math.exp(t*n*n);return n<=e?r:0}function Uv(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}async function KO(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY){let s=C(e,"boxes","nonMaxSuppressionAsync"),i=C(t,"scores","nonMaxSuppressionAsync"),o=xu(s,i,n,r,a);n=o.maxOutputSize,r=o.iouThreshold,a=o.scoreThreshold;let l=await Promise.all([s.data(),i.data()]),p=l[0],u=l[1],{selectedIndices:d}=mk(p,u,n,r,a);return s!==e&&s.dispose(),i!==t&&i.dispose(),Ye(d,"int32")}var XO=KO;function ZO(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=0){let i=C(e,"boxes","nonMaxSuppression"),o=C(t,"scores","nonMaxSuppression"),l=xu(i,o,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;let p={boxes:i,scores:o},u={maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s},d=O.runKernel(Hl,p,u);return{selectedIndices:d[0],selectedScores:d[1]}}var JO=L({nonMaxSuppressionWithScore_:ZO});async function YO(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=0){let i=C(e,"boxes","nonMaxSuppressionAsync"),o=C(t,"scores","nonMaxSuppressionAsync"),l=xu(i,o,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;let p=await Promise.all([i.data(),o.data()]),u=p[0],d=p[1],{selectedIndices:h,selectedScores:c}=yk(u,d,n,r,a,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Ye(h,"int32"),selectedScores:Ye(c)}}var QO=YO;function e3(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=!1){let i=C(e,"boxes","nonMaxSuppression"),o=C(t,"scores","nonMaxSuppression"),l=xu(i,o,n,r,a,null),p=l.maxOutputSize,u=l.iouThreshold,d=l.scoreThreshold,h={boxes:i,scores:o},c={maxOutputSize:p,iouThreshold:u,scoreThreshold:d,padToMaxOutputSize:s},f=O.runKernel(Gl,h,c);return{selectedIndices:f[0],validOutputs:f[1]}}var t3=L({nonMaxSuppressionPadded_:e3});async function n3(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=!1){let i=C(e,"boxes","nonMaxSuppressionAsync"),o=C(t,"scores","nonMaxSuppressionAsync"),l=xu(i,o,n,r,a,null),p=l.maxOutputSize,u=l.iouThreshold,d=l.scoreThreshold,[h,c]=await Promise.all([i.data(),o.data()]),{selectedIndices:f,validOutputs:m}=gk(h,c,p,u,d,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Ye(f,"int32"),validOutputs:we(m,"int32")}}var r3=n3;function a3(e,t,n=!1,r=!1){let a=C(e,"images","resizeBilinear");$(a.rank===3||a.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${a.rank}.`),$(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),$(r===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=a,i=!1;a.rank===3&&(i=!0,s=P(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let o={images:s},l={alignCorners:n,halfPixelCenters:r,size:t},p=O.runKernel(Qi,o,l);return i?P(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var bk=L({resizeBilinear_:a3});function s3(e,t,n=!1,r=!1){let a=C(e,"images","resizeNearestNeighbor");$(a.rank===3||a.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${a.rank}.`),$(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),$(a.dtype==="float32"||a.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),$(r===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=a,i=!1;a.rank===3&&(i=!0,s=P(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let o={images:s},l={alignCorners:n,halfPixelCenters:r,size:t},p=O.runKernel(Yi,o,l);return i?P(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var xk=L({resizeNearestNeighbor_:s3});function i3(e,t="binary",n=!1,r=.5){let a=C(e,"image","threshold"),s=.2989,i=.587,o=.114,l=a.shape[0]*a.shape[1],p=z(Ye([r]),255),u,d,h,c;if($(a.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${a.rank}.`),$(a.shape[2]===3||a.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${a.shape[2]}.`),$(a.dtype==="int32"||a.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${a.dtype}.`),$(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),a.shape[2]===3){[u,d,h]=Tn(a,[1,1,1],-1);let m=z(u,s),g=z(d,i),y=z(h,o);c=X(X(m,g),y)}else c=e;if(t==="otsu"){let m=_g(se(Nc(c),"int32"),cn([]),256);p=o3(m,l)}let f=n?rs(c,p):xn(c,p);return se(z(f,255),"int32")}function o3(e,t){let n=Ye([-1]),r=Ye([0]),a=Ye([0]),s,i,o,l,p,u;for(let d=0;d<e.size-1;d++){s=Ue(e,0,d+1),i=Ue(e,d+1),p=fe(ge(s),t),u=fe(ge(i),t);let h=ge(z(s,Us(0,s.size)));o=fe(h,ge(s));let c=Bn(i.shape,s.size),f=X(Us(0,i.size),c),m=z(i,f);l=fe(ge(m),ge(i));let g=de(o,l),y=de(o,l),b=z(p,u);a=z(z(b,g),y);let x=xn(a,r);r=qt(x,a,r),n=qt(x,Ye([d]),n)}return n}var l3=L({threshold_:i3});function u3(e,t,n="nearest",r="constant",a=0,s){let i=C(e,"image","transform","float32"),o=C(t,"transforms","transform","float32");$(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),$(o.rank===2&&(o.shape[0]===i.shape[0]||o.shape[0]===1)&&o.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),$(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);let l={image:i,transforms:o},p={interpolation:n,fillMode:r,fillValue:a,outputShape:s};return O.runKernel(lu,l,p)}var p3=L({transform_:u3});function d3(e,t,n){let r=C(e,"a","bandPart");$(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);let a=r.shape,[s,i]=r.shape.slice(-2),o,l;typeof t=="number"?($(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),$(t<=s,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${s}).`),o=C(t<0?s:t,"numLower","bandPart")):($(t.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),o=qt(Zo(t,0),s,Va(t,s))),typeof n=="number"?($(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`),$(n<=i,()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`),l=C(n<0?i:n,"numUpper","bandPart")):($(n.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=qt(Zo(n,0),i,Va(n,i)));let p=P(Us(0,s,1,"int32"),[-1,1]),u=Us(0,i,1,"int32"),d=de(p,u),h=dr(rs(d,o),ca(d,ct(l))),c=vt([s,i],r.dtype);return P(At(St(P(r,[-1,s,i])).map(f=>qt(h,f,c))),a)}var h3=L({bandPart_:d3});function c3(e){let t;if(Array.isArray(e)){t=!1,$(e!=null&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let a=e[0].shape[0];for(let s=1;s<e.length;++s)$(e[s].shape[0]===a,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[s].shape[0]} vs. ${a})`)}else t=!0,e=Tn(e,e.shape[0],0).map(a=>is(a,[0]));$(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);let n=[],r=e;for(let a=0;a<e.length;++a)n.push(O.tidy(()=>{let s=r[a];if(a>0)for(let i=0;i<a;++i){let o=z(ge(z(n[i],s)),n[i]);s=de(s,o)}return fe(s,fu(s,"euclidean"))}));return t?At(n,0):n}var f3=L({gramSchmidt_:c3});function m3(e,t=!1){if($(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),e.rank===2)return Gv(e,t);{let n=e.shape.slice(0,e.shape.length-2).reduce((l,p)=>l*p),r=St(P(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),a=[],s=[];r.forEach(l=>{let[p,u]=Gv(l,t);a.push(p),s.push(u)});let i=P(At(a,0),e.shape),o=P(At(s,0),e.shape);return[i,o]}}function Gv(e,t=!1){return O.tidy(()=>{$(e.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);let n=e.shape[0],r=e.shape[1],a=bc(n),s=Br(e),i=Wr([[1]],[1,1]),o=Br(i),l=n>=r?r:n;for(let p=0;p<l;++p){let u=s,d=o,h=a;[o,s,a]=O.tidy(()=>{let c=Ue(s,[p,p],[n-p,1]),f=fu(c),m=Ue(s,[p,p],[1,1]),g=qt(xn(m,0),Wr([[-1]]),Wr([[1]])),y=de(m,z(g,f)),b=fe(c,y);b.shape[0]===1?o=Br(i):o=it([i,Ue(b,[1,0],[b.shape[0]-1,b.shape[1]])],0);let x=ct(fe(Oe(g,y),f)),v=Ue(s,[p,0],[n-p,r]),I=z(x,o),T=Le(o);if(p===0)s=de(v,Oe(I,Oe(T,v)));else{let A=de(v,Oe(I,Oe(T,v)));s=it([Ue(s,[0,0],[p,r]),A],0)}let _=Le(I),E=Ue(a,[0,p],[n,a.shape[1]-p]);if(p===0)a=de(E,Oe(Oe(E,o),_));else{let A=de(E,Oe(Oe(E,o),_));a=it([Ue(a,[0,0],[n,p]),A],1)}return[o,s,a]}),_e([u,d,h])}return!t&&n>r&&(a=Ue(a,[0,0],[n,r]),s=Ue(s,[0,0],[r,r])),[a,s]})}var g3=L({qr_:m3}),dn;(function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(dn||(dn={}));function y3(e,t,n=dn.SUM_BY_NONZERO_WEIGHTS){let r=C(e,"losses","computeWeightedLoss"),a=null;t!=null&&(a=C(t,"weights","computeWeightedLoss"));let s=a==null?r:z(r,a);if(n===dn.NONE)return s;if(n===dn.SUM)return ge(s);if(n===dn.MEAN){if(a==null)return xt(s);{let i=r.size/a.size,o=fe(ge(s),ge(a));return i>1?fe(o,we(i)):o}}if(n===dn.SUM_BY_NONZERO_WEIGHTS){if(a==null)return fe(ge(s),we(r.size));{let i=z(a,Nn(r.shape)),o=se(ge(Vs(i,we(0))),"float32");return fe(ge(s),o)}}throw Error(`Unknown reduction: ${n}`)}var fa=L({computeWeightedLoss_:y3});function b3(e,t,n,r=dn.SUM_BY_NONZERO_WEIGHTS){let a=C(e,"labels","absoluteDifference"),s=C(t,"predictions","absoluteDifference"),i=null;n!=null&&(i=C(n,"weights","absoluteDifference")),yn(a.shape,s.shape,"Error in absoluteDifference: ");let o=_t(de(a,s));return fa(o,i,r)}var x3=L({absoluteDifference_:b3});function v3(e,t,n,r,a=dn.SUM_BY_NONZERO_WEIGHTS){let s=C(e,"labels","cosineDistance"),i=C(t,"predictions","cosineDistance"),o=null;r!=null&&(o=C(r,"weights","cosineDistance")),yn(s.shape,i.shape,"Error in cosineDistance: ");let l=we(1),p=de(l,ge(z(s,i),n,!0));return fa(p,o,a)}var w3=L({cosineDistance_:v3});function k3(e,t,n,r=dn.SUM_BY_NONZERO_WEIGHTS){let a=C(e,"labels","hingeLoss"),s=C(t,"predictions","hingeLoss"),i=null;n!=null&&(i=C(n,"weights","hingeLoss")),yn(a.shape,s.shape,"Error in hingeLoss: ");let o=we(1);a=de(z(we(2),a),o);let l=et(de(o,z(a,s)));return fa(l,i,r)}var I3=L({hingeLoss_:k3});function S3(e,t,n,r=1,a=dn.SUM_BY_NONZERO_WEIGHTS){let s=C(e,"labels","huberLoss"),i=C(t,"predictions","huberLoss"),o=null;n!=null&&(o=C(n,"weights","huberLoss")),yn(s.shape,i.shape,"Error in huberLoss: ");let l=we(r),p=_t(de(i,s)),u=Va(p,l),d=de(p,u),h=X(z(we(.5),st(u)),z(l,d));return fa(h,o,a)}var N3=L({huberLoss_:S3});function T3(e,t,n,r=1e-7,a=dn.SUM_BY_NONZERO_WEIGHTS){let s=C(e,"labels","logLoss"),i=C(t,"predictions","logLoss"),o=null;n!=null&&(o=C(n,"weights","logLoss")),yn(s.shape,i.shape,"Error in logLoss: ");let l=we(1),p=we(r),u=ct(z(s,Vn(X(i,p)))),d=z(de(l,s),Vn(X(de(l,i),p))),h=de(u,d);return fa(h,o,a)}var C3=L({logLoss_:T3});function _3(e,t,n,r=dn.SUM_BY_NONZERO_WEIGHTS){let a=C(e,"labels","meanSquaredError"),s=C(t,"predictions","meanSquaredError"),i=null;n!=null&&(i=C(n,"weights","meanSquaredError")),yn(a.shape,s.shape,"Error in meanSquaredError: ");let o=Fc(a,s);return fa(o,i,r)}var E3=L({meanSquaredError_:_3});function $3(e,t){let n=C(e,"labels","sigmoidCrossEntropyWithLogits"),r=C(t,"logits","sigmoidCrossEntropyWithLogits");yn(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");let a=et(r),s=z(r,n),i=ed(sn(ct(_t(r))));return X(de(a,s),i)}function A3(e,t,n,r=0,a=dn.SUM_BY_NONZERO_WEIGHTS){let s=C(e,"multiClassLabels","sigmoidCrossEntropy"),i=C(t,"logits","sigmoidCrossEntropy"),o=null;if(n!=null&&(o=C(n,"weights","sigmoidCrossEntropy")),yn(s.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){let p=we(r),u=we(1),d=we(.5);s=X(z(s,de(u,p)),z(d,p))}let l=$3(s,i);return fa(l,o,a)}var F3=L({sigmoidCrossEntropy_:A3});function R3(e,t,n=-1){if(n===-1&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return Hr((r,a,s)=>{let i=td(a,[n],!0),o=de(se(a,"float32"),i);s([r,o]);let l=ct(z(o,r));return{value:ge(l,[n]),gradFunc:(p,u)=>{let[d,h]=u,c=Ws(p.shape,[n]);return[z(P(p,c),de(se(d,"float32"),sn(h))),z(P(p,c),de(sn(h),se(d,"float32")))]}}})(e,t)}function D3(e,t,n,r=0,a=dn.SUM_BY_NONZERO_WEIGHTS){let s=C(e,"onehotLabels","softmaxCrossEntropy"),i=C(t,"logits","softmaxCrossEntropy"),o=null;if(n!=null&&(o=C(n,"weights","softmaxCrossEntropy")),yn(s.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){let p=we(r),u=we(1),d=we(s.shape[1]);s=X(z(s,de(u,p)),fe(p,d))}let l=R3(s,i);return fa(l,o,a)}var M3=L({softmaxCrossEntropy_:D3});function O3(e,t,n,r){let a=C(e,"indices","sparseFillEmptyRows","int32"),s=C(t,"values","sparseFillEmptyRows"),i=C(n,"denseShape","sparseFillEmptyRows","int32"),o=C(r,"defaultValue","sparseFillEmptyRows",s.dtype);if(a.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${a.shape}`);if(s.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(o.rank!==0)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);let l={indices:a,values:s,denseShape:i,defaultValue:o},p=O.runKernel(Dp,l);return{outputIndices:p[0],outputValues:p[1],emptyRowIndicator:p[2],reverseIndexMap:p[3]}}var L3=L({sparseFillEmptyRows_:O3});function z3(e,t,n){let r=C(e,"inputIndices","sparseReshape","int32"),a=C(t,"inputShape","sparseReshape","int32"),s=C(n,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(a.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${a.shape}`);if(s.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);let i={inputIndices:r,inputShape:a,newShape:s},o=O.runKernel(au,i);return{outputIndices:o[0],outputShape:o[1]}}var P3=L({sparseReshape_:z3});function B3(e,t,n){let r=C(e,"data","sparseSegmentMean"),a=C(t,"indices","sparseSegmentMean","int32"),s=C(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${a.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);let i={data:r,indices:a,segmentIds:s};return O.runKernel(Mp,i)}var W3=L({sparseSegmentMean_:B3});function V3(e,t,n){let r=C(e,"data","sparseSegmentSum"),a=C(t,"indices","sparseSegmentSum","int32"),s=C(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${a.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);let i={data:r,indices:a,segmentIds:s};return O.runKernel(Op,i)}var U3=L({sparseSegmentSum_:V3});function G3(e,t,n,r,a,s,i,o){let l=C(e,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);let p=C(t,"dataSplits","stringNGrams");if(p.dtype!=="int32")throw new Error("Data splits must be of datatype int32");let u={separator:n,nGramWidths:r,leftPad:a,rightPad:s,padWidth:i,preserveShortSequences:o},d={data:l,dataSplits:p},h=O.runKernel(Pp,d,u);return{nGrams:h[0],nGramsSplits:h[1]}}var H3=L({stringNGrams_:G3});function j3(e,t,n=!0){let r=C(e,"input","stringSplit","string"),a=C(t,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(a.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${a.shape}`);let s={skipEmpty:n},i={input:r,delimiter:a},o=O.runKernel(Bp,i,s);return{indices:o[0],values:o[1],shape:o[2]}}var q3=L({stringSplit_:j3});function K3(e,t){let n=C(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");let a={input:n};return O.runKernel(Wp,a,r)}var X3=L({stringToHashBucketFast_:K3});function Z3(e,t,n,r=!0){let a=C(e,"input","staticRegexReplace","string"),s={pattern:t,rewrite:n,replaceGlobal:r};return O.runKernel(zp,{x:a},s)}var J3=L({staticRegexReplace_:Z3}),vk={fft:od,ifft:el,rfft:ld,irfft:Ac},wk={hammingWindow:NO,hannWindow:ck,frame:fk,stft:EO},Zn={flipLeftRight:RO,grayscaleToRGB:MO,resizeNearestNeighbor:xk,resizeBilinear:bk,rgbToGrayscale:LO,rotateWithOffset:PO,cropAndResize:AO,nonMaxSuppression:WO,nonMaxSuppressionAsync:XO,nonMaxSuppressionWithScore:JO,nonMaxSuppressionWithScoreAsync:QO,nonMaxSuppressionPadded:t3,nonMaxSuppressionPaddedAsync:r3,threshold:l3,transform:p3},xy={bandPart:h3,gramSchmidt:f3,qr:g3},kk={absoluteDifference:x3,computeWeightedLoss:fa,cosineDistance:w3,hingeLoss:I3,huberLoss:N3,logLoss:C3,meanSquaredError:E3,sigmoidCrossEntropy:F3,softmaxCrossEntropy:M3},Ik={sparseFillEmptyRows:L3,sparseReshape:P3,sparseSegmentMean:W3,sparseSegmentSum:U3},Sk={stringNGrams:H3,stringSplit:q3,stringToHashBucketFast:X3,staticRegexReplace:J3},ne={};Ee(ne,{Serializable:()=>Nk,SerializationMap:()=>Tk,getRegisteredName:()=>Q3,registerClass:()=>Ck});var Y3=new Map,um=new Map,Nk=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},Tk=class zo{constructor(){this.classNameMap={}}static getMap(){return zo.instance==null&&(zo.instance=new zo),zo.instance}static register(t){zo.getMap().classNameMap[t.className]=[t,t.fromConfig]}};function Ck(e,t,n){$(e.className!=null,()=>"Class being registered does not have the static className property defined."),$(typeof e.className=="string",()=>"className is required to be a string, but got type "+typeof e.className),$(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof t>"u"&&(t="Custom"),typeof n>"u"&&(n=e.className);let r=n,a=t+">"+r;return Tk.register(e),Y3.set(a,e),um.set(e,a),e}function Q3(e){return um.has(e)?um.get(e):e.className}var ma=class extends Nk{minimize(e,t=!1,n){let{value:r,grads:a}=this.computeGradients(e,n);if(n!=null){let s=n.map(i=>({name:i.name,tensor:a[i.name]}));this.applyGradients(s)}else this.applyGradients(a);return _e(a),t?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return C1(e,t)}dispose(){this.iterations_!=null&&_e(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:we(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(ma,Symbol.hasInstance,{value:e=>e.minimize!=null&&e.computeGradients!=null&&e.applyGradients!=null});var vy=class extends ma{static get className(){return"Adadelta"}constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],n==null&&(this.epsilon=O.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=O.registeredVariables[t],a=!1;this.accumulatedGrads[n]==null&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:B(()=>He(r).variable(a))}),this.accumulatedUpdates[n]==null&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:B(()=>He(r).variable(a))});let s=Array.isArray(e)?e[n].tensor:e[t];if(s==null)return;let i=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;B(()=>{let l=X(z(i,this.rho),z(st(s),1-this.rho)),p=z(fe(Kt(X(o,this.epsilon)),Kt(X(i,this.epsilon))),s),u=X(z(o,this.rho),z(st(p),1-this.rho));i.assign(l),o.assign(u);let d=X(z(p,-this.learningRate),r);r.assign(d)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(_e(this.accumulatedGrads.map(e=>e.variable)),_e(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=e.length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedUpdates=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}},wy=class extends ma{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=O.registeredVariables[t];this.accumulatedGrads[n]==null&&(this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:B(()=>Bn(r.shape,this.initialAccumulatorValue).variable(!1))});let a=Array.isArray(e)?e[n].tensor:e[t];if(a==null)return;let s=this.accumulatedGrads[n].variable;B(()=>{let i=X(s,st(a));s.assign(i);let o=X(z(fe(a,Kt(X(i,O.backend.epsilon()))),-this.learningRate),r);r.assign(o)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&_e(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulatedGrads=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}},ky=class extends ma{static get className(){return"Adam"}constructor(e,t,n,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],B(()=>{this.accBeta1=we(t).variable(),this.accBeta2=we(n).variable()}),r==null&&(this.epsilon=O.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);B(()=>{let n=de(1,this.accBeta1),r=de(1,this.accBeta2);t.forEach((a,s)=>{let i=O.registeredVariables[a],o=!1;this.accumulatedFirstMoment[s]==null&&(this.accumulatedFirstMoment[s]={originalName:`${a}/m`,variable:B(()=>He(i).variable(o))}),this.accumulatedSecondMoment[s]==null&&(this.accumulatedSecondMoment[s]={originalName:`${a}/v`,variable:B(()=>He(i).variable(o))});let l=Array.isArray(e)?e[s].tensor:e[a];if(l==null)return;let p=this.accumulatedFirstMoment[s].variable,u=this.accumulatedSecondMoment[s].variable,d=X(z(p,this.beta1),z(l,1-this.beta1)),h=X(z(u,this.beta2),z(st(l),1-this.beta2)),c=fe(d,n),f=fe(h,r);p.assign(d),u.assign(h);let m=X(z(fe(c,X(Kt(f),this.epsilon)),-this.learningRate),i);i.assign(m)}),this.accBeta1.assign(z(this.accBeta1,this.beta1)),this.accBeta2.assign(z(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&_e(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&_e(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),B(()=>{this.accBeta1.assign(Gr(this.beta1,this.iterations_+1)),this.accBeta2.assign(Gr(this.beta2,this.iterations_+1))});let t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}},Iy=class extends ma{static get className(){return"Adamax"}constructor(e,t,n,r=null,a=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],B(()=>{this.iteration=we(0).variable(),this.accBeta1=we(t).variable()}),r==null&&(this.epsilon=O.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);B(()=>{let n=de(1,this.accBeta1),r=fe(-this.learningRate,X(z(this.iteration,this.decay),1));t.forEach((a,s)=>{let i=O.registeredVariables[a],o=!1;this.accumulatedFirstMoment[s]==null&&(this.accumulatedFirstMoment[s]={originalName:`${a}/m`,variable:He(i).variable(o)}),this.accumulatedWeightedInfNorm[s]==null&&(this.accumulatedWeightedInfNorm[s]={originalName:`${a}/v`,variable:He(i).variable(o)});let l=Array.isArray(e)?e[s].tensor:e[a];if(l==null)return;let p=this.accumulatedFirstMoment[s].variable,u=this.accumulatedWeightedInfNorm[s].variable,d=X(z(p,this.beta1),z(l,1-this.beta1)),h=z(u,this.beta2),c=_t(l),f=Kr(h,c);p.assign(d),u.assign(f);let m=X(z(fe(r,n),fe(d,X(f,this.epsilon))),i);i.assign(m)}),this.iteration.assign(X(this.iteration,1)),this.accBeta1.assign(z(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&_e(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&_e(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}},Uc=class extends ma{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=Array.isArray(e)?e[n].tensor:e[t];if(r==null)return;let a=O.registeredVariables[t];B(()=>{let s=X(z(this.c,r),a);a.assign(s)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=Mt(we(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}},Sy=class extends Uc{static get className(){return"Momentum"}constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=we(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=O.registeredVariables[t];this.accumulations[n]==null&&(this.accumulations[n]={originalName:`${t}/momentum`,variable:B(()=>He(r).variable(!1))});let a=this.accumulations[n].variable,s=Array.isArray(e)?e[n].tensor:e[t];s!=null&&B(()=>{let i,o=X(z(this.m,a),s);this.useNesterov?i=X(z(this.c,X(s,z(o,this.m))),r):i=X(z(this.c,o),r),a.assign(o),r.assign(i)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&_e(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulations=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}},Ny=class extends ma{static get className(){return"RMSProp"}constructor(e,t=.9,n=0,r=null,a=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,r==null&&(this.epsilon=O.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=O.registeredVariables[t],a=!1;this.accumulatedMeanSquares[n]==null&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:B(()=>He(r).variable(a))}),this.accumulatedMoments[n]==null&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:B(()=>He(r).variable(a))}),this.accumulatedMeanGrads[n]==null&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:B(()=>He(r).variable(a))});let s=Array.isArray(e)?e[n].tensor:e[t];if(s==null)return;let i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;B(()=>{let l=X(z(i,this.decay),z(st(s),1-this.decay));if(this.centered){let p=this.accumulatedMeanGrads[n].variable,u=X(z(p,this.decay),z(s,1-this.decay)),d=fe(z(s,this.learningRate),Kt(de(l,X(st(u),this.epsilon)))),h=X(z(o,this.momentum),d);i.assign(l),p.assign(u),o.assign(h);let c=de(r,h);r.assign(c)}else{let p=X(z(i,this.decay),z(st(s),1-this.decay)),u=X(z(o,this.momentum),fe(z(s,this.learningRate),Kt(X(p,this.epsilon))));i.assign(p),o.assign(u);let d=de(r,u);r.assign(d)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&_e(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&_e(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&_e(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedMoments=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}},eL=[vy,wy,ky,Iy,Sy,Ny,Uc];function tL(){for(let e of eL)Ck(e)}var nn={};Ee(nn,{CompositeArrayBuffer:()=>da,browserFiles:()=>lL,browserHTTPRequest:()=>fL,concatenateArrayBuffers:()=>VA,copyModel:()=>pF,decodeWeights:()=>Q0,decodeWeightsStream:()=>t1,encodeWeights:()=>OA,fromMemory:()=>gL,fromMemorySync:()=>Fk,getLoadHandlers:()=>ZA,getModelArtifactsForJSON:()=>cg,getModelArtifactsForJSONSync:()=>r1,getModelArtifactsInfoForJSON:()=>Kp,getSaveHandlers:()=>XA,getWeightSpecs:()=>rm,http:()=>Cy,isHTTPScheme:()=>dm,listModels:()=>lF,loadWeights:()=>pL,moveModel:()=>dF,registerLoadRouter:()=>KA,registerSaveRouter:()=>qA,removeModel:()=>uF,weightsLoaderFactory:()=>Ek,withSaveHandler:()=>yL,withSaveHandlerSync:()=>bL});var nL="model",rL=".json",aL=".weights.bin";function Hv(e){return new Promise(t=>setTimeout(t)).then(e)}var vh=class pm{constructor(t){if(!G().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(pm.URL_SCHEME)&&(t=t.slice(pm.URL_SCHEME.length)),(t==null||t.length===0)&&(t=nL),this.modelJsonFileName=t+rL,this.weightDataFileName=t+aL}async save(t){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let n=da.join(t.weightData),r=window.URL.createObjectURL(new Blob([n],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let a=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],s=n1(t,a),i=window.URL.createObjectURL(new Blob([JSON.stringify(s)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=i,await Hv(()=>o.dispatchEvent(new MouseEvent("click"))),t.weightData!=null){let l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=r,await Hv(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Kp(t)}}}};vh.URL_SCHEME="downloads://";var sL=class{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{let n=new FileReader;n.onload=r=>{let a=JSON.parse(r.target.result),s=a.modelTopology;if(s==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(a.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:s});return}let i=cg(a,o=>this.loadWeights(o));e(i)},n.onerror=r=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(e){let t=[],n=[];for(let s of e)t.push(...s.weights),n.push(...s.paths);let r=this.checkManifestAndWeightFiles(e),a=n.map(s=>this.loadWeightsFile(s,r[s]));return Promise.all(a).then(s=>[t,s])}loadWeightsFile(e,t){return new Promise((n,r)=>{let a=new FileReader;a.onload=s=>{let i=s.target.result;n(i)},a.onerror=s=>r(`Failed to weights data from file of path '${e}'.`),a.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){let t=[],n=this.weightsFiles.map(a=>Vv(a.name)),r={};for(let a of e)a.paths.forEach(s=>{let i=Vv(s);if(t.indexOf(i)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(t.push(i),n.indexOf(i)===-1)throw new Error(`Weight file with basename '${i}' is not provided.`);r[s]=this.weightsFiles[n.indexOf(i)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}},iL=e=>G().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(vh.URL_SCHEME)?oL(e.slice(vh.URL_SCHEME.length)):null;nr.registerSaveRouter(iL);function oL(e="model"){return new vh(e)}function lL(e){return new sL(e)}function jv(e,t,n,r){i(e),n=n??0,r=r??1,o(n,r);let a=0,s=l=>(l.then(p=>{let u=n+ ++a/e.length*(r-n);return t(u),p}),l);function i(l){$(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function o(l,p){$(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),$(p>=0&&p<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${p}`),$(p>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${p}`)}return Promise.all(e.map(s))}async function _k(e,t){t==null&&(t={});let n=t.fetchFunc==null?G().platform.fetch:t.fetchFunc,r=e.map(s=>n(s,t.requestInit,{isBinary:!0})),a=(t.onProgress==null?await Promise.all(r):await jv(r,t.onProgress,0,.5)).map(s=>s.arrayBuffer());return t.onProgress==null?await Promise.all(a):await jv(a,t.onProgress,.5,1)}function uL(e,t){var n;let r=t.fetchFunc==null?G().platform.fetch:t.fetchFunc,a=0,s;return(n=t.onProgress)===null||n===void 0||n.call(t,0),new ReadableStream({pull:async i=>{for(var o;a<e.length;){s||(s=(await r(e[a],t.requestInit,{isBinary:!0})).body.getReader());let{done:l,value:p}=await s.read();if(l){a++,s=void 0,(o=t.onProgress)===null||o===void 0||o.call(t,a/e.length);continue}i.enqueue(p);return}i.close()}})}async function pL(e,t="",n,r){return Ek(a=>_k(a,{requestInit:r}))(e,t,n)}function Ek(e){return async(t,n="",r)=>{let a=t.map(()=>!1),s={},i=r!=null?r.map(()=>!1):[],o=[];if(t.forEach((c,f)=>{let m=0;c.weights.forEach(g=>{let y="quantization"in g?g.quantization.dtype:g.dtype,b=Os[y]*tt(g.shape),x=()=>{a[f]=!0,s[f]==null&&(s[f]=[]),s[f].push({manifestEntry:g,groupOffset:m,sizeBytes:b})};r!=null?r.forEach((v,I)=>{v===g.name&&(x(),i[I]=!0)}):x(),o.push(g.name),m+=b})}),!i.every(c=>c)){let c=r.filter((f,m)=>!i[m]);throw new Error(`Could not find weights in manifest with names: ${c.join(", ")}. 
Manifest JSON has weights with names: ${o.join(", ")}.`)}let l=a.reduce((c,f,m)=>(f&&c.push(m),c),[]),p=[];l.forEach(c=>{t[c].paths.forEach(f=>{let m=n+(n.endsWith("/")?"":"/")+f;p.push(m)})});let u=await e(p),d={},h=0;return l.forEach(c=>{let f=t[c].paths.length,m=new da(u.slice(h,h+f));s[c].forEach(g=>{let y=m.slice(g.groupOffset,g.groupOffset+g.sizeBytes),b=Q0(y,[g.manifestEntry]);for(let x in b)d[x]=b[x]}),h+=f}),d}}var dL="application/octet-stream",hL="application/json",Ty=class{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?($(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=G().platform.fetch,$(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&$(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=n1(e,n);if(t.body.append("model.json",new Blob([JSON.stringify(r)],{type:hL}),"model.json"),e.weightData!=null){let s=da.join(e.weightData);t.body.append("model.weights.bin",new Blob([s],{type:dL}),"model.weights.bin")}let a=await this.fetch(this.path,t);if(a.ok)return{modelArtifactsInfo:Kp(e),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)}async loadModelJSON(){let e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let s=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?s+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":s+=" Please make sure the server is serving valid JSON for this request.",new Error(s)}let n=t.modelTopology,r=t.weightsManifest;if(n==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();let e=await this.loadModelJSON();return cg(e,t=>this.loadWeights(t))}async loadStream(){let e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=rm(e.weightsManifest),r=()=>uL(t,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:r})}async getWeightUrls(e){let t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=cL(t),a=this.weightPathPrefix||n,s=[],i=[];for(let o of e)for(let l of o.paths)this.weightUrlConverter!=null?i.push(this.weightUrlConverter(l)):s.push(a+l+r);return this.weightUrlConverter&&s.push(...await Promise.all(i)),s}async loadWeights(e){let t=await this.getWeightUrls(e),n=rm(e),r=await _k(t,this.loadOptions);return[n,r]}};Ty.URL_SCHEME_REGEX=/^https?:\/\//;function cL(e){let t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),r=e.substring(0,t),a=n>t?e.substring(n):"";return[r+"/",a]}function dm(e){return e.match(Ty.URL_SCHEME_REGEX)!=null}var $k=(e,t)=>{if(typeof fetch>"u"&&(t==null||t.fetchFunc==null))return null;{let n=!0;if(Array.isArray(e)?n=e.every(r=>dm(r)):n=dm(e),n)return Cy(e,t)}return null};nr.registerSaveRouter($k);nr.registerLoadRouter($k);function Cy(e,t){return new Ty(e,t)}function fL(e,t){return Cy(e,t)}var Ff=class{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}},Ak=class{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}},mL=class{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}};function gL(e,t,n,r){let a=arguments;return new mL(Fk(...a))}function Fk(e,t,n,r){return arguments.length===1?e.modelTopology!=null||e.weightSpecs!=null?new Ff(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Ff({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Ff({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r}))}function yL(e){return new Ak(e)}function bL(e){return new Ak(e)}var Rk={};Ee(Rk,{confusionMatrix:()=>vL});function xL(e,t,n){let r=C(e,"labels","confusionMatrix"),a=C(t,"predictions","confusionMatrix");$(n==null||n>0&&Number.isInteger(n),()=>`If provided, numClasses must be a positive integer, but got ${n}`),$(r.rank===1,()=>`Expected the rank of labels to be 1, but got ${r.rank}`),$(a.rank===1,()=>`Expected the rank of predictions to be 1, but got ${a.rank}`),$(r.shape[0]===a.shape[0],()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${a.shape[0]}. Labels and predictions should have the same number of elements.`),$(n>0&&Number.isInteger(n),()=>`numClasses is required to be a positive integer, but got ${n}`);let s=Jo(se(r,"int32"),n),i=Jo(se(a,"int32"),n),o=Le(s),l=Oe(o,i);return se(l,"int32")}var vL=L({confusionMatrix_:xL}),ud={};Ee(ud,{draw:()=>_L,fromPixels:()=>EL,fromPixelsAsync:()=>NL,toPixels:()=>CL});var gs,qv=!1;function Dk(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(e==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,a=!1,s=!1,i=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if(typeof ImageData<"u"&&e instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&e instanceof HTMLVideoElement)a=!0;else if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement)s=!0;else if(e.getContext!=null)i=!0;else if(typeof ImageBitmap<"u"&&e instanceof ImageBitmap)o=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);if(sp(gh,O.backendName)!=null){let h={pixels:e},c={numChannels:t};return O.runKernel(gh,h,c)}let[l,p]=a?[e.videoWidth,e.videoHeight]:[e.width,e.height],u;if(i)u=e.getContext("2d").getImageData(0,0,l,p).data;else if(r||n)u=e.data;else if(s||a||o){if(gs==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")gs=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else gs=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});gs.canvas.width=l,gs.canvas.height=p,gs.drawImage(e,0,0,l,p),u=gs.getImageData(0,0,l,p).data}let d;if(t===4)d=new Int32Array(u);else{let h=l*p;d=new Int32Array(h*t);for(let c=0;c<h;c++)for(let f=0;f<t;++f)d[c*t+f]=u[c*4+f]}return Rc(d,[p,l,t],"int32")}function wL(e){return e!=null&&e.data instanceof Uint8Array}function kL(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function IL(e){return e!=null&&e.width!==0&&e.height!==0}function SL(e){return kL()&&!(e instanceof ImageBitmap)&&IL(e)&&!wL(e)}async function NL(e,t=3){let n=null;if(G().getBool("WRAP_TO_IMAGEBITMAP")&&SL(e)){let r;try{r=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch{r=null}r!=null&&r.width===e.width&&r.height===e.height?n=r:n=e}else n=e;return Dk(n,t)}function Mk(e){if(e.rank!==2&&e.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);let t=e.rank===2?1:e.shape[2];if(t>4||t===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if(e.dtype!=="float32"&&e.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`)}function TL(e){let t=(e==null?void 0:e.alpha)||1;if(t>1||t<0)throw new Error(`Alpha value ${t} is suppoed to be in range [0 - 1].`)}async function CL(e,t){let n=C(e,"img","toPixels");if(!(e instanceof Fe)){let p=n;n=se(p,"int32"),p.dispose()}Mk(n);let[r,a]=n.shape.slice(0,2),s=n.rank===2?1:n.shape[2],i=await n.data(),o=n.dtype==="float32"?255:1,l=new Uint8ClampedArray(a*r*4);for(let p=0;p<r*a;++p){let u=[0,0,0,255];for(let h=0;h<s;h++){let c=i[p*s+h];if(n.dtype==="float32"){if(c<0||c>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${c}.`)}else if(n.dtype==="int32"&&(c<0||c>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${c}.`);s===1?(u[0]=c*o,u[1]=c*o,u[2]=c*o):u[h]=c*o}let d=p*4;l[d+0]=Math.round(u[0]),l[d+1]=Math.round(u[1]),l[d+2]=Math.round(u[2]),l[d+3]=Math.round(u[3])}if(t!=null){qv||sp(Qh,O.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),qv=!0),t.width=a,t.height=r;let p=t.getContext("2d"),u=new ImageData(l,a,r);p.putImageData(u,0,0)}return n!==e&&n.dispose(),l}function _L(e,t,n){let r=C(e,"img","draw");if(!(e instanceof Fe)){let i=r;r=se(i,"int32"),i.dispose()}Mk(r),TL(n==null?void 0:n.imageOptions);let a={image:r},s={canvas:t,options:n};O.runKernel(Qh,a,s)}var EL=L({fromPixels_:Dk}),_y={};Ee(_y,{prepareAndValidate:()=>Ok});function Ok(e,t){let n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(tt(e.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);let a=t.shape,s=a[a.length-1],i=1;for(let d=0;d<a.length-1;++d)i*=a[d];let o=e.shape,l=a.slice();l.pop();let p=1;for(let d=s;d<n;++d)p*=o[d],l.push(o[d]);let u=[...ul(e.shape).map(d=>d/p),1].slice(0,s);return[l,i,p,u]}var Lt={};Ee(Lt,{assertParamsValid:()=>AL,computeFlatOffset:()=>OL,computeOutShape:()=>RL,getNormalizedAxes:()=>DL,isSliceContinous:()=>ML,maskToAxes:()=>FL,parseSliceParams:()=>Hk,sliceInfo:()=>LL,startForAxis:()=>Uk,startIndicesWithElidedDims:()=>Bk,stopForAxis:()=>Gk,stopIndicesWithElidedDims:()=>Wk,stridesForAxis:()=>Vk,stridesWithElidedDims:()=>Lk});var hm=-2,$L=-1;function AL(e,t,n){let r=e.shape.length;$(r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),$(r===n.length,()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);for(let a=0;a<r;++a)$(t[a]+n[a]<=e.shape[a],()=>`Error in slice${r}D: begin[${a}] + size[${a}] (${t[a]+n[a]}) would overflow input.shape[${a}] (${e.shape[a]})`)}function FL(e){let t=[],n=0;for(;e>0;)e&1&&t.push(n),e/=2,n++;return t}function RL(e,t,n){let r=[];for(let a=0;a<e.length;a++)r[a]=Math.ceil((t[a]-e[a])/n[a]);return r}function Lk(e,t,n,r){let a=[...e];for(let s=a.length;s<r.length;s++)a.push(1);for(let s=0;s<n;s++)s===0?a[t]=1:(a.splice(t,0,1),a.pop());return a}function zk(e,t,n){return n<=e?n:n-(t-1)}function Pk(e,t){let n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function DL(e,t,n,r,a,s,i,o,l){let p=e.length,u=new Array(p),d=new Array(p),h=new Array(p);if(t.length&&n>0){let c=t[0],f=n+1;u=Bk(i,c,f,r,e),d=Wk(o,c,f,a,e),h=Lk(s,c,f,e)}else for(let c=0;c<p;c++)u[c]=Uk(i,r,s,e,c,l),d[c]=Gk(o,a,s,e,c,l),h[c]=Vk(s,c,l);return{begin:u,end:d,strides:h}}function Bk(e,t,n,r,a){let s=[...a],i=Pk(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=0;else{let l=zk(t,n,o),p=r[l];e&1<<l&&(p=0),s[o]=p}return s}function Wk(e,t,n,r,a){let s=[...a],i=Pk(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=Number.MAX_SAFE_INTEGER;else{let l=zk(t,n,o),p=r[l];e&1<<l&&(p=Number.MAX_SAFE_INTEGER),s[o]=p}for(let o=0;o<s.length;o++){let l=a[o];s[o]<0&&(s[o]+=l),s[o]=rp(0,s[o],a[o])}return s}function Vk(e,t,n){let r=e[t];return(n&1<<t||r==null)&&(r=1),r}function Uk(e,t,n,r,a,s){let i=t[a],o=n[a]||1;(e&1<<a||s&1<<a||i==null)&&(o>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);let l=r[a];return i<0&&(i+=l),i=rp(0,i,l-1),i}function Gk(e,t,n,r,a,s){let i=t[a],o=n[a]||1;(e&1<<a||s&1<<a||i==null)&&(o>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);let l=r[a];return i<0&&(i+=l),o>0?i=rp(0,i,l):i=rp(-1,i,l-1),i}function ML(e,t,n){let r=n.length;for(let a=0;a<n.length;a++)if(n[a]>1){r=a;break}for(let a=r+1;a<n.length;a++)if(t[a]>0||n[a]!==e[a])return!1;return!0}function OL(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function Hk(e,t,n){let r,a=e.shape.length;typeof t=="number"?r=[t,...new Array(a-1).fill(0)]:t.length<a?r=t.concat(new Array(a-t.length).fill(0)):r=t.slice(),r.forEach(i=>{$(i!==-1,()=>"slice() does not support negative begin indexing.")});let s;return n==null?s=new Array(a).fill(-1):typeof n=="number"?s=[n,...new Array(a-1).fill(-1)]:n.length<a?s=n.concat(new Array(a-n.length).fill(-1)):s=n,s=s.map((i,o)=>i>=0?i:($(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${o}.`),e.shape[o]-r[o])),[r,s]}function LL(e,t,n,r,a,s,i,o,l){let p;if(r==null?(p=new Array(t.length),p.fill(1)):p=r,i!=null&&i&i-1)throw new Error("Multiple ellipses in slice is not allowed.");let u=!1,d={dims:p.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:p.slice(),beginMask:a,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};for(let b=0;b<d.dims;b++)u&&1<<b&o&&d.numAddAxisAfterEllipsis++,1<<b&i&&(u=!0);u||(d.ellipsisMask|=1<<d.dims,d.dims++);let h={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};zL(d,h);let c=!0,f=!0,m=!0,g=[],y=[];for(let b=0;b<e.length;++b){if(h.strides[b]===0)throw Error(`strides[${b}] must be non-zero`);let x=!!(h.shrinkAxisMask&1<<b),v=e[b];if(v===-1){g.push(x?1:-1);continue}let I=[h.beginMask&1<<b,h.endMask&1<<b],T=[h.strides[b]>0?0:-1,h.strides[b]>0?v:v-1];if(x&&h.strides[b]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&h.strides[b]===1;let _=!!(h.beginMask&1<<b&&h.endMask&1<<b);if(h.beginValid&&h.endValid){if(x){let F=h.begin[b]<0?v+h.begin[b]:h.begin[b];if(h.begin[b]=F,h.end[b]=h.begin[b]+1,F<0||F>=v)throw Error(`slice index ${h.begin[b]} of dimension ${b} out of bounds.`)}else h.begin[b]=Kv(h.begin[b],0,h.strides[b],v,I,T),h.end[b]=Kv(h.end[b],1,h.strides[b],v,I,T);let R=h.strides[b]===1&&h.begin[b]===0&&h.end[b]===v;c=c&&R,f=f&&(b===0&&h.strides[b]===1||R)}else c=c&&h.strides[b]===1&&_,f=f&&(b===0&&h.strides[b]===1||_);let E,A=!1;if(h.beginValid&&h.endValid?(E=h.end[b]-h.begin[b],A=!0):x?(E=1,A=!0):_&&v>=0&&(h.strides[b]<0?E=-v:E=v,A=!0),A){let R;E===0||E<0!=h.strides[b]<0?R=0:R=Math.trunc(E/h.strides[b])+(E%h.strides[b]!==0?1:0),g.push(R)}else g.push(-1)}for(let b=0;b<h.finalShapeGatherIndices.length;++b){let x=h.finalShapeGatherIndices[b];x>=0?y.push(g[x]):x===hm&&y.push(1)}return{finalShapeSparse:y.filter((b,x)=>h.finalShapeGatherIndices[x]!==hm),finalShape:y,isIdentity:c,sliceDim0:f,isSimpleSlice:m,begin:h.begin,end:h.end,strides:h.strides}}function zL(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=e.begin!=null,t.endValid=e.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){let a=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<a;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(hm),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);e.begin!=null&&(t.begin[n]=e.begin[r]),e.end!=null&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push($L),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}function Kv(e,t,n,r,a,s){if(a[t])return n>0?s[t]:s[t+1&1];{let i=e<0?r+e:e;return i<s[0]?s[0]:i>s[1]?s[1]:i}}var PL="4.22.0",jk=class{static sgd(e){return new Uc(e)}static momentum(e,t,n=!1){return new Sy(e,t,n)}static rmsprop(e,t=.9,n=0,r=null,a=!1){return new Ny(e,t,n,r,a)}static adam(e=.001,t=.9,n=.999,r=null){return new ky(e,t,n,r)}static adadelta(e=.001,t=.95,n=null){return new vy(e,t,n)}static adamax(e=.002,t=.9,n=.999,r=null,a=0){return new Iy(e,t,n,r,a)}static adagrad(e,t=.1){return new wy(e,t)}},xs=jk,BL=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:e=>e();function Ey(){return new Promise(e=>BL(()=>e()))}var N={};Ee(N,{ERF_A1:()=>tz,ERF_A2:()=>nz,ERF_A3:()=>rz,ERF_A4:()=>az,ERF_A5:()=>sz,ERF_P:()=>ez,PARALLELIZE_THRESHOLD:()=>$y,RowPartitionType:()=>Mr,SELU_SCALE:()=>Kk,SELU_SCALEALPHA:()=>qk,applyActivation:()=>Wc,assertAndGetBroadcastShape:()=>ot,assertAxesAreInnerMostDims:()=>LR,assertParamsConsistent:()=>WL,assignToTypedArray:()=>dz,axesAreInnerMostDims:()=>Wg,calculateShapes:()=>tk,checkEinsumDimSizes:()=>yz,checkPadOnDimRoundingMode:()=>bn,combineLocations:()=>k1,combineRaggedTensorToTensorShapes:()=>UL,complexWithEvenIndex:()=>lz,complexWithOddIndex:()=>uz,computeConv2DInfo:()=>Xp,computeConv3DInfo:()=>c1,computeDefaultPad:()=>Ig,computeDilation2DInfo:()=>MF,computeOptimalWindowSize:()=>qL,computeOutAndReduceShapes:()=>I1,computeOutShape:()=>VL,computePool2DInfo:()=>h1,computePool3DInfo:()=>OF,convertConv2DDataFormat:()=>f1,decodeEinsumEquation:()=>mz,eitherStridesOrDilationsAreOne:()=>qr,expandShapeToKeepDim:()=>Ws,exponent:()=>cz,exponents:()=>hz,fromStringArrayToUint8:()=>zz,fromUint8ToStringArray:()=>Lz,getAxesPermutation:()=>S1,getBroadcastDims:()=>v1,getComplexWithIndex:()=>pz,getEinsumComputePath:()=>bz,getEinsumPermutation:()=>gz,getFusedBiasGradient:()=>Bc,getFusedDyActivation:()=>Pc,getImageCenter:()=>KL,getInnerMostAxes:()=>zR,getPermuted:()=>ZL,getRaggedRank:()=>HL,getReductionAxes:()=>Ft,getReshaped:()=>XL,getReshapedPermuted:()=>JL,getRowPartitionTypesHelper:()=>GL,getSliceBeginCoords:()=>YL,getSliceSize:()=>QL,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>kz,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>Iz,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>Sz,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>Cz,getSparseReshapeInputOutputMismatchErrorMessage:()=>Ez,getSparseReshapeInputOutputMultipleErrorMessage:()=>_z,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>Nz,getSparseReshapeNegativeOutputDimErrorMessage:()=>Tz,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>Rz,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>$z,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>Az,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>Fz,getUndoAxesPermutation:()=>Vg,isIdentityPermutation:()=>xz,log:()=>q$,mergeRealAndImagArrays:()=>iz,prepareAndValidate:()=>Ok,prepareSplitSize:()=>wz,segment_util:()=>Xk,shouldFuse:()=>Vc,slice_util:()=>Lt,splitRealAndImagArrays:()=>oz,stridesOrDilationsArePositive:()=>Bs,tupleValuesAreOne:()=>Ba,upcastType:()=>tr,validateDefaultValueShape:()=>jL,validateInput:()=>Mc,validateUpdateShape:()=>py,warn:()=>_a});function WL(e,t){let n=e[0].length;e.forEach((a,s)=>{$(a.length===n,()=>`Error in concat${n}D: rank of tensors[${s}] must be the same as the rank of the rest (${n})`)}),$(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);let r=e[0];e.forEach((a,s)=>{for(let i=0;i<n;i++)$(i===t||a[i]===r[i],()=>`Error in concat${n}D: Shape of tensors[${s}] (${a}) does not match the shape of the rest (${r}) along the non-concatenated axis ${s}.`)})}function VL(e,t){let n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}var Mr;(function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"})(Mr||(Mr={}));function UL(e,t,n){let r=new Array;if(n==null&&t==null)return r;if(t==null)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(n==null)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let a=1;a<n.length;++a){let s=n[a],i=r[r.length-n.length+a],o=r[i];if(s>=0)if(o>=0){if(o!==s)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${a+e}] = ${s} but shape[${a+e}] = ${o}`)}else r[i]=s}return r}function GL(e){let t={FIRST_DIM_SIZE:Mr.FIRST_DIM_SIZE,VALUE_ROWIDS:Mr.VALUE_ROWIDS,ROW_LENGTHS:Mr.ROW_LENGTHS,ROW_SPLITS:Mr.ROW_SPLITS,ROW_LIMITS:Mr.ROW_LIMITS,ROW_STARTS:Mr.ROW_STARTS},n=[];for(let r of e)if(r in t)n.push(t[r]);else break;return n}function HL(e){return e.length===0?0:e[0]===Mr.FIRST_DIM_SIZE?e.length-1:e.length}function jL(e,t){if(e==null||t==null)return;let n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let a=0;a<Math.min(n,r-1);++a){let s=e[a],i=t[a+1];if(s>=0&&i>=0&&s!==1&&s!==i)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${a-e.length}] = ${s} but ragged tensor input.flatValues.shape[${a-e.length}] = ${i}`)}}var $y=30;function qL(e){return e<=$y?e:mh(e,Math.floor(Math.sqrt(e)))}function KL(e,t,n){let r=n*(typeof e=="number"?e:e[0]),a=t*(typeof e=="number"?e:e[1]);return[r,a]}function XL(e,t,n,r=!0){let a=[];if(r)a=a.concat(t.slice(0)),a.push(e[0]/n),a=a.concat(e.slice(1));else{a=a.concat(e[0]);let s=t.length;for(let i=0;i<s;++i)a=a.concat([e[i+1]/t[i],t[i]]);a=a.concat(e.slice(s+1))}return a}function ZL(e,t,n=!0){let r=[];if(n){r.push(t);for(let a=t+1;a<e;++a)a<=2*t?(r.push(a),r.push(a-(t+1))):r.push(a)}else{let a=[],s=[];for(let i=1;i<e;++i)i>=t*2+1||i%2===1?s.push(i):a.push(i);r.push(...a),r.push(0),r.push(...s)}return r}function JL(e,t,n,r=!0){let a=[];r?a.push(e[0]/n):a.push(e[0]*n);for(let s=1;s<e.length;++s)s<=t.length?r?a.push(t[s-1]*e[s]):a.push(e[s]/t[s-1]):a.push(e[s]);return a}function YL(e,t){let n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function QL(e,t,n){let r=e.slice(0,1);for(let a=0;a<n;++a)r.push(e[a+1]-t[a][0]-t[a][1]);return r}var qk=1.7580993408473768,Kk=1.0507009873554805,ez=.3275911,tz=.254829592,nz=-.284496736,rz=1.421413741,az=-1.453152027,sz=1.061405429;function iz(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);let n=new Float32Array(e.length*2);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function oz(e){let t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function lz(e){let t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=0;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function uz(e){let t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=2;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function pz(e,t){let n=e[t*2],r=e[t*2+1];return{real:n,imag:r}}function dz(e,t,n,r){e[r*2]=t,e[r*2+1]=n}function hz(e,t){let n=new Float32Array(e/2),r=new Float32Array(e/2);for(let a=0;a<Math.ceil(e/2);a++){let s=(t?2:-2)*Math.PI*(a/e);n[a]=Math.cos(s),r[a]=Math.sin(s)}return{real:n,imag:r}}function cz(e,t,n){let r=(n?2:-2)*Math.PI*(e/t),a=Math.cos(r),s=Math.sin(r);return{real:a,imag:s}}var Rf="->",fz=/->/g,Xv=",",Zv="...";function mz(e,t){e=e.replace(/\s/g,"");let n=(e.length-e.replace(fz,"").length)/Rf.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${Rf}").`);let[r,a]=e.split(Rf);$(r.indexOf(Zv)===-1,()=>`The ellipsis notation ("${Zv}") is not supported yet.`);let s=r.split(Xv),i=s.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let o=[];for(let h=0;h<a.length;++h){let c=a[h];if(!s.some(f=>f.indexOf(c)!==-1))throw new Error(`Output subscripts contain the label ${c} not present in the input subscripts.`);o.indexOf(c)===-1&&o.push(c)}for(let h=0;h<r.length;++h){let c=r[h];o.indexOf(c)===-1&&c!==Xv&&o.push(c)}let l=new Array(s.length);for(let h=0;h<i;++h){if(new Set(s[h].split("")).size!==s[h].length)throw new Error(`Found duplicate axes in input component ${s[h]}. Support for duplicate axes in input is not implemented yet.`);l[h]=[];for(let c=0;c<s[h].length;++c)l[h].push(o.indexOf(s[h][c]))}let p=o.length,u=a.length,d=[];for(let h=u;h<p;++h)d.push(h);return{allDims:o,summedDims:d,idDims:l}}function gz(e,t){let n=new Array(e);n.fill(-1);for(let a=0;a<t.length;++a)n[t[a]]=a;let r=[];for(let a=0;a<e;++a)n[a]===-1&&r.push(a);return n=n.filter(a=>a!==-1),{permutationIndices:n,expandDims:r}}function yz(e,t,n){let r=new Array(e);for(let a=0;a<n.length;++a){let s=n[a].shape;for(let i=0;i<t[a].length;++i)r[t[a][i]]===void 0?r[t[a][i]]=s[i]:$(r[t[a][i]]===s[i],()=>`Expected dimension ${r[t[a][i]]} at axis ${i} of input shaped ${JSON.stringify(s)}, but got dimension ${s[i]}`)}}function bz(e,t){let n=e,r=[],a=0;e.length===0&&n.push(-1),a=e.length+1;for(let i=0;i<a;++i)r.push([]);let s=[];for(let i=0;i<n.length;++i){let o=n[i],l=vz(t,o);for(let p of l)s.indexOf(p)===-1&&(r[i].push(p),s.push(p))}return{path:n,steps:r}}function xz(e){return e.every((t,n)=>t===n)}function vz(e,t){let n=[];for(let r=0;r<e.length;++r)(e[r].length===0||e[r].indexOf(t)!==-1||t===-1)&&n.push(r);return n}function wz(e,t,n=0){let r=[];if(typeof t=="number")$(e.shape[n]%t===0,()=>"Number of splits must evenly divide the axis."),r=new Array(t).fill(e.shape[n]/t);else{let a=t.reduce((i,o)=>(o===-1&&(i+=1),i),0);$(a<=1,()=>"There should be only one negative value in split array.");let s=t.indexOf(-1);if(s!==-1){let i=t.reduce((o,l)=>l>0?o+l:o);t[s]=e.shape[n]-i}$(e.shape[n]===t.reduce((i,o)=>i+o),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}function kz(e){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${e}`}function Iz(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function Sz(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function Nz(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function Tz(e,t){return`size ${e} must be non-negative, not ${t}`}function Cz(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function _z(e,t){let n=tt(e),r=tt(t);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${e} outputShape= ${t}`}function Ez(e,t){let n=tt(e),r=tt(t);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${r}. inputShape=${e} outputShape=${t}`}function $z(){return"segment ids must be >= 0"}function Az(){return"segment ids are not increasing"}function Fz(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function Rz(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}var Xk={};Ee(Xk,{collectGatherOpShapeInfo:()=>Oz,computeOutShape:()=>Mz,segOpComputeOptimalWindowSize:()=>Dz});function Dz(e,t){let n=!1,r;for(e<=$y?(r=e,n=!0):r=mh(e,Math.floor(Math.sqrt(e)));!n;)r>t||r===e?n=!0:r=mh(e,r+1);return r}function Mz(e,t,n){let r=[],a=e.length;for(let s=0;s<a;s++)s!==t?r.push(e[s]):r.push(n);return r}function Oz(e,t,n,r){let a=t.shape.length,s=e.shape.length;if(r!==0&&(r<-a||r>a))throw new Error(`Expect batchDims in the range of [-${a}, ${a}], but got ${r}`);if(r<0&&(r+=a),r>s)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${s}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let d=0;d<r;++d)if(e.shape[d]!==t.shape[d])throw new Error(`x.shape[${d}]: ${e.shape[d]} should be equal to indices.shape[${d}]: ${t.shape[d]}.`);let i=e.shape[n],o=[],l=1,p=1,u=1;for(let d=0;d<r;++d)o.push(e.shape[d]),l*=e.shape[d];for(let d=r;d<n;d++)o.push(e.shape[d]),p*=e.shape[d];for(let d=r;d<a;d++)o.push(t.shape[d]);for(let d=n+1;d<s;d++)o.push(e.shape[d]),u*=e.shape[d];return{batchSize:l,sliceSize:u,outerSize:p,dimSize:i,outputShape:o}}function Lz(e){try{return e.map(t=>bh(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function zz(e){return e.map(t=>jp(t))}var Xr={};Ee(Xr,{nonMaxSuppressionV3Impl:()=>mk,nonMaxSuppressionV4Impl:()=>gk,nonMaxSuppressionV5Impl:()=>yk,whereImpl:()=>ak});tL();var Zk={kernelName:pl,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,wo(se(n,"float32"),-1))}}},Pz={kernelName:Qs,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=st(se(n,"float32")),a=Kt(de(we(1),r));return ct(fe(e,a))}}}},Bz={kernelName:ei,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=Kt(de(st(se(n,"float32")),1));return fe(e,r)}}}},Wz={kernelName:Ya,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=ot(n.shape,r.shape);return{a:()=>{let s=e,i=Ft(n.shape,a);return i.length>0&&(s=ge(s,i)),P(s,n.shape)},b:()=>{let s=e,i=Ft(r.shape,a);return i.length>0&&(s=ge(s,i)),P(s,r.shape)}}}},Vz={kernelName:ti,saveAllInputs:!0,gradFunc:(e,t)=>{let n={};return t.forEach((r,a)=>{n[a]=()=>e.clone()}),n}},Uz={kernelName:cl,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>He(n)}}},Gz={kernelName:fl,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>He(n)}}},Hz={kernelName:ni,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>fe(e,Kt(de(we(1),st(se(n,"float32")))))}}},jz={kernelName:ri,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=Kt(X(we(1),st(se(n,"float32"))));return fe(e,r)}}}},qz={kernelName:ii,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=ot(n.shape,r.shape);return{a:()=>{let s=X(st(n),st(r)),i=z(e,fe(r,s)),o=Ft(n.shape,a);return o.length>0&&(i=ge(i,o)),P(i,n.shape)},b:()=>{let s=X(st(n),st(r)),i=ct(z(e,fe(n,s))),o=Ft(r.shape,a);return o.length>0&&(i=ge(i,o)),P(i,r.shape)}}}},Kz={kernelName:ai,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>fe(e,X(st(se(n,"float32")),1))}}},Xz={kernelName:si,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>fe(e,de(we(1),st(se(n,"float32"))))}}};function Zz(e,t,n,r,a,s){let i=C(e,"dy","avgPool3dGrad"),o=C(t,"input","avgPool3dGrad"),l=i,p=o,u=!1;o.rank===4&&(u=!0,l=P(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),p=P(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),$(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),$(p.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${p.rank}.`),bn("avgPool3dGrad",a,s);let d={dy:l,input:p},h={filterSize:n,strides:r,pad:a,dimRoundingMode:s},c=O.runKernel(Sp,d,h);return u?P(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}var Jz=L({avgPool3dGrad_:Zz}),Yz={kernelName:ml,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:a,strides:s,pad:i,dimRoundingMode:o}=n;return{x:()=>Jz(e,r,a,s,i,o)}}};function Qz(e,t,n,r,a){let s=C(e,"dy","avgPoolGrad"),i=C(t,"input","avgPoolGrad");$(i.rank===s.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${s.rank})`);let o=i,l=s,p=!1;i.rank===3&&(p=!0,o=P(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=P(s,[1,s.shape[0],s.shape[1],s.shape[2]])),$(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),$(o.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);let u={dy:l,input:o},d={filterSize:n,strides:r,pad:a},h=O.runKernel(Ip,u,d);return p?P(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var eP=L({avgPoolGrad_:Qz}),tP={kernelName:oi,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:a,strides:s,pad:i}=n;return{x:()=>eP(e,r,a,s,i)}}},nP={kernelName:li,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{let[r,a]=t,{transposeA:s,transposeB:i}=n;return!s&&!i?{a:()=>Oe(e,a,!1,!0),b:()=>Oe(r,e,!0,!1)}:!s&&i?{a:()=>Oe(e,a,!1,!1),b:()=>Oe(e,r,!0,!1)}:s&&!i?{a:()=>Oe(a,e,!1,!0),b:()=>Oe(r,e,!1,!1)}:{a:()=>Oe(a,e,!0,!0),b:()=>Oe(e,r,!0,!0)}}},rP={kernelName:gl,gradFunc:(e,t,n)=>{let{blockShape:r,crops:a}=n;return{x:()=>ad(e,r,a)}}},aP={kernelName:M0,gradFunc:(e,t,n)=>{let r=n,a=r.inputShape,s=r.shape,i=Array.from(s);for(let l=a.length-1;l>=0;l--)if(a[l]===s[l])i[l]=1;else if(a[l]!==1)throw new Error(`broadcastTo(): [${a}] cannot be broadcast to [${s}].`);let o=[];for(let l=0;l<i.length;l++)i[l]>1&&o.push(l);return{x:()=>ge(e,o,!0)}}},sP={kernelName:ui,gradFunc:e=>({x:()=>e.clone()})},iP={kernelName:pi,gradFunc:e=>({x:()=>He(e)})},oP={kernelName:Qa,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{clipValueMin:a,clipValueMax:s}=n;return{x:()=>qt(dr(ca(r,a),rs(r,s)),e,He(e))}}},lP={kernelName:Tp,inputsToSave:["x"],gradFunc:Zk.gradFunc},uP={kernelName:xl,saveAllInputs:!0,gradFunc:(e,t,n)=>{let r=t.map(o=>o.shape),{axis:a}=n,s=hr(a,t[0].shape)[0],i=r.map(o=>o[s]);return Tn(e,i,s).map(o=>()=>o)}},pP={kernelName:di,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,{dilations:s,strides:i,pad:o,dataFormat:l}=n;return $(Ba(s),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`),{x:()=>Dg(r.shape,e,a,i,o,l),filter:()=>yy(r,e,a.shape,i,o,l)}}},dP={kernelName:hi,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,{strides:s,pad:i,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>fn(e,a,s,i,o,1,l),filter:()=>yy(e,r,a.shape,s,i,o,l)}}};function hP(e,t,n,r,a){let s=e;e.rank===4&&(s=P(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;i.rank===4&&(i=P(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),$(s.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`),$(i.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),$(n.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),$(s.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${n[3]}.`),$(i.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`);let o={x:s,dy:i},l={strides:r,pad:a,filterShape:n};return O.runKernel(vl,o,l)}var cP=L({conv3DBackpropFilter_:hP}),fP={kernelName:ci,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:a,pad:s}=n;$(Ba(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);let[i,o]=t;return{x:()=>b1(i.shape,e,o,a,s),filter:()=>cP(i,e,o.shape,a,s)}}},mP={kernelName:fi,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(ct(_c(se(n,"float32"))),e)}}},gP={kernelName:mi,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(Ec(se(n,"float32")),e)}}},yP={kernelName:gi,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a,exclusive:s,reverse:i}=n;return{x:()=>{let o=S1([a],r.rank),l=gc(e,a,s,!i);return o!=null&&(l=Le(l,o)),l}}}},bP={kernelName:yi,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:a,pad:s,dimRoundingMode:i}=n,o=r??[1,1];$(Ba(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);let[l,p]=t;return $(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),$(p.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${p.rank}.`),$(l.shape[3]===p.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`),$(qr(a,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${a} and dilations '${o}'.`),bn("depthwiseConv2d",s,i),{x:()=>hk(l.shape,e,p,a,s,o,i),filter:()=>dk(l,e,p.shape,a,s,o,i)}}},xP={kernelName:bi,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,s={x:r,filter:a,dy:e},i={x:r,filter:a,dy:e};return{x:()=>O.runKernel(jo,s,n),filter:()=>O.runKernel(qo,i,n)}}},vP={kernelName:vi,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t,r={dy:e,y:n};return{x:()=>O.runKernel(Nl,r)}}},wP={kernelName:wi,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=z(sn(ct(st(n))),2/Math.sqrt(Math.PI));return{x:()=>z(e,r)}}},kP={kernelName:ki,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,n)}}},IP={kernelName:Cl,inputsToSave:["input"],gradFunc:(e,t)=>{let[n]=t;return{input:()=>P(e,n.shape)}}},SP={kernelName:Ii,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,sn(n))}}},NP={kernelName:Si,gradFunc:e=>({x:()=>He(e)})},TP={kernelName:Ni,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=ot(n.shape,r.shape);return{a:()=>{let s=fe(e,se(r,"float32")),i=Ft(n.shape,a);return i.length>0?P(ge(s,i),n.shape):s},b:()=>{let s=z(e,se(n,"float32")),i=Ft(r.shape,a);i.length>0&&(s=P(ge(s,i),r.shape));let o=st(r);return ct(fe(s,se(o,"float32")))}}}},CP={kernelName:Ti,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{let{varianceEpsilon:r}=n,[a,s,i,o]=t,l=o??we(1),p=Ft(s.shape,a.shape),u=[];if(s.rank===1){for(let m=0;m<a.shape.length-1;++m)u.push(a.shape[m]);u.push(1)}let d=de(a,s),h=z(e,l),c=Tc(X(i,we(r))),f=z(z(z(c,c),c),we(-.5));return{x:()=>s.rank===1?P(z(z(e,Pn(P(c,[1,1,1,s.shape[0]]),u)),l),a.shape):P(z(z(e,c),l),a.shape),mean:()=>{let m=z(z(c,we(-1)),h);return s.rank===1&&(m=ge(m,p)),P(m,s.shape)},variance:()=>{let m=z(z(f,d),h);return s.rank===1&&(m=ge(m,p)),P(m,s.shape)},scale:()=>{let m=z(d,c),g=z(e,m);return s.rank===1&&(g=ge(g,p)),P(g,s.shape)},offset:()=>{let m=e;return s.rank===1&&(m=ge(m,p)),P(m,s.shape)}}}},_P={kernelName:El,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{let[r,a]=t,{axis:s,batchDims:i}=n,o=hr(s,r.shape)[0],l=(p,u,d)=>()=>{let h=p.shape,c=u.size,f=h.slice(0,o),m=f.length,g=h.slice(s,h.length).slice(1),y=g.length,b=Jv(0,m),x=Jv(m+1,m+1+y),v=Yv([f,[c],g]),I=P(d,v),T=P(u,[c]),_=Yv([[m],b,x]),E=Le(I,_),A=Lc(E,T,p.shape[o]),R=Vg(_);return A=Le(A,R),A};if(i===1){let p=r.shape[0],u=r.split(p,0);return{x:()=>At(u.map((d,h)=>l(d,a.slice(h,1),e.slice(h,1))())).reshape(r.shape),indices:()=>a}}else return{x:l(r,a,e),indices:()=>a}}};function Jv(e,t){let n=[];for(let r=e;r<t;++r)n.push(r);return n}function Yv(e){let t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}var EP={kernelName:Ci,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>He(n),b:()=>He(r)}}},$P={kernelName:_i,gradFunc:e=>({x:()=>se(e,"float32")})},AP={kernelName:Ei,gradFunc:e=>({x:()=>He(e)})},FP={kernelName:$i,gradFunc:e=>({x:()=>He(e)})},RP={kernelName:Ai,gradFunc:e=>({x:()=>He(e)})},DP={kernelName:Fi,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{alpha:a}=n,s=xn(r,0);return{x:()=>qt(s,e,z(e,a))}}},MP={kernelName:Di,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>fe(e,X(n,1))}}},OP={kernelName:Ri,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>fe(e,se(n,"float32"))}}},LP={kernelName:L0,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n;return{logits:()=>{let s=sn(r);return de(e,z(ge(e,a,!0),s))}}}};function zP(e,t,n,r=5,a=1,s=1,i=.5){let o={x:e,y:t,dy:n},l={depthRadius:r,bias:a,alpha:s,beta:i};return O.runKernel(zl,o,l)}var PP=L({localResponseNormalizationBackprop_:zP}),BP={kernelName:Mi,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{depthRadius:s,bias:i,alpha:o,beta:l}=n;return{x:()=>PP(r,a,e,s,i,o,l)}}};function Jk(e,t,n,r){return t.rank<n.rank&&(t=P(t,Ws(t.shape,r))),e.rank<n.rank&&(e=P(e,Ws(e.shape,r))),{x:()=>z(e,se(Wn(n,t),e.dtype))}}var Qv={kernelName:Oi,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{reductionIndices:a}=r,s=t[0],i=t[1],o=hr(a,s.shape),l=Jk(e,i,s,o);return{x:()=>l.x()}}},WP={kernelName:Li,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>z(e,se(ca(n,r),"float32")),b:()=>z(e,se(Zo(n,r),"float32"))}}};function VP(e,t,n,r,a,s,i){let o=C(e,"dy","maxPool3dGrad"),l=C(t,"input","maxPool3dGrad"),p=C(n,"output","maxPool3dGrad"),u=o,d=l,h=p,c=!1;l.rank===4&&(c=!0,u=P(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),d=P(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),h=P(p,[1,p.shape[0],p.shape[1],p.shape[2],p.shape[3]])),$(u.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),$(d.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),$(h.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${h.rank}.`),bn("maxPool3dGrad",s,i);let f={dy:u,input:d,output:h},m={filterSize:r,strides:a,pad:s,dimRoundingMode:i},g=O.runKernel(Ap,f,m);return c?P(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}var UP=L({maxPool3dGrad_:VP}),GP={kernelName:Pl,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=n;return{x:()=>UP(e,r,a,s,i,o,l)}}};function HP(e,t,n,r,a,s,i){let o=C(e,"dy","maxPoolGrad"),l=C(t,"input","maxPoolGrad"),p=C(n,"output","maxPoolGrad");$(l.rank===o.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`),$(o.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),$(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),bn("maxPoolGrad",s,i);let u={dy:o,input:l,output:p},d={filterSize:r,strides:a,pad:s,dimRoundingMode:i};return O.runKernel($p,u,d)}var jP=L({maxPoolGrad_:HP}),qP={kernelName:zi,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{filterSize:s,strides:i,pad:o}=n;return{x:()=>jP(e,r,a,s,i,o)}}},KP={kernelName:Pi,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n,s=hr(a,r.shape),i=I1(r.shape,s)[1],o=tt(i);return{x:()=>{let l=r.shape.slice();s.forEach(u=>{l[u]=1});let p=P(e,l);return fe(z(p,Nn(r.shape,"float32")),o)}}}},XP={kernelName:Bi,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{axis:a}=r,[s,i]=t,o=hr(a,s.shape),l=Jk(e,i,s,o);return{x:()=>l.x()}}},ZP={kernelName:Wi,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>z(e,se(rs(n,r),"float32")),b:()=>z(e,se(xn(n,r),"float32"))}}},JP={kernelName:Vi,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:a}=n,s=a.map(i=>i[0]);return{x:()=>Ue(e,s,r.shape)}}},YP={kernelName:Ui,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=ot(n.shape,r.shape);return{a:()=>{let s=Ft(n.shape,a);return s.length>0?P(ge(e,s),n.shape):e},b:()=>{let s=z(e,ct(mu(fe(n,r)))),i=Ft(r.shape,a);return i.length>0?P(ge(s,i),r.shape):s}}}},QP={kernelName:Gi,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=ot(n.shape,r.shape);return{a:()=>{let s=z(e,se(r,"float32")),i=Ft(n.shape,a);return i.length>0?P(ge(s,i),n.shape):s},b:()=>{let s=z(e,se(n,"float32")),i=Ft(r.shape,a);return i.length>0?P(ge(s,i),r.shape):s}}}},eB={kernelName:Wl,gradFunc:e=>({x:()=>ct(e)})},tB={kernelName:Hi,inputsToSave:["indices"],gradFunc:(e,t)=>{let n=t[0];return{indices:()=>vt(n.shape,"float32")}}},nB={kernelName:jl,gradFunc:e=>({x:()=>He(e)})},rB={kernelName:ql,saveAllInputs:!0,gradFunc:(e,t,n)=>{let{axis:r}=n;return St(e,r).map(a=>()=>a)}},ew={kernelName:ji,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:a}=n,s=a.map(i=>i[0]);return{x:()=>Ue(e,s,r.shape)}}},aB={kernelName:qi,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{let[n,r,a]=t,s=n,i=r,o=ot(s.shape,i.shape);return{a:()=>{let l=se(i,"float32"),p=z(e,z(l,Gr(s,de(l,we(1))))),u=Ft(s.shape,o);return u.length>0&&(p=ge(p,u)),P(p,s.shape)},b:()=>{let l=xn(s,0),p=qt(l,Vn(s),He(s)),u=z(e,z(a,p)),d=Ft(i.shape,o);return d.length>0&&(u=ge(u,d)),P(u,i.shape)}}}},sB={kernelName:Ki,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{let[n,r]=t,a=xn(n,0);return{x:()=>qt(a,e,z(e,r)),alpha:()=>{let s=qt(a,He(e),z(e,n)),i=Ft(r.shape,e.shape);return i.length>0&&(s=ge(s,i)),P(s,r.shape)}}}};function iB(e,t,n){let r=e.shape.slice();r[n]=1;let a=P(t,r),s=dp(e,n,!0,!1),i=dp(e,n,!0,!0),o=z(s,i);return z(a,o)}function oB(e,t,n){let r=e.shape.length,a=r-n.length,s=N.getAxesPermutation(n,r),i=e;s!=null&&(i=Le(e,s));let o=i.shape.slice(),l=o.splice(r-n.length,n.length).reduce((d,h)=>d*h,1);o.push(l);let p=i.reshape(o),u=iB(p,t,a);if(u=u.reshape(i.shape),s!=null){let d=N.getUndoAxesPermutation(s);u=Le(u,d)}return u}var lB={kernelName:Xi,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n,s=[];return a==null?s=r.shape.map((i,o)=>o):typeof a=="number"?s=[a]:s=a,{x:()=>oB(r,e,s)}}},uB={kernelName:xi,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=ot(n.shape,r.shape);return{a:()=>{let s=fe(e,se(r,"float32")),i=Ft(n.shape,a);return i.length>0?P(ge(s,i),n.shape):s},b:()=>{let s=z(e,se(n,"float32")),i=Ft(r.shape,a);i.length>0&&(s=P(ge(s,i),r.shape));let o=st(r);return ct(fe(s,se(o,"float32")))}}}},pB={kernelName:Zi,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>fe(e,ct(st(n)))}}},dB={kernelName:eo,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=z(rs(n,6),wo(n));return{x:()=>z(e,se(r,"float32"))}}},hB={kernelName:Ji,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,se(wo(n),"float32"))}}},cB={kernelName:Kl,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>P(e,n.shape)}}},fB={kernelName:Qi,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,a={dy:e,images:r};return{images:()=>O.runKernel(Zl,a,n)}}},mB={kernelName:Yi,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,a={dy:e,images:r};return{images:()=>O.runKernel(Xl,a,n)}}},gB={kernelName:to,gradFunc:(e,t,n)=>{let{dims:r}=n,a=hr(r,e.shape);return{x:()=>rr(e,a)}}},yB={kernelName:no,gradFunc:e=>({x:()=>He(e)})},bB={kernelName:ro,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ct(fe(e,z(Gr(n,1.5),2)))}}},xB={kernelName:eu,inputsToSave:["condition"],gradFunc:(e,t)=>{let[n]=t;return{condition:()=>se(He(n),"float32"),t:()=>z(e,se(n,e.dtype)),e:()=>z(e,se(nd(n),e.dtype))}}},vB={kernelName:ao,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=xn(n,we(0)),a=we(qk),s=we(Kk),i=z(e,s),o=z(z(e,a),sn(se(n,"float32")));return qt(r,i,o)}}}},wB={kernelName:lo,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,z(n,de(we(1),n)))}}},kB={kernelName:oo,gradFunc:e=>({x:()=>He(e)})},IB={kernelName:so,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(Jp(se(n,"float32")),e)}}},SB={kernelName:io,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(mc(se(n,"float32")),e)}}},NB={kernelName:tu,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{begin:a,size:s}=n,i=r.shape,[o,l]=Hk(r,a,s),p=[];for(let u=0;u<e.rank;u++)p.push([o[u],i[u]-o[u]-l[u]]);return{x:()=>_r(e,p)}}},TB={kernelName:co,outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{dim:a}=n,s=!0,i=z(e,r);return{logits:()=>de(i,z(ge(i,[a],s),r))}}},CB={kernelName:uo,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,pr(n))}}},tw={kernelName:nu,gradFunc:(e,t,n)=>{let{blockShape:r,paddings:a}=n;return{x:()=>Zp(e,r,a)}}},nw={kernelName:ru,gradFunc:(e,t,n)=>{let{axis:r}=n;return{x:()=>it(e,r)}}},_B={kernelName:po,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>fe(e,z(Kt(se(n,"float32")),2))}}},EB={kernelName:Lp,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(e,z(se(n,"float32"),2))}}},$B={kernelName:fo,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=we(2);return{a:()=>z(e,z(a,de(n,r))),b:()=>z(e,z(a,de(r,n)))}}},AB={kernelName:ts,gradFunc:e=>({x:()=>He(e)})},FB={kernelName:mo,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=ot(n.shape,r.shape);return{a:()=>{let s=e,i=Ft(n.shape,a);return i.length>0&&(s=ge(s,i)),P(s,n.shape)},b:()=>{let s=e,i=Ft(r.shape,a);return i.length>0&&(s=ge(s,i)),P(ct(s),r.shape)}}}},RB={kernelName:ho,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,a=r.shape.slice(),{axis:s}=n;hr(s,r.shape).forEach(l=>{a[l]=1});let i=P(e,a),o=z(i,Nn(r.shape,"float32"));return{x:()=>o}}},DB={kernelName:go,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>fe(e,st(Jp(n)))}}},MB={kernelName:yo,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>z(de(we(1),st(n)),e)}}},OB={kernelName:es,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{reps:a}=n;return{x:()=>{let s=He(r);if(r.rank===1)for(let i=0;i<a[0];++i)s=X(s,Ue(e,[i*r.shape[0]],[r.shape[0]]));else if(r.rank===2)for(let i=0;i<a[0];++i)for(let o=0;o<a[1];++o)s=X(s,Ue(e,[i*r.shape[0],o*r.shape[1]],[r.shape[0],r.shape[1]]));else if(r.rank===3)for(let i=0;i<a[0];++i)for(let o=0;o<a[1];++o)for(let l=0;l<a[2];++l)s=X(s,Ue(e,[i*r.shape[0],o*r.shape[1],l*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else if(r.rank===4)for(let i=0;i<a[0];++i)for(let o=0;o<a[1];++o)for(let l=0;l<a[2];++l)for(let p=0;p<a[3];++p)s=X(s,Ue(e,[i*r.shape[0],o*r.shape[1],l*r.shape[2],p*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);return s}}}},LB={kernelName:sa,gradFunc:(e,t,n)=>{let r=n,{perm:a}=r,s=Vg(a);return{x:()=>Le(e,s)}}},zB={kernelName:uu,gradFunc:(e,t,n)=>{let r=n,{axis:a}=r;return{value:()=>At(e,a)}}},PB={kernelName:Up,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>BB(e,n)}}};function BB(e,t){let n=Kr(t,He(t)),r=gu(e,n),a=ca(t,we(0,"int32")),s=r.rank-a.rank;for(let o=0;o<s;++o)a=Ht(a,o+1);a=dr(a,Nn(r.shape,"bool"));let i=He(r);return qt(a,r,i)}var WB={kernelName:pu,gradFunc:e=>({x:()=>He(e)})},VB=[Zk,Pz,Bz,Wz,Vz,Uz,Gz,Hz,jz,qz,Kz,Xz,Yz,tP,nP,rP,aP,sP,iP,oP,lP,uP,dP,pP,fP,mP,gP,yP,bP,xP,uB,vP,wP,kP,IP,SP,TP,NP,CP,_P,EP,$P,AP,FP,RP,DP,MP,OP,LP,BP,Qv,Qv,WP,GP,qP,KP,XP,ZP,JP,YP,QP,eB,tB,nB,rB,ew,ew,aB,sB,lB,pB,dB,hB,cB,fB,mB,gB,yB,bB,xB,vB,wB,kB,IB,SB,NB,TB,CB,tw,tw,nw,nw,_B,$B,EB,AB,FB,RB,DB,MB,OB,LB,zB,PB,WB];for(let e of VB)z0(e);J().prototype.abs=function(){return this.throwIfDisposed(),_t(this)};J().prototype.acos=function(){return this.throwIfDisposed(),mg(this)};J().prototype.acosh=function(){return this.throwIfDisposed(),gg(this)};J().prototype.add=function(e){return this.throwIfDisposed(),X(this,e)};J().prototype.all=function(e,t){return this.throwIfDisposed(),hc(this,e,t)};J().prototype.any=function(e,t){return this.throwIfDisposed(),lp(this,e,t)};J().prototype.argMax=function(e){return this.throwIfDisposed(),Ps(this,e)};J().prototype.argMin=function(e){return this.throwIfDisposed(),yg(this,e)};J().prototype.asScalar=function(){return this.throwIfDisposed(),$(this.size===1,()=>"The array must have only 1 element."),P(this,[])};J().prototype.asType=function(e){return this.throwIfDisposed(),se(this,e)};J().prototype.as1D=function(){return this.throwIfDisposed(),P(this,[this.size])};J().prototype.as2D=function(e,t){return this.throwIfDisposed(),P(this,[e,t])};J().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),P(this,[e,t,n])};J().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),P(this,[e,t,n,r])};J().prototype.as5D=function(e,t,n,r,a){return this.throwIfDisposed(),P(this,[e,t,n,r,a])};J().prototype.asin=function(){return this.throwIfDisposed(),bg(this)};J().prototype.asinh=function(){return this.throwIfDisposed(),xg(this)};J().prototype.atan=function(){return this.throwIfDisposed(),vg(this)};J().prototype.atan2=function(e){return this.throwIfDisposed(),wg(this,e)};J().prototype.atanh=function(){return this.throwIfDisposed(),kg(this)};J().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),ha(this,e,t,n,r)};J().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),Zp(this,e,t)};J().prototype.batchNorm=function(e,t,n,r,a){return this.throwIfDisposed(),bo(this,e,t,n,r,a)};J().prototype.broadcastTo=function(e){return this.throwIfDisposed(),_s(this,e)};J().prototype.cast=function(e){return this.throwIfDisposed(),se(this,e)};J().prototype.ceil=function(){return this.throwIfDisposed(),Eg(this)};J().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),an(this,e,t)};J().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof Fe&&(e=[e]),it([this,...e],t)};J().prototype.conv1d=function(e,t,n,r,a,s){return this.throwIfDisposed(),cc(this,e,t,n,r,a,s)};J().prototype.conv2dTranspose=function(e,t,n,r,a){return this.throwIfDisposed(),fc(this,e,t,n,r,a)};J().prototype.conv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),fn(this,e,t,n,r,a,s)};J().prototype.cos=function(){return this.throwIfDisposed(),Jp(this)};J().prototype.cosh=function(){return this.throwIfDisposed(),mc(this)};J().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),dp(this,e,t,n)};J().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),gc(this,e,t,n)};J().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),Lg(this,e,t)};J().prototype.depthwiseConv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),xo(this,e,t,n,r,a,s)};J().prototype.dilation2d=function(e,t,n,r,a){return this.throwIfDisposed(),zg(this,e,t,n,r,a)};J().prototype.divNoNan=function(e){return this.throwIfDisposed(),Pg(this,e)};J().prototype.div=function(e){return this.throwIfDisposed(),fe(this,e)};J().prototype.dot=function(e){return this.throwIfDisposed(),Bg(this,e)};J().prototype.elu=function(){return this.throwIfDisposed(),cu(this)};J().prototype.equal=function(e){return this.throwIfDisposed(),Wn(this,e)};J().prototype.erf=function(){return this.throwIfDisposed(),yc(this)};J().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),Ug(this,e,t)};J().prototype.exp=function(){return this.throwIfDisposed(),sn(this)};J().prototype.expandDims=function(e){return this.throwIfDisposed(),Ht(this,e)};J().prototype.expm1=function(){return this.throwIfDisposed(),Gg(this)};J().prototype.fft=function(){return this.throwIfDisposed(),od(this)};J().prototype.flatten=function(){return this.throwIfDisposed(),P(this,[this.size])};J().prototype.floor=function(){return this.throwIfDisposed(),mu(this)};J().prototype.floorDiv=function(e){return this.throwIfDisposed(),dc(this,e)};J().prototype.gather=function(e,t,n){return this.throwIfDisposed(),gu(this,e,t,n)};J().prototype.greaterEqual=function(e){return this.throwIfDisposed(),ca(this,e)};J().prototype.greater=function(e){return this.throwIfDisposed(),xn(this,e)};J().prototype.ifft=function(){return this.throwIfDisposed(),el(this)};J().prototype.irfft=function(){return this.throwIfDisposed(),Ac(this)};J().prototype.isFinite=function(){return this.throwIfDisposed(),Hg(this)};J().prototype.isInf=function(){return this.throwIfDisposed(),jg(this)};J().prototype.isNaN=function(){return this.throwIfDisposed(),qg(this)};J().prototype.leakyRelu=function(e){return this.throwIfDisposed(),Qp(this,e)};J().prototype.lessEqual=function(e){return this.throwIfDisposed(),rs(this,e)};J().prototype.less=function(e){return this.throwIfDisposed(),Zo(this,e)};J().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),Kg(this,e,t,n,r)};J().prototype.logSigmoid=function(){return this.throwIfDisposed(),Xg(this)};J().prototype.logSoftmax=function(e){return this.throwIfDisposed(),vc(this,e)};J().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),td(this,e,t)};J().prototype.log=function(){return this.throwIfDisposed(),Vn(this)};J().prototype.log1p=function(){return this.throwIfDisposed(),ed(this)};J().prototype.logicalAnd=function(e){return this.throwIfDisposed(),dr(this,e)};J().prototype.logicalNot=function(){return this.throwIfDisposed(),nd(this)};J().prototype.logicalOr=function(e){return this.throwIfDisposed(),wc(this,e)};J().prototype.logicalXor=function(e){return this.throwIfDisposed(),Zg(this,e)};J().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),Oe(this,e,t,n)};J().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),Vt(this,e,t,n,r)};J().prototype.max=function(e,t){return this.throwIfDisposed(),er(this,e,t)};J().prototype.maximum=function(e){return this.throwIfDisposed(),Kr(this,e)};J().prototype.mean=function(e,t){return this.throwIfDisposed(),xt(this,e,t)};J().prototype.min=function(e,t){return this.throwIfDisposed(),Xo(this,e,t)};J().prototype.minimum=function(e){return this.throwIfDisposed(),Va(this,e)};J().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),Yg(this,e,t)};J().prototype.mod=function(e){return this.throwIfDisposed(),Qg(this,e)};J().prototype.mul=function(e){return this.throwIfDisposed(),z(this,e)};J().prototype.neg=function(){return this.throwIfDisposed(),ct(this)};J().prototype.norm=function(e,t,n){return this.throwIfDisposed(),fu(this,e,t,n)};J().prototype.notEqual=function(e){return this.throwIfDisposed(),Vs(this,e)};J().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),Jo(this,e,t,n)};J().prototype.onesLike=function(){return this.throwIfDisposed(),Un(this)};J().prototype.pad=function(e,t){return this.throwIfDisposed(),_r(this,e,t)};J().prototype.pool=function(e,t,n,r,a,s){return this.throwIfDisposed(),ey(this,e,t,n,r,a,s)};J().prototype.pow=function(e){return this.throwIfDisposed(),Gr(this,e)};J().prototype.prelu=function(e){return this.throwIfDisposed(),sd(this,e)};J().prototype.prod=function(e,t){return this.throwIfDisposed(),ty(this,e,t)};J().prototype.reciprocal=function(){return this.throwIfDisposed(),iy(this)};J().prototype.relu=function(){return this.throwIfDisposed(),et(this)};J().prototype.relu6=function(){return this.throwIfDisposed(),Sc(this)};J().prototype.reshapeAs=function(e){return this.throwIfDisposed(),P(this,e.shape)};J().prototype.reshape=function(e){return this.throwIfDisposed(),P(this,e)};J().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),bk(this,e,t,n)};J().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),xk(this,e,t,n)};J().prototype.reverse=function(e){return this.throwIfDisposed(),rr(this,e)};J().prototype.rfft=function(){return this.throwIfDisposed(),ld(this)};J().prototype.round=function(){return this.throwIfDisposed(),Nc(this)};J().prototype.rsqrt=function(){return this.throwIfDisposed(),Tc(this)};J().prototype.selu=function(){return this.throwIfDisposed(),Cc(this)};J().prototype.separableConv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),yu(this,e,t,n,r,a,s)};J().prototype.sigmoid=function(){return this.throwIfDisposed(),pr(this)};J().prototype.sign=function(){return this.throwIfDisposed(),oy(this)};J().prototype.sin=function(){return this.throwIfDisposed(),_c(this)};J().prototype.sinh=function(){return this.throwIfDisposed(),Ec(this)};J().prototype.slice=function(e,t){return this.throwIfDisposed(),Ue(this,e,t)};J().prototype.softmax=function(e){return this.throwIfDisposed(),ss(this,e)};J().prototype.softplus=function(){return this.throwIfDisposed(),vo(this)};J().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),ad(this,e,t)};J().prototype.split=function(e,t){return this.throwIfDisposed(),Tn(this,e,t)};J().prototype.sqrt=function(){return this.throwIfDisposed(),Kt(this)};J().prototype.square=function(){return this.throwIfDisposed(),st(this)};J().prototype.squaredDifference=function(e){return this.throwIfDisposed(),Fc(this,e)};J().prototype.squeeze=function(e){return this.throwIfDisposed(),is(this,e)};J().prototype.stack=function(e,t){this.throwIfDisposed();let n=e instanceof Fe?[this,e]:[this,...e];return At(n,t)};J().prototype.step=function(e){return this.throwIfDisposed(),wo(this,e)};J().prototype.stridedSlice=function(e,t,n,r,a,s,i,o){return this.throwIfDisposed(),ly(this,e,t,n,r,a,s,i,o)};J().prototype.sub=function(e){return this.throwIfDisposed(),de(this,e)};J().prototype.sum=function(e,t){return this.throwIfDisposed(),ge(this,e,t)};J().prototype.tan=function(){return this.throwIfDisposed(),uy(this)};J().prototype.tanh=function(){return this.throwIfDisposed(),Wa(this)};J().prototype.tile=function(e){return this.throwIfDisposed(),Pn(this,e)};J().prototype.toBool=function(){return this.throwIfDisposed(),se(this,"bool")};J().prototype.toFloat=function(){return this.throwIfDisposed(),se(this,"float32")};J().prototype.toInt=function(){return this.throwIfDisposed(),se(this,"int32")};J().prototype.topk=function(e,t){return this.throwIfDisposed(),dy(this,e,t)};J().prototype.transpose=function(e){return this.throwIfDisposed(),Le(this,e)};J().prototype.unique=function(e){return this.throwIfDisposed(),hy(this,e)};J().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),Lc(this,e,t)};J().prototype.unstack=function(e){return this.throwIfDisposed(),St(this,e)};J().prototype.where=function(e,t){return this.throwIfDisposed(),qt(e,this,t)};J().prototype.zerosLike=function(){return this.throwIfDisposed(),He(this)};var Ta=class Yk extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Yk.prototype)}},zr=class Qk extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Qk.prototype)}},V=class eI extends Error{constructor(t){super(t),Object.setPrototypeOf(this,eI.prototype)}},Be=class tI extends Error{constructor(t){super(t),Object.setPrototypeOf(this,tI.prototype)}},UB=class nI extends Error{constructor(t){super(t),Object.setPrototypeOf(this,nI.prototype)}},rI=class{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){let n=this.cache.keys().next().value;this.cache.delete(n)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){let n=this.cache.keys().next().value;this.cache.delete(n)}this.maxEntries=e}};function Gs(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}else{let n=new Array(t);return n.fill(e),n}}function Or(e,t){if(!e)throw new UB(t)}function rw(e,t){let n=0;for(let r of e)r===t&&n++;return n}function Sn(e){return e.length===1?e[0]:e}function Qe(e){return Array.isArray(e)?e:[e]}function ta(e){let t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function Is(e){return e.length<=1||e.indexOf("_")===-1?e:e.replace(/[_]+(\w|$)/g,(t,n)=>n.toUpperCase())}var ir={};function Ay(e){if(e==null)return null;let t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function cm(e){if(!(e==null||typeof e!="object"))if(Array.isArray(e))e.forEach(t=>cm(t));else{let t=Object.keys(e);for(let n of t){let r=e[n];r!=null&&typeof r=="object"&&(!Array.isArray(r)&&r.type==="ndarray"&&typeof r.value=="number"?e[n]=r.value:cm(r))}}}function pd(e,t={},n={},r="object",a=!1){if(typeof e=="string"){let s=e,i;if(s in n)i=n[s];else if(s in ir)i=ir[s];else if(i=t[s],i==null)throw new V(`Unknown ${r}: ${e}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}else{let s=e;if(s.className==null||s.config==null)throw new V(`${r}: Improper config format: ${JSON.stringify(s)}.
'className' and 'config' must set.`);let i=s.className,o,l;if(i in n?[o,l]=n[i]:i in ir?[o,l]=ir.className:i in t&&([o,l]=t[i]),o==null)throw new V(`Unknown ${r}: ${i}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){let p={};for(let c of Object.keys(ir))p[c]=ir[c];for(let c of Object.keys(n))p[c]=n[c];let u=s.config;u.customObjects=p;let d=Object.assign({},ir);for(let c of Object.keys(n))ir[c]=n[c];cm(s.config);let h=l(o,s.config,n,a);return ir=Object.assign({},d),h}else{let p=Object.assign({},ir);for(let d of Object.keys(n))ir[d]=n[d];let u=new o(s.config);return ir=Object.assign({},p),u}}}function GB(e,t){return e<t?-1:e>t?1:0}function Ud(e,t){return-1*GB(e,t)}function Da(e){if(e==null)return e;let t=[];for(let n of e)t.indexOf(n)===-1&&t.push(n);return t}function HB(e){if(e==null)throw new V(`Invalid value in obj: ${JSON.stringify(e)}`);for(let t in e)if(e.hasOwnProperty(t))return!1;return!0}function ko(e,t,n){if(n!=null&&e.indexOf(n)<0)throw new V(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function Fy(e,t,n=0,r=1/0){return Or(n>=0),Or(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every(a=>typeof a===t)}function jt(e,t){Array.isArray(e)?(w.assert(e.length>0,()=>`${t} is unexpectedly an empty array.`),e.forEach((n,r)=>jt(n,`element ${r+1} of ${t}`))):w.assert(Number.isInteger(e)&&e>0,()=>`Expected ${t} to be a positive integer, but got ${aI(e)}.`)}function aI(e){return e===null?"null":Array.isArray(e)?"["+e.map(t=>aI(t)).join(",")+"]":typeof e=="string"?`"${e}"`:`${e}`}function jB(e,t,n){let r=n!=null?n():w.now(),a;return(...s)=>{let i=n!=null?n():w.now();return i-r<t||(r=i,a=e(...s)),a}}function sI(e){return e==="relu"?"relu":e==="linear"?"linear":e==="elu"?"elu":null}var qB=0;function iI(){return qB++}var Gd={};function Gc(e=""){return e in Gd||(Gd[e]=0),Gd[e]+=1,e+Gd[e].toString()}var KB=["channelsFirst","channelsLast"],XB=["nearest","bilinear"],ZB=["valid","same","causal"],JB=["max","avg"],YB=["sum","mul","concat","ave"],Ro=new Map;function Nt(e){ko(KB,"DataFormat",e)}function QB(e){ko(XB,"InterpolationFormat",e)}function ar(e){ko(ZB,"PaddingMode",e)}function oI(e){ko(JB,"PoolMode",e)}var Qu=[],aw="/";function Es(e,t){Qu.push(e);try{let n=t();return Qu.pop(),n}catch(n){throw Qu.pop(),n}}function eW(){return Qu.length===0?"":Qu.join(aw)+aw}function lI(e){if(!pI(e))throw new Error("Not a valid tensor name: '"+e+"'");return eW()+e}function uI(e){if(!pI(e))throw new Error("Not a valid tensor name: '"+e+"'");Ro.has(e)||Ro.set(e,0);let t=Ro.get(e);if(Ro.set(e,Ro.get(e)+1),t>0){let n=`${e}_${t}`;return Ro.set(n,1),n}else return e}var tW=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function pI(e){return!!e.match(tW)}function nW(e){return e===parseInt(e.toString(),10)}function Ma(e,t,n){t==null&&(t=0),n==null&&(n=e.length);let r=1;for(let a=t;a<n;++a)r*=e[a];return r}function nl(e){if(e.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r<t&&(t=r)}return t}function Ga(e){if(e.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r>t&&(t=r)}return t}function Ir(e,t){if(t<e)throw new V(`end (${t}) < begin (${e}) is forbidden.`);let n=[];for(let r=e;r<t;++r)n.push(r);return n}var Df;function Ot(){return Df==null&&(Df=dg().epsilon()),Df}function Sr(){return"channelsLast"}function ua(e,t){return se(e,t)}function dd(e,t=-1){let n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),P(e,n)}function rW(e,t){return B(()=>{if(e.shape.length!==2)throw new V(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);let n=dd(e,1);return fm(n,[1,t,1])})}function aW(e){let t=[Ma(e.shape)];return P(e,t)}function sW(e){if(e.rank<=1)throw new V(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);let t=[e.shape[0],Ma(e.shape,1)];return P(e,t)}function $s(e,t,n){return B(()=>{switch(e.rank){case 1:return id(e,t,n);case 2:return $c(e,[t,0],[n,e.shape[1]]);case 3:return bu(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return Qo(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return Ue(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return Ue(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new V(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}})}function Mf(e,t,n){return B(()=>{switch(e.rank){case 1:return id(e,t,n);case 2:return $c(e,[0,t],[e.shape[0],n]);case 3:return bu(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return Qo(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new V(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function Hd(e,t,n,r){return B(()=>{switch(e.rank){case 1:return id(e,t,n);case 2:switch(r){case 1:return $s(e,t,n);case 2:return Mf(e,t,n);default:throw new V(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return $s(e,t,n);case 2:return bu(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return Mf(e,t,n);default:throw new V(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return $s(e,t,n);case 2:return Qo(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return Qo(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return Mf(e,t,n);default:throw new V(`The axis is not within the rank of the tensor ${r}`)}default:throw new V(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function Ry(e,t=-1){let n;return t<0&&(n=e[0].rank,n!==0?t=n:t=0),t===e[0].rank&&(t=-1),it(e,t)}function sw(e,t){switch(e.rank){case 1:return $g([e,t]);case 2:return Ag([e,t],0);case 3:return Fg([e,t],0);case 4:return Rg([e,t],0);default:throw new V(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function fm(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new V(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return Pn(e,t)}function Hc(e,t=0,n=1,r,a){return Ic(e,t,n,r,a)}function Vr(e,t,n,r){if(e.rank<2||t.rank<2)throw new Be(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){let a=e.shape.slice(-1)[0],s=t.shape.slice(-2)[0];if(a!==s)throw new Be(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(e.rank===2&&t.rank===2)return tl.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?mm(e.rank,r,Sr()):null,activation:n});{let a=e.shape.slice(),s=a.pop();e=P(e,[-1,s]);let i=t.shape.slice(),o=i.pop(),l=i.pop(),p=[...i,o],u=Array.from({length:t.rank},(h,c)=>c===0?t.rank-2:c<=t.rank-2?c-1:c);t=P(Le(t,u),[l,-1]);let d=[...a,...p];return P(tl.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?mm(e.rank,r,Sr()):null,activation:n}),d)}}function dI(e,t,n){return B(()=>(Array.isArray(t)?t=Ye(t,"int32"):t=se(t,"int32"),gu(e,t,n)))}function hd(e){return z(e,e)}function mm(e,t,n){let r=t.shape;if(t.rank!==1&&t.rank!==e)throw new V(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(e===5){if(n==="channelsFirst")return r.length===1?P(t,[1,r[0],1,1,1]):P(t,[1,r[3],r[0],r[1],r[2]]);if(n==="channelsLast")return r.length===1?P(t,[1,1,1,1,r[0]]):P(t,[1].concat(r))}else if(e===4){if(n==="channelsFirst")return r.length===1?P(t,[1,r[0],1,1]):P(t,[1,r[2],r[0],r[1]]);if(n==="channelsLast")return r.length===1?P(t,[1,1,1,r[0]]):P(t,[1].concat(r))}else if(e===3){if(n==="channelsFirst")return r.length===1?P(t,[1,r[0],1]):P(t,[1,r[1],r[0]]);if(n==="channelsLast")return r.length===1?P(t,[1,1,r[0]]):P(t,[1].concat(r))}else if(e<3)return t;throw new V(`Unsupported input rank by biasAdd: ${t.rank}`)}function Er(e,t,n){return B(()=>(n==null&&(n=Sr()),Nt(n),X(e,mm(e.rank,t,n))))}function iW(e,t=1){if(t!==1)throw new Be(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return cu(e)}function oW(e){return B(()=>fe(e,X(_t(e),1)))}function hI(e,t,n,r){return B(()=>my(e,t,n,r))}function lW(e){return B(()=>{let t=X(.5,z(.2,e));return an(t,0,1)})}function cd(e,t,n=!1){return n?e():t()}var uW=["fanIn","fanOut","fanAvg"],pW=["normal","uniform","truncatedNormal"];function dW(e){ko(uW,"FanMode",e)}function hW(e){ko(pW,"Distribution",e)}var cr=class extends ne.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},Dy=class extends cr{apply(e,t){return vt(e,t)}};Dy.className="Zeros";ne.registerClass(Dy);var jc=class extends cr{apply(e,t){return Nn(e,t)}};jc.className="Ones";ne.registerClass(jc);var My=class extends cr{constructor(e){if(super(),typeof e!="object")throw new V(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new V(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return B(()=>z(we(this.value),Nn(e,t)))}getConfig(){return{value:this.value}}};My.className="Constant";ne.registerClass(My);var Oy=class extends cr{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return as(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};Oy.className="RandomUniform";ne.registerClass(Oy);var Ly=class extends cr{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Be(`randomNormal does not support dType ${t}.`);return Hc(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};Ly.className="RandomNormal";ne.registerClass(Ly);var zy=class extends cr{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Be(`truncatedNormal does not support dType ${t}.`);return Oc(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};zy.className="TruncatedNormal";ne.registerClass(zy);var Py=class extends cr{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return B(()=>{if(e.length!==2||e[0]!==e[1])throw new V("Identity matrix initializer can only be used for 2D square matrices.");return z(this.gain,bc(e[0]))})}getConfig(){return{gain:this.gain}}};Py.className="Identity";ne.registerClass(Py);function cW(e,t="channelsLast"){let n,r;if(Nt(t),e.length===2)n=e[0],r=e[1];else if([3,4,5].indexOf(e.length)!==-1){if(t==="channelsFirst"){let a=Ma(e,2);n=e[1]*a,r=e[0]*a}else if(t==="channelsLast"){let a=Ma(e,0,e.length-2);n=e[e.length-2]*a,r=e[e.length-1]*a}}else{let a=Ma(e);n=Math.sqrt(a),r=Math.sqrt(a)}return[n,r]}var En=class extends cr{constructor(e){if(super(),e.scale<0)throw new V(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,dW(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,hW(this.distribution),this.seed=e.seed}apply(e,t){let n=cW(e),r=n[0],a=n[1],s=this.scale;if(this.mode==="fanIn"?s/=Math.max(1,r):this.mode==="fanOut"?s/=Math.max(1,a):s/=Math.max(1,(r+a)/2),this.distribution==="normal"){let i=Math.sqrt(s);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Be(`${this.getClassName()} does not support dType ${t}.`);return Oc(e,0,i,t,this.seed)}else{let i=Math.sqrt(3*s);return as(e,-i,i,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};En.className="VarianceScaling";ne.registerClass(En);var qc=class extends En{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return En.className}};qc.className="GlorotUniform";ne.registerClass(qc);var Kc=class extends En{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return En.className}};Kc.className="GlorotNormal";ne.registerClass(Kc);var Xc=class extends En{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return En.className}};Xc.className="HeNormal";ne.registerClass(Xc);var Zc=class extends En{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return En.className}};Zc.className="HeUniform";ne.registerClass(Zc);var Jc=class extends En{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return En.className}};Jc.className="LeCunNormal";ne.registerClass(Jc);var Yc=class extends En{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return En.className}};Yc.className="LeCunUniform";ne.registerClass(Yc);var By=class extends cr{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return B(()=>{if(e.length<2)throw new Be("Shape must be at least 2D.");if(t!=="int32"&&t!=="float32"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;let n=w.sizeFromShape(e.slice(0,-1)),r=e[e.length-1],a=n*r;a>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${a}) elements: Slowness may result.`);let s=[Math.max(r,n),Math.min(r,n)],i=Hc(s,0,1,t,this.seed),o=xy.qr(i,!1),l=o[0],p=o[1].flatten().stridedSlice([0],[Math.min(r,n)*Math.min(r,n)],[Math.min(r,n)+1]);return l=z(l,p.sign()),n<r&&(l=l.transpose()),z(we(this.gain),l.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}};By.className="Orthogonal";ne.registerClass(By);var iw={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function ow(e,t={}){return pd(e,ne.SerializationMap.getMap().classNameMap,t,"initializer")}function wt(e){return Ay(e)}function gt(e){if(typeof e=="string"){let t=e in iw?iw[e]:e;if(t==="GlorotNormal")return new Kc;if(t==="GlorotUniform")return new qc;if(t==="HeNormal")return new Xc;if(t==="HeUniform")return new Zc;if(t==="LeCunNormal")return new Jc;if(t==="LeCunUniform")return new Yc;{let n={};return n.className=t,n.config={},ow(n)}}else return e instanceof cr?e:ow(e)}function gm(e){return Array.isArray(e)&&Array.isArray(e[0])}function wh(e){return e.length===0?[]:Array.isArray(e[0])?e:[e]}function Ce(e){let t;if(Array.isArray(e)){if(e.length!==1)throw new V(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function Xe(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(e.length===1)return e=e,e[0];throw new V(`Expected exactly 1 Shape; got ${e.length}`)}else return e}function kh(e){let t=0;for(let n of e)n.shape.length===0?t+=1:t+=n.shape.reduce((r,a)=>r*a);return t}var lw="Variable",cI=class{constructor(e,t="float32",n=lw,r=!0,a=null){this.dtype=t??"float32",this.shape=e.shape,this.id=iI(),n=n??lw,this.originalName=lI(n),this.name=uI(this.originalName),this.trainable_=r,this.constraint=a,this.val=cy(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),fW(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}};function fW(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}function ym(e){return e.map(t=>t.read())}function Wy(e){e.forEach(t=>{t[0].write(t[1])})}var Et=class{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}},Nr=class{constructor(e,t,n,r,a,s,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=a,this.outputTensorIndex=i,this.id=iI(),s!=null&&(this.originalName=lI(s),this.name=uI(this.originalName)),this.rank=t.length}},mW=0,Qc=class{constructor(e,t){this.callArgs=t,this.id=mW++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(let n of e.inboundLayers)n!=null&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){let e=[];for(let t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},gW=0,We=class extends ne.Serializable{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=gW++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){let n=this.getClassName();t=ta(n)+"_"+Gc(n)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let n;if(e.batchInputShape!=null)n=e.batchInputShape;else if(e.inputShape!=null){let a=null;e.batchSize!=null&&(a=e.batchSize),n=[a].concat(e.inputShape)}this.batchInputShape=n;let r=e.dtype;r==null&&(r=e.inputDType),r==null&&(r="float32"),this.dtype=r}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new zr(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new V(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return Sn(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return Sn(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Ta(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Ta(`Layer ${this.name} is not connected, no input to return.`);return Sn(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Ta(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Ta(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Sn(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){let t=Qe(e);if(this.inputSpec==null||this.inputSpec.length===0)return;let n=Qe(this.inputSpec);if(t.length!==n.length)throw new V(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let r=0;r<t.length;r++){let a=t[r],s=n[r];if(s==null)continue;let i=a.rank;if(s.ndim!=null&&i!==s.ndim)throw new V(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${i}`);if(s.maxNDim!=null&&i>s.maxNDim)throw new V(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${i}`);if(s.minNDim!=null&&i<s.minNDim)throw new V(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${i}.`);if(s.dtype!=null&&a.dtype!==s.dtype)throw new V(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${a.dtype}.`);if(s.axes){let o=a.shape;for(let l in s.axes){let p=Number(l),u=s.axes[l],d=p>=0?o[p]:o[o.length+p];if(u!=null&&[u,null].indexOf(d)===-1)throw new V(`Input ${r} is incompatible with layer ${this.name}: expected axis ${p} of input shape to have value ${u} but got shape ${o}.`)}}if(s.shape!=null)for(let o=0;o<s.shape.length;++o){let l=s.shape[o],p=a.shape[o];if(l!=null&&p!=null&&l!==p)throw new V(`Input ${r} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${a.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();let n=Qe(e),r=xW(e),a=vW(e);if(r===a)throw new V("Arguments to apply() must be all SymbolicTensors or all Tensors");return Es(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);let s=[];for(let i of Qe(e))s.push(i.shape);this.build(Sn(s)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&a&&(this._refCount=1)}if(this.assertInputCompatibility(e),a){let s=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,s);let i=Qe(s),o=[];for(let l of i)n.indexOf(l)!==-1&&(l=l.clone()),o.push(l);if(s=Sn(o),this.activityRegularizer!=null)throw new Be("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return s}else{let s=yW(e),i=this.computeOutputShape(s),o,l=bW(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?s[0]:s),i!=null&&i.length>0&&Array.isArray(i[0])?o=i.map((p,u)=>new Nr(l,p,this,Qe(e),t,this.name,u)):o=new Nr(l,i,this,Qe(e),t,this.name),this.addInboundNode(e,o,null,null,s,i,t),this._refCount++,this.activityRegularizer!=null)throw new Be("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((n,r)=>{n!=null&&e[r]!=null&&e[r]!==n&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Ta(`The layer ${this.name} has never been called and thus has no defined output shape.`);let e=[];for(let t of this.inboundNodes){let n=JSON.stringify(t.outputShapes);e.indexOf(n)===-1&&e.push(n)}if(e.length===1){let t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new Ta(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new zr(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return kh(this.weights)}build(e){this.built=!0}getWeights(e=!1){return ym(e?this.trainableWeights:this.weights)}setWeights(e){B(()=>{let t=this.weights;if(t.length!==e.length)throw new V(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;let n=[],r=ym(t);for(let a=0;a<r.length;++a){let s=r[a],i=t[a],o=e[a];if(!w.arraysEqual(s.shape,o.shape))throw new V(`Layer weight shape ${s.shape} not compatible with provided weight shape ${o.shape}`);n.push([i,o])}Wy(n)})}addWeight(e,t,n,r,a,s,i,o){if(this._addedWeightNames.indexOf(e)!==-1)throw new V(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),n==null&&(n="float32"),this.fastWeightInitDuringBuild&&(r=o!=null?o():gt("zeros"));let l=r.apply(t,n),p=new cI(l,n,e,s,i);return l.dispose(),a!=null&&this.addLoss(()=>a.apply(p.read())),s==null&&(s=!0),s?this._trainableWeights.push(p):this._nonTrainableWeights.push(p),p}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=Qe(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(n=>{if(n!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;let r=this.computeMask(e,n),a=Qe(t),s=Qe(r);if(a.length!==s.length)throw new Error(`${this.name} outputs ${a.length} tensors but ${a.length} masks for those tensors`);for(let i=0;i<a.length;i++)a[i].kerasMask=s[i]}addInboundNode(e,t,n,r,a,s,i=null){let o=Qe(e);t=Qe(t),n=Qe(n),r=Qe(r),a=wh(a),s=wh(s);let l=[],p=[],u=[];for(let d of o)l.push(d.sourceLayer),p.push(d.nodeIndex),u.push(d.tensorIndex);new Qc({outboundLayer:this,inboundLayers:l,nodeIndices:p,tensorIndices:u,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:a,outputShapes:s},i);for(let d=0;d<t.length;d++)t[d].sourceLayer=this,t[d].nodeIndex=this.inboundNodes.length-1,t[d].tensorIndex=d}getConfig(){let e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}};function yW(e){e=Qe(e);let t=[];for(let n of e)t.push(n.shape);return Sn(t)}function bW(e){return"float32"}function fI(e,t,n){if((t==null||n!=null&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),t.inboundNodes.length===0)return[e];{let r=t.inboundNodes[n];if(r.inboundLayers.length===0)return r.inputTensors;{let a=[];for(let s=0;s<r.inboundLayers.length;s++){let i=r.inputTensors[s],o=r.inboundLayers[s],l=r.nodeIndices[s],p=fI(i,o,l);for(let u of p)a.indexOf(u)===-1&&a.push(u)}return a}}}function xW(e){let t=!0;for(let n of Qe(e))if(!(n instanceof Nr)){t=!1;break}return t}function vW(e){let t=!0;for(let n of Qe(e))if(n instanceof Nr){t=!1;break}return t}var vu=class extends We{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:Gc("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new V("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new V("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new V("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];let r=new Nr(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new Qc({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new V(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};vu.className="InputLayer";ne.registerClass(vu);function mI(e){if(e.batchShape==null&&e.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(e.batchShape!=null&&e.shape!=null)throw new V("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;e.shape!=null&&t==null&&(t=[null].concat(e.shape));let n=e.dtype;return n==null&&(n="float32"),new vu({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}function wW(e,t){if(e.dtype==null||e.dtype===t.dtype)return t;try{return se(t,e.dtype)}catch{throw new V(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}var Po=class gI{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof gI)for(let n in t.id2Value)this.id2Value[n]=t.id2Value[n],n in t.id2Mask&&(this.id2Mask[n]=t.id2Mask[n]);else{if(t==null)return;for(let n of t)this.add(n.key,n.value)}}add(t,n,r){if(this.id2Value[t.id]==null)this.id2Value[t.id]=wW(t,n),this.name2Id[t.name]=t.id,r!=null&&(this.id2Mask[t.id]=r);else throw new V(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof Nr){if(this.id2Value[t.id]==null)throw new V(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{let n=this.name2Id[t];if(n==null)throw new V(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[n]}}getMask(t){if(t instanceof Nr){if(this.id2Value[t.id]==null)throw new V(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{let n=this.name2Id[t];if(n==null)throw new V(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[n]}}disposeMasks(){this.id2Mask!=null&&_e(this.id2Mask)}},Ih=new rI,Sh=new rI;function kW(e){Ih!=null&&Ih.setMaxEntries(e),Sh!=null&&Sh.setMaxEntries(e)}function Gu(e,t,n,r){let a=n==null?!1:n.training,s=Array.isArray(e),i=s?e:[e],o=i.map(f=>f.name),l=[],p=t.names();for(let f of o)p.indexOf(f)!==-1?l.push(t.getValue(f)):l.push(null);let u=o.join(",")+"|"+t.names().sort().join(","),d=Ih.get(u),h;if(d==null){let f=IW(i,t);d=f.sorted,h=f.recipientCounts,Ih.put(u,d),Sh.put(u,h)}h={},a||Object.assign(h,Sh.get(u));let c=new Po(t);for(let f=0;f<d.length;++f){let m=d[f],g=m.sourceLayer;if(g instanceof vu)continue;let y=[],b=[],x=[],v=!1;for(let A of m.inputs){let R=c.getValue(A),F=c.getMask(A);y.push(R),b.push(F),F!=null&&(v=!0),a||(h[A.name]--,h[A.name]===0&&!t.hasKey(A)&&o.indexOf(A.name)===-1&&!R.isDisposed&&A.sourceLayer.stateful!==!0&&x.push(R))}v&&(n=n||{},n.mask=b[0]);let I=Qe(g.apply(y,n)),T=null;g.supportsMasking&&(T=g.computeMask(y,b));let _=NW(m),E=Array.isArray(_)?_:[_];for(let A=0;A<E.length;++A){c.hasKey(E[A])||c.add(E[A],I[A],Array.isArray(T)?T[0]:T);let R=o.indexOf(E[A].name);R!==-1&&(l[R]=I[A])}a||_e(x)}return c.disposeMasks(),s?l:l[0]}function IW(e,t){w.assert(e!=null&&e.length>0,()=>"Expected at least one fetch, got none");let n=[],r={};if(e.length===1){let a=uw(e[0],t);n=a.sorted,r=a.recipientMap}else{let a=new Set;for(let s of e){let{sorted:i,recipientMap:o}=uw(s,t);for(let l of i)a.has(l.name)||(n.push(l),a.add(l.name));for(let l in o)r[l]==null&&(r[l]=new Set),o[l].forEach(p=>r[l].add(p))}}return{sorted:n,recipientCounts:SW(r)}}function SW(e){let t={};for(let n in e)t[n]=e[n].size;return t}function uw(e,t){let n=new Set,r=[],a={};for(let o of t.names())n.add(o);let s=[],i=[];for(s.push(e);s.length>0;){let o=s[s.length-1];if(n.has(o.name)){s.pop();continue}let l=i[i.length-1]===s.length-1;if(o.inputs.length===0||l)s.pop(),r.push(o),n.add(o.name),l&&i.pop();else{i.push(s.length-1);for(let p of o.inputs)a[p.name]==null&&(a[p.name]=new Set),a[p.name].add(o.name),!n.has(p.name)&&s.push(p)}}return{sorted:r,recipientMap:a}}function NW(e){let t;if(e.sourceLayer.inboundNodes.length===1)t=e.sourceLayer.output;else{let n=null;for(let r=0;r<e.sourceLayer.inboundNodes.length;++r)for(let a of e.sourceLayer.inboundNodes[r].outputTensors)if(a.id===e.id){n=r;break}t=e.sourceLayer.getOutputAt(n)}return t}var TW=G();TW.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,kW);var yI={};Ee(yI,{maxNorm:()=>CW,minMaxNorm:()=>$W,nonNeg:()=>EW,unitNorm:()=>_W});function Vy(e,t){return B(()=>Kt(ge(z(e,e),t,!0)))}var fd=class extends ne.Serializable{getConfig(){return{}}},Uy=class extends fd{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return B(()=>{let t=Vy(e,this.axis),n=an(t,0,this.maxValue);return z(e,fe(n,X(Ot(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};Uy.className="MaxNorm";ne.registerClass(Uy);var Gy=class extends fd{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return B(()=>fe(e,X(Ot(),Vy(e,this.axis))))}getConfig(){return{axis:this.axis}}};Gy.className="UnitNorm";ne.registerClass(Gy);var Hy=class extends fd{apply(e){return et(e)}};Hy.className="NonNeg";ne.registerClass(Hy);var jy=class extends fd{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return B(()=>{let t=Vy(e,this.axis),n=X(z(this.rate,an(t,this.minValue,this.maxValue)),z(1-this.rate,t));return z(e,fe(n,X(Ot(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};jy.className="MinMaxNorm";ne.registerClass(jy);var pw={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function zt(e){return Ay(e)}function dw(e,t={}){return pd(e,ne.SerializationMap.getMap().classNameMap,t,"constraint")}function Pt(e){if(e==null)return null;if(typeof e=="string"){let t={className:e in pw?pw[e]:e,config:{}};return dw(t)}else return e instanceof fd?e:dw(e)}function CW(e){return new Uy(e)}function _W(e){return new Gy(e)}function EW(){return new Hy}function $W(e){return new jy(e)}var bI={};Ee(bI,{constant:()=>RW,glorotNormal:()=>BW,glorotUniform:()=>PW,heNormal:()=>WW,heUniform:()=>VW,identity:()=>LW,leCunNormal:()=>UW,leCunUniform:()=>GW,ones:()=>FW,orthogonal:()=>HW,randomNormal:()=>MW,randomUniform:()=>DW,truncatedNormal:()=>OW,varianceScaling:()=>zW,zeros:()=>AW});function AW(){return new Dy}function FW(){return new jc}function RW(e){return new My(e)}function DW(e){return new Oy(e)}function MW(e){return new Ly(e)}function OW(e){return new zy(e)}function LW(e){return new Py(e)}function zW(e){return new En(e)}function PW(e){return new qc(e)}function BW(e){return new Kc(e)}function WW(e){return new Xc(e)}function VW(e){return new Zc(e)}function UW(e){return new Jc(e)}function GW(e){return new Yc(e)}function HW(e){return new By(e)}var xI={};Ee(xI,{Layer:()=>We,RNN:()=>ga,RNNCell:()=>gd,activation:()=>kV,add:()=>AV,alphaDropout:()=>fU,average:()=>FV,averagePooling1d:()=>ax,averagePooling2d:()=>sx,averagePooling3d:()=>ix,avgPool1d:()=>WV,avgPool2d:()=>UV,avgPool3d:()=>HV,avgPooling1d:()=>VV,avgPooling2d:()=>GV,avgPooling3d:()=>jV,batchNormalization:()=>zV,bidirectional:()=>iU,categoryEncoding:()=>xU,centerCrop:()=>yU,concatenate:()=>RV,conv1d:()=>cV,conv2d:()=>fV,conv2dTranspose:()=>mV,conv3d:()=>gV,conv3dTranspose:()=>yV,convLstm2d:()=>nU,convLstm2dCell:()=>rU,cropping2D:()=>xV,dense:()=>IV,depthwiseConv2d:()=>wV,dot:()=>LV,dropout:()=>SV,elu:()=>oV,embedding:()=>$V,flatten:()=>TV,gaussianDropout:()=>cU,gaussianNoise:()=>hU,globalAveragePooling1d:()=>qV,globalAveragePooling2d:()=>KV,globalMaxPool1d:()=>lU,globalMaxPool2d:()=>uU,globalMaxPooling1d:()=>wS,globalMaxPooling2d:()=>kS,gru:()=>ZV,gruCell:()=>JV,input:()=>LI,inputLayer:()=>iV,layerNormalization:()=>PV,leakyReLU:()=>uV,lstm:()=>YV,lstmCell:()=>QV,masking:()=>mU,maxPool1d:()=>pU,maxPool2d:()=>dU,maxPooling1d:()=>IS,maxPooling2d:()=>SS,maxPooling3d:()=>XV,maximum:()=>DV,minimum:()=>MV,multiply:()=>OV,permute:()=>EV,prelu:()=>pV,randomWidth:()=>vU,reLU:()=>lV,repeatVector:()=>CV,rescaling:()=>gU,reshape:()=>_V,resizing:()=>bU,rnn:()=>aU,separableConv2d:()=>bV,simpleRNN:()=>eU,simpleRNNCell:()=>tU,softmax:()=>dV,spatialDropout1d:()=>NV,stackedRNNCells:()=>sU,thresholdedReLU:()=>hV,timeDistributed:()=>oU,upSampling2d:()=>vV,zeroPadding2d:()=>BV});async function Sa(e){if(e==null)return;let t=[],n=[],r=[];for(let a in e){let s=e[a];if(typeof s!="number"){let i=s;t.push(i.data()),n.push(a),r.push(i)}}if(t.length>0){let a=await Promise.all(t);for(let s=0;s<a.length;++s)e[n[s]]=a[s][0];_e(r)}}function vI(e){if(e!=null)for(let t in e){let n=e[t];typeof n!="number"&&n.dispose()}}var hw;(function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"})(hw||(hw={}));var jW=125,rl=class{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}},wI=class{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(let t of this.callbacks)t.setParams(e)}setModel(e){for(let t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainEnd(e)}},qW=class extends rl{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});let n=t.size==null?0:t.size;this.seen+=n;for(let r in t){let a=t[r];if(typeof a=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+a*n;else{let s;r in this.totals?s=this.totals[r]:this.totals[r]=0;let i=B(()=>X(this.totals[r],z(a,n)));this.totals[r]=i,s!=null&&s.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(let n of this.params.metrics)this.totals[n]!=null&&(typeof this.totals[n]=="number"?t[n]=this.totals[n]/this.seen:B(()=>{let r=z(fe(1,this.seen),this.totals[n]);t[n]=r,this.totals[n].dispose(),Mt(t[n])}))}},kI=class extends rl{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(let n in t)this.history[n]==null&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){let e=[],t=[],n=[];for(let a in this.history){let s=this.history[a];for(let i=0;i<s.length;++i)if(typeof s[i]!="number"){let o=s[i];e.push(o.data()),t.push(a),n.push(i)}}let r=await Promise.all(e);for(let a=0;a<r.length;++a)this.history[t[a]][n[a]].dispose(),this.history[t[a]][n[a]]=r[a][0]}},II=class extends rl{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||Ey,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=jW),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");w.isNumber(this.yieldEvery)&&(this.maybeWait=jB(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){let r=[];this.yield!=null&&(await Sa(n),r.push(this.yield(e,t,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await Sa(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){let n=[];this.epochEnd!=null&&(await Sa(t),n.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){this.batchBegin!=null&&(await Sa(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){let n=[];this.batchEnd!=null&&(await Sa(t),n.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?n.push(this.nextFrameFunc()):w.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){this.trainBegin!=null&&(await Sa(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await Sa(e),await this.trainEnd(e))}};function SI(e,t){return e==null&&(e={}),e instanceof rl?[e]:Array.isArray(e)&&e[0]instanceof rl?e:Qe(e).map(n=>new II(n,t))}var qy=class Fr{constructor(){}static registerCallbackConstructor(t,n){w.assert(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),Fr.checkForDuplicate(n),Fr.constructors[t]==null&&(Fr.constructors[t]=[]),Fr.constructors[t].push(n)}static checkForDuplicate(t){for(let n in Fr.constructors)Fr.constructors[+n].forEach(r=>{if(r===t)throw new V("Duplicate callback constructor.")})}static clear(){Fr.constructors={}}static createCallbacks(t){let n=[];for(let r in Fr.constructors){let a=+r;t>=a&&n.push(...Fr.constructors[a])}return n.map(r=>new r)}};qy.constructors={};function NI(e,t,n,r,a,s,i,o,l){let p=new kI,u=[new qW,...qy.createCallbacks(t)];e!=null&&u.push(...e),u.push(p);let d=new wI(u);return d.setParams({epochs:n,initialEpoch:r,samples:a,steps:s,batchSize:i,verbose:t,doValidation:o,metrics:l}),{callbackList:d,history:p}}function vr(e,t={},n=!1){return pd(e,ne.SerializationMap.getMap().classNameMap,t,"layer",n)}function Nh(e,t){return B(()=>{e.dtype!=="float32"&&(e=se(e,"float32"));let n=ge(hd(e),t,!0),r=Bn(n.shape,Ot()),a=Kt(Kr(n,r));return fe(e,a)})}function Io(e,t){return B(()=>xt(hd(de(t,e)),-1))}function ef(e,t){return B(()=>xt(_t(de(t,e)),-1))}function wu(e,t){return B(()=>{let n=de(e,t),r=an(_t(e),Ot(),Number.MAX_VALUE),a=_t(fe(n,r));return z(100,xt(a,-1))})}function KW(e,t){return B(()=>{let n=an(t,Ot(),Number.MAX_VALUE),r=Vn(X(1,n)),a=an(e,Ot(),Number.MAX_VALUE),s=Vn(X(1,a));return xt(hd(de(r,s)),-1)})}function XW(e,t){return B(()=>{let n=Kr(0,de(1,z(e,t)));return xt(hd(n),-1)})}function ZW(e,t){return B(()=>{let n=Kr(0,de(1,z(e,t)));return xt(n,-1)})}function JW(e,t){return B(()=>{let n=ge(z(e,t),-1),r=er(z(de(1,e),t),-1);return Kr(0,X(1,de(r,n)))})}function YW(e,t){return B(()=>{let n=Math.log(2),r=de(t,e),a=de(X(r,vo(z(-2,r))),n);return xt(a,-1)})}function hp(e,t,n=!1){return B(()=>{if(n)t=ss(t);else{let r=ge(t,t.shape.length-1,!0);t=fe(t,r)}return t=an(t,Ot(),1-Ot()),ct(ge(z(se(e,"float32"),Vn(t)),t.shape.length-1))})}function Th(e,t,n=!1){return B(()=>{let r=se(mu(aW(e)),"int32");t=an(t,Ot(),1-Ot());let a=t.shape,s=P(Jo(r,a[a.length-1]),a);return hp(s,t,n)})}function QW(e,t){if(!w.arraysEqual(e.shape,t.shape))throw new V(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return B(()=>{let n=et(t),r=ct(_t(t));return X(de(n,z(t,e)),ed(sn(r)))})}function tf(e,t){return B(()=>{let n;return n=an(t,Ot(),1-Ot()),n=Vn(fe(n,de(1,n))),xt(QW(e,n),-1)})}function e4(e,t){return B(()=>{let n=an(e,Ot(),1),r=an(t,Ot(),1);return ge(z(e,Vn(fe(n,r))),-1)})}function t4(e,t){return B(()=>{let n=Vn(X(Ot(),t));return xt(de(t,z(e,n)),-1)})}function Ky(e,t){return B(()=>{let n=Nh(e,-1),r=Nh(t,-1),a=z(n,r);return ct(ge(a,-1))})}var Ch={meanSquaredError:Io,meanAbsoluteError:ef,meanAbsolutePercentageError:wu,meanSquaredLogarithmicError:KW,squaredHinge:XW,hinge:ZW,categoricalHinge:JW,logcosh:YW,categoricalCrossentropy:hp,sparseCategoricalCrossentropy:Th,binaryCrossentropy:tf,kullbackLeiblerDivergence:e4,poisson:t4,cosineProximity:Ky};function Of(e){if(typeof e=="string"){if(e in Ch)return Ch[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new V(t)}else return e}function Xy(e,t){return B(()=>{let n=z(.5,Un(t)),r=ua(xn(t,n),e.dtype);return xt(Wn(e,r),-1)})}function Zy(e,t){return B(()=>ua(Wn(Ps(e,-1),Ps(t,-1)),"float32"))}function TI(e,t){return B(()=>se(ge(dr(Wn(e,1),Wn(t,1))),"float32"))}function n4(e,t){return B(()=>se(ge(dr(Wn(e,1),Wn(t,0))),"float32"))}function r4(e,t){return B(()=>se(ge(dr(Wn(e,0),Wn(t,1))),"float32"))}function CI(e,t){return B(()=>{let n=TI(e,t),r=r4(e,t),a=X(n,r);return se(qt(xn(a,0),fe(n,a),0),"float32")})}function a4(e,t){return B(()=>{let n=TI(e,t),r=n4(e,t),a=X(n,r);return se(qt(xn(a,0),fe(n,a),0),"float32")})}function _I(e,t){return tf(e,t)}function EI(e,t){return e.rank===t.rank&&(e=is(e,[e.rank-1])),t=Ps(t,-1),t.dtype!==e.dtype&&(t=se(t,e.dtype)),se(Wn(e,t),"float32")}function s4(e,t){return B(()=>{let n=e.sub(t).square().sum(),r=e.sub(e.mean()).square().sum();return we(1).sub(n.div(r))})}var i4=Io,o4=Io,l4=ef,u4=ef,p4=wu,d4=wu,Jy=hp,h4=Ky,$I=Th,_h={binaryAccuracy:Xy,categoricalAccuracy:Zy,precision:CI,categoricalCrossentropy:Jy,sparseCategoricalCrossentropy:$I,mse:i4,MSE:o4,mae:l4,MAE:u4,mape:p4,MAPE:d4,cosine:h4};function c4(e){if(typeof e=="string"&&e in _h)return _h[e];if(typeof e!="string"&&e!=null)return e;throw new V(`Unknown metric ${e}`)}function jd(e){if(Or(e!==null,`Unknown LossOrMetricFn ${e}`),typeof e=="string")return e;{let t;for(let n of Object.keys(Ch))if(Ch[n]===e){t=n;break}if(t!==void 0)return t;for(let n of Object.keys(_h))if(_h[n]===e){t=n;break}return t!==void 0?t:e.name}}function f4(e){let t={Adagrad:()=>xs.adagrad(.01),Adadelta:()=>xs.adadelta(1,.95,Ot()),Adam:()=>xs.adam(.001,.9,.999,Ot()),Adamax:()=>xs.adamax(.002,.9,.999,Ot(),0),RMSProp:()=>xs.rmsprop(.001,.9,0,Ot()),SGD:()=>xs.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new V(`Unknown Optimizer ${e}`)}function cw(e,t,n=!1){if(e==null||typeof e!="object"||Object.getPrototypeOf(e)!==Object.prototype||!bm(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){let r=JSON.stringify(e);r.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function bm(e){if(e===null)return!0;if(typeof e=="object")if(Object.getPrototypeOf(e)===Object.prototype){let t=Object.keys(e);for(let n of t)if(typeof n!="string"||!bm(e[n]))return!1;return!0}else if(Array.isArray(e)){for(let t of e)if(!bm(t))return!1;return!0}else return!1;else{let t=typeof e;return t==="string"||t==="number"||t==="boolean"}}function m4(e,t,n,r=console.log){let a=y4(e),s=["Layer (type)","Input Shape","Output shape","Param #"];a?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map(u=>Math.floor(t*u)));let i;if(!a){s.push("Receives inputs"),i=[];for(let u in e.nodesByDepth)i.push(...e.nodesByDepth[u])}r("_".repeat(t)),Eh(s,n,r),r("=".repeat(t));let o=e.layers;for(let u=0;u<o.length;++u)a?b4(o[u],n,r):x4(o[u],n,i,r),r((u===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();let l=g4(e),p=kh(e.nonTrainableWeights);r(`Total params: ${l+p}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${p}`),r("_".repeat(t))}function g4(e){let t;return e.collectedTrainableWeights!=null?t=kh(e.collectedTrainableWeights):t=kh(e.trainableWeights),t}function y4(e){let t=!0,n=[],r=[];for(let a in e.nodesByDepth)n.push(e.nodesByDepth[a]);for(let a of n){if(a.length>1||a.length===1&&a[0].inboundLayers.length>1){t=!1;break}r.push(...a)}if(t)for(let a of e.layers){let s=!1;for(let i of a.inboundNodes)if(r.indexOf(i)!==-1)if(s){t=!1;break}else s=!0;if(!t)break}return t}function Eh(e,t,n=console.log){let r="";for(let a=0;a<e.length;++a)a>0&&(r=r.slice(0,r.length-1)+" "),r+=e[a],r=r.slice(0,t[a]),r+=" ".repeat(t[a]-r.length);n(r)}function b4(e,t,n){let r,a;try{a=e.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{a="multiple"}try{r=JSON.stringify(e.outputShape)}catch{r="multiple"}let s=e.name,i=e.getClassName(),o=[`${s} (${i})`,a,r,e.countParams().toString()];Eh(o,t,n)}function x4(e,t,n,r){let a,s;try{s=e.inboundNodes.map(d=>JSON.stringify(d.inputShapes)).join(",")}catch{s="multiple"}try{a=JSON.stringify(e.outputShape)}catch{a="multiple"}let i=[];for(let d of e.inboundNodes)if(!(n!=null&&n.length>0&&n.indexOf(d)===-1))for(let h=0;h<d.inboundLayers.length;++h){let c=d.inboundLayers[h].name,f=d.nodeIndices[h],m=d.tensorIndices[h];i.push(`${c}[${f}][${m}]`)}let o=e.name,l=e.getClassName(),p=i.length===0?"":i[0],u=[`${o} (${l})`,s,a,e.countParams().toString(),p];Eh(u,t,r);for(let d=1;d<i.length;++d)Eh(["","","","",i[d]],t,r)}function AI(e,t,n){return(e==="inboundNodes"||e==="outputLayers"||e==="inputLayers")&&t===0&&typeof n=="string"}function cp(e,t){if(e===null)return null;if(typeof e=="string")return Is(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){let n=[],r=e.length;for(let a=0;a<r;++a){let s=e[a];AI(t,a,s)?n.push(s):n.push(cp(s,t))}return n}else{let n={};for(let r of Object.keys(e)){let a=e[r];if(r==="name"&&typeof a=="string")n[r]=a;else{let s=Is(r);n[s]=cp(a,s)}}return n}}function xm(e,t){if(e==null)return null;if(typeof e=="string")return ta(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){let n=[],r=e.length;for(let a=0;a<r;++a){let s=e[a];AI(t,a,s)?n.push(s):n.push(xm(s,t))}return n}else{let n={};for(let r of Object.keys(e)){let a=e[r],s=ta(r);(r==="name"||r==="className")&&typeof a=="string"?n[s]=a:n[s]=xm(a,r)}return n}}var Yy="4.22.0",v4=e=>{let t=Object.keys(e);if(t.length===0)return!1;let n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))},w4=class Rr extends We{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,this.name==null){let b=this.getClassName().toLowerCase();this.name=Gc(b)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],Da(this.inputs).length!==this.inputs.length)throw new V(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(b=>b.name)}`);Da(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(b=>b.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let b of this.outputs){let x=b.sourceLayer,v=b.nodeIndex,I=b.tensorIndex;this.outputLayers.push(x),this.outputLayersNodeIndices.push(v),this.outputLayersTensorIndices.push(I)}for(let b of this.inputs){let x=b.sourceLayer,v=b.nodeIndex,I=b.tensorIndex;Or(v===0,"input layer has >1 nodes"),Or(I===0,"input layer has >1 tensors"),this.inputLayers.push(x),this.inputLayersNodeIndices.push(v),this.inputLayersTensorIndices.push(I)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){let x=this.inputLayers[b];if(!(x instanceof vu))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${b} (0-based) originates from layer type ${x.getClassName()}.`);this.inputNames.push(x.name),this.feedInputShapes.push(x.batchInputShape),this.feedInputNames.push(x.name)}for(let b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(b=>b.shape),this.internalOutputShapes=this.outputs.map(b=>b.shape);let n={},r={},a={},s={},i={},o=[],l=(b,x,v,I,T,_)=>{(I==null||T==null||_==null)&&(I=b.sourceLayer,T=b.nodeIndex,_=b.tensorIndex);let E=I.inboundNodes[T];if(v.indexOf(E)!==-1)throw new zr(`The tensor ${b.name} at layer "${I.name}" is part of a cycle.`);if(x.indexOf(E)!==-1)return;this.containerNodes.add(Rr.nodeKey(I,T)),I.id in i||(i[I.id]=Object.keys(i).length),v.indexOf(E)===-1&&v.push(E);let A=E.inboundLayers.length;for(let R=0;R<A;R++){let F=E.inputTensors[R],S=E.inboundLayers[R],M=E.nodeIndices[R],W=E.tensorIndices[R];l(F,x,v,S,M,W)}for(x.push(E);v.indexOf(E)>=0;)v.splice(v.indexOf(E),1);o.push(E)},p=[],u=[];for(let b of this.outputs)l(b,p,u);let d=o.slice().reverse();for(let b of d){r[b.id]=b,b.id in n||(n[b.id]=0);let x=n[b.id],v=a[b.outboundLayer.id]==null?0:a[b.outboundLayer.id];x=Math.max(x,v),a[b.outboundLayer.id]=x,s[b.outboundLayer.id]=b.outboundLayer,n[b.id]=x;for(let I=0;I<b.inboundLayers.length;I++){let T=b.inboundLayers[I],_=b.nodeIndices[I],E=T.inboundNodes[_],A=n[E.id]==null?0:n[E.id];n[E.id]=Math.max(x+1,A),r[E.id]=E}}let h={};for(let b in n){let x=n[b];x in h||(h[x]=[]),h[x].push(r[b])}let c={};for(let b in a){let x=a[b];x in c||(c[x]=[]),c[x].push(s[b])}let f=Object.keys(c).map(b=>parseInt(b,10)).sort(Ud);this.layers=[];for(let b of f){let x=c[b];x.sort((v,I)=>{let T=i[v.id],_=i[I.id];return T<_?-1:T>_?1:0});for(let v of x)v instanceof Rr&&this.internalContainerRefs.push(v),this.layers.push(v)}this.layersByDepth=c,f=Object.keys(h).map(b=>parseInt(b,10)).sort(Ud);let m=this.inputs.slice(),g=[];for(let b of f)for(let x of h[b]){let v=x.outboundLayer;if(v!=null){for(let I of x.inputTensors)if(m.indexOf(I)===-1)throw new zr(`Graph disconnected: cannot obtain value for tensor ${I} at layer "${v.name}". The following previous layers were accessed without issue: ${g}`);for(let I of x.outputTensors)m.push(I);g.push(v.name)}}this.nodesByDepth=h;let y=this.layers.map(b=>b.name);for(let b of y){let x=y.filter(v=>v===b).length;if(x!==1)throw new zr(`The name "${b}" is used ${x} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new Qc({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(b=>null),outputMasks:this.outputs.map(b=>null),inputShapes:this.inputs.map(b=>b.shape),outputShapes:this.outputs.map(b=>b.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(let n of this.layers)t.numDisposedVariables+=n.dispose().numDisposedVariables;for(let n of this.internalContainerRefs)t.numDisposedVariables+=n.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(n=>{n._trainableWeights.forEach(r=>r.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new V("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(let n of this.layers)t=t.concat(n.trainableWeights);return t}get nonTrainableWeights(){let t=[];for(let n of this.layers)t.push(...n.nonTrainableWeights);if(!this.trainable){let n=[];for(let r of this.layers)n.push(...r.trainableWeights);return n.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,n=!0){let r={},a=0,s=v4(t);s&&this.parseWeights(t);for(let o of this.layers)for(let[l,p]of o.weights.entries()){let u=s?`${p.name.split("/").slice(0,-1).join("/")+"/"}${l}`:p.originalName;if(r[u]!=null)throw new V(`Duplicate weight name: ${u}`);r[u]=p,a++}let i=[];for(let o in t){let l=o;if(r[o]==null){let p=o.split("/");l=p.slice(0,-2).concat([p[p.length-1]]).join("/")}if(r[l]!=null)i.push([r[l],t[o]]);else if(n)throw new V(`Provided weight data has no target variable: ${o}`);delete r[l]}if(n){let o=[];for(let l in r)o.push(l);if(o.length>0)throw new V(`${o.length} of ${a} weights are not set: ${o}`)}Wy(i)}parseWeights(t){for(let n in Object.keys(t)){let r=n.split("/"),a=["vars","layer_checkpoint_dependencies"],s=r.map(i=>i.startsWith("_")?i.slice(1):i).filter(i=>!a.includes(i)).join("/");s!==n&&(t[s]=t[n],delete t[n])}}updatedConfig(){let t=this.getConfig(),n={};return n.className=this.getClassName(),n.config=t,n.kerasVersion=`tfjs-layers ${Yy}`,n.backend="TensorFlow.js",n}toJSON(t,n=!0){let r=xm(this.updatedConfig());return n?JSON.stringify(r):r}call(t,n){return B(()=>{t=Qe(t);let r=new Po;for(let a=0;a<this.inputs.length;++a)r.add(this.inputs[a],t[a]);return Gu(this.outputs,r,n)})}computeMask(t,n){return B(()=>{t=Qe(t);let r;return n==null?r=Gs(null,t.length):r=Qe(n),this.runInternalGraph(t,r)[1]})}computeOutputShape(t){let n=wh(t);if(n.length!==this.inputLayers.length)throw new V(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);let r={};for(let o=0;o<n.length;o++){let l=this.inputLayers[o],p=n[o],u=l.name+"_0_0";r[u]=p}let a=Object.keys(this.nodesByDepth).map(o=>parseInt(o,10)).sort(Ud);if(a.length>1)for(let o of a){let l=this.nodesByDepth[o];for(let p of l){let u=p.outboundLayer;if(this.inputLayers.map(m=>m.id).indexOf(u.id)!==-1)continue;let d=[];for(let m=0;m<p.inboundLayers.length;m++){let g=p.inboundLayers[m],y=p.nodeIndices[m],b=p.tensorIndices[m],x=`${g.name}_${y}_${b}`,v=r[x];d.push(v)}let h=u.computeOutputShape(Sn(d)),c=wh(h),f=u.inboundNodes.indexOf(p);for(let m=0;m<c.length;m++){let g=`${u.name}_${f}_${m}`;r[g]=c[m]}}}let s=[],i=[];for(let o=0;o<this.outputLayers.length;o++){let l=this.outputLayers[o],p=this.outputLayersNodeIndices[o],u=this.outputLayersTensorIndices[o],d=`${l.name}_${p}_${u}`;i.push(d)}for(let o=0;o<i.length;o++){let l=i[o];Or(l in r),s.push(r[l])}return Sn(s)}runInternalGraph(t,n){n==null&&(n=Gs(null,t.length));let r={};for(let l=0;l<this.inputs.length;++l){let p=this.inputs[l],u=t[l],d=n[l];r[p.id]=[u,d]}let a=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(Ud);for(let l of a){let p=this.nodesByDepth[l];for(let u of p){let d=u.outboundLayer,h=u.inputTensors,c=u.outputTensors,f=new Array;for(let m of h)m.id in r&&f.push(r[m.id]);if(f.length===h.length){let m={},g,y,b,x;if(u.callArgs!=null&&(m=u.callArgs),f.length===1){let[v,I]=f[0];m.mask==null&&(m.mask=I),b=Qe(d.call(v,m)),x=Qe(d.computeMask(v,I)),g=[v],y=[I]}else g=f.map(v=>v[0]),y=f.map(v=>v[1]),m.mask==null&&(m.mask=y),b=Qe(d.call(g,m)),x=Qe(d.computeMask(g,y));if(d.activityRegularizer)throw new Be("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let v=0;v<c.length;++v){let I=c[v],T=b[v],_=x[v];r[I.id]=[T,_]}}}}let s=[],i=[],o=[];for(let l of this.outputs){Or(l.id in r,`Could not compute output ${l.name} : ${l.id}`);let[p,u]=r[l.id];o.push(p.shape),s.push(p),i.push(u)}return[s,i,o]}buildNodeConversionMap(t){let n={},r;for(let a of this.layers){r=a instanceof Rr?1:0;for(let s=0;s<a.inboundNodes.length;s++){let i=Rr.nodeKey(a,s);this.containerNodes.has(i)&&(n[i]=r,r+=1)}}return n}getLayer(t,n){if(n!=null)return this.findLayer(n);if(t==null)throw new V("Provide either a layer name or layer index");if(typeof t=="number")return this.findLayer(t);for(let r of this.layers)if(r.name===t)return r;throw new V(`No such layer: ${t}`)}findLayer(t){if(this.layers.length<=t)throw new V(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}calculateLosses(){return B(()=>{let t=[];for(let n of this.layers)for(let r=0;r<n.inboundNodes.length;++r){let a=Rr.nodeKey(n,r);this.containerNodes.has(a)&&t.push(...n.calculateLosses())}return t})}getConfig(){let t={name:this.name},n=this.buildNodeConversionMap(this.layers),r=[];for(let i of this.layers){let o=i.getClassName(),l=i.getConfig(),p=[];for(let d=0;d<i.inboundNodes.length;d++){let h=i.inboundNodes[d],c=Rr.nodeKey(i,d),f={};if(this.containerNodes.has(c)){if(h.callArgs)try{JSON.stringify(h.callArgs),f=h.callArgs}catch{console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${h.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),f={}}if(h.inboundLayers.length>0){let m=[];for(let g=0;g<h.inboundLayers.length;g++){let y=h.inboundLayers[g],b=h.nodeIndices[g],x=h.tensorIndices[g],v=Rr.nodeKey(y,b),I=n[v];I==null&&(I=0),m.push([y.name,I,x,f])}p.push(m)}}}let u={};u.name=i.name,u.className=o,u.config=l,u.inboundNodes=p,r.push(u)}t.layers=r;let a=[];for(let i=0;i<this.inputLayers.length;i++){let o=this.inputLayers[i],l=this.inputLayersNodeIndices[i],p=Rr.nodeKey(o,l);if(!this.containerNodes.has(p))continue;let u=n[p];u==null&&(u=0);let d=this.inputLayersTensorIndices[i];a.push([o.name,u,d])}t.inputLayers=a;let s=[];for(let i=0;i<this.outputLayers.length;i++){let o=this.outputLayers[i],l=this.outputLayersNodeIndices[i],p=Rr.nodeKey(o,l);if(!this.containerNodes.has(p))continue;let u=n[p];u==null&&(u=0);let d=this.outputLayersTensorIndices[i];s.push([o.name,u,d])}return t.outputLayers=s,t}static fromConfig(t,n,r={},a=!1){let s={},i={};function o(g,y){g.name in i?i[g.name].push(y):i[g.name]=[y]}function l(g,y){let b=[],x;for(let v of y){let I=v[0],T=v[1],_=v[2];if(x=v[3]==null?{}:v[3],!(I in s)){o(g,y);return}let E=s[I];if(E.inboundNodes.length<=T){o(g,y);return}let A=E.inboundNodes[T];b.push(A.outputTensors[_])}b.length>0&&g.apply(Sn(b),x)}function p(g){let y=g.name,b=vr(g,n.customObjects!=null?n.customObjects:{});b.setFastWeightInitDuringBuild(a),s[y]=b,g.inboundNodes.forEach(x=>{if(!(x instanceof Array))throw new V(`Corrupted configuration, expected array for nodeData: ${x}`);o(b,x)})}let u=n.name,d=n.layers;for(let g of d)p(g);for(;!HB(i);)for(let g of d){let y=s[g.name];if(y.name in i){let b=i[y.name];delete i[y.name];for(let x of b)l(y,x)}}let h=[],c=[],f=n.inputLayers;for(let g of f){let y=g[0],b=g[1],x=g[2];Or(y in s);let v=s[y].inboundNodes[b].outputTensors;h.push(v[x])}let m=n.outputLayers;for(let g of m){let y=g[0],b=g[1],x=g[2];Or(y in s);let v=s[y].inboundNodes[b].outputTensors;c.push(v[x])}return new t({inputs:h,outputs:c,name:u})}get stateful(){if(this._stateful)throw new V("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let t of this.layers)if(t.stateful)return!0;return!1}resetStates(){B(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}};function k4(e,t,n){let r=t.length;if(e==null||Array.isArray(e)&&e.length===0)return t.map(a=>null);if(r===1)return Array.isArray(e)&&e.length===1?e:typeof e=="object"&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}else if(typeof e=="object"&&Object.keys(e).length>0&&typeof e[Object.keys(e)[0]]=="object"){let a=[];return t.forEach(s=>{s in e?a.push(e[s]):a.push(null)}),a}else throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}function FI(e,t){return k4(e,t,"classWeight")}async function RI(e,t,n,r){if(n!=null){let a=B(()=>{if(e.shape.length===1)return Br(e);if(e.shape.length===2){if(e.shape[1]>1)return Ps(e,1);if(e.shape[1]===1)return P(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(await a.data());_e(a);let i=[];return s.forEach(o=>{if(n[o]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${o} exists in the data but not in classWeight`);i.push(n[o])}),Ye(i,"float32")}else return null}function I4(e,t){return z(e,t)}var S4=32;function DI(e,t){let n,r,a=t;n=a.xs,r=a.ys,w.assert(n!=null&&r!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);let s=fw("input",e.inputNames,n),i=fw("output",e.outputNames,r),o=s[0].shape[0];w.assert(s.length===e.inputs.length,()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`),w.assert(i.length===e.outputs.length,()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`);for(let l=0;l<s.length;l++)w.assert(s[l].shape[0]===o,()=>`Batch size mismatch: input ${e.inputNames[l]} has ${s[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);for(let l=0;l<i.length;l++)w.assert(i[l].shape[0]===o,()=>`Batch size mismatch: output ${e.outputNames[l]} has ${i[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);return{xs:s,ys:i}}function fw(e,t,n){if(n instanceof Fe)return[n];if(Array.isArray(n))return w.assert(n.length===t.length,()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`),n;{let r=[];for(let a of t){if(n[a]==null)throw new V(`The feature data generated by the dataset lacks the required ${e} key '${a}'.`);r.push(n[a])}return r}}function N4(e){if(e.length===3)throw new Be("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}async function T4(e,t,n){let r=n.batchesPerEpoch!=null;if(w.assert(e.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),w.assert(n!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),w.assert(n.epochs!=null&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),w.assert(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),w.assert(n.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{let a=n.validationData!=null,s,i;if(a)if(mw(n.validationData))w.assert(n.validationBatches==null||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{let g=N4(n.validationData);s=g.xs,i=g.ys}let o=e.makeTrainFunction(),l=e.getDedupedMetricsNames(),p;a?p=l.slice().concat(l.map(g=>"val_"+g)):p=l.slice();let u=SI(n.callbacks,n.yieldEvery),d=n.verbose==null?1:n.verbose,{callbackList:h,history:c}=NI(u,d,n.epochs,null,null,C4(t,n),null,a,p);h.setModel(e),e.history=c,await h.onTrainBegin(),e.stopTraining_=!1;let f=n.initialEpoch==null?0:n.initialEpoch,m=await t.iterator();for(;f<n.epochs;){let g={};await h.onEpochBegin(f);let y=0,b=0;for(r||(m=await t.iterator());!r||y<n.batchesPerEpoch;){let x=await m.next();if(r&&x.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(x.value!=null){let{xs:v,ys:I}=DI(e,x.value),T={};T.batch=b,T.size=v[0].shape[0],await h.onBatchBegin(b,T);let _=[];if(n.classWeight!=null){let R=FI(n.classWeight,e.outputNames);for(let F=0;F<R.length;++F)_.push(await RI(I[F],null,R[F]))}let E=v.concat(I).concat(_),A=o(E);_e(E);for(let R=0;R<l.length;++R){let F=l[R],S=A[R];T[F]=S,Mt(S)}await h.onBatchEnd(b,T),vI(T),b++,y++}if(r?y>=n.batchesPerEpoch:x.done){if(a){let v;mw(n.validationData)?v=Qe(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):v=Qe(e.evaluate(s,i,{batchSize:n.validationBatchSize==null?S4:n.validationBatchSize,verbose:0}));for(let I=0;I<e.metricsNames.length;++I)g[`val_${e.metricsNames[I]}`]=v[I]}break}if(e.stopTraining_)break}if(await h.onEpochEnd(f,g),f++,e.stopTraining_)break}return await h.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function C4(e,t){let n=null;return t.batchesPerEpoch!=null?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}function mw(e){return typeof e.iterator=="function"}function _4(e){return typeof e.next=="function"}async function E4(e,t,n){n=n||{};let r=n.batches!=null,a=e.testFunction,s=[];if(n.verbose>0)throw new Be("Verbose mode is not implemented yet.");w.assert(!r||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);let i=_4(t)?t:await t.iterator(),o=0,l=0;for(;!r||l<n.batches;){let p=await i.next();if(s=B(()=>{if(p.value){let{xs:u,ys:d}=DI(e,p.value),h=u.concat(d),c=B(()=>a(h));if(_e(h),l===0)for(let m=0;m<c.length;++m)s.push(we(0));let f=h[0].shape[0];for(let m=0;m<c.length;++m){let g=c[m],y=s[m];s[m]=B(()=>X(s[m],z(f,g))),l>0&&_e(y)}_e(c),o+=f,++l}return s}),p.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let p=0;p<s.length;++p){let u=s[p];s[p]=fe(s[p],o),_e(u)}return Sn(s)}function Lf(e){w.assert(e>0&&Number.isInteger(e),()=>`batchSize is required to be a positive integer, but got ${e}`)}function zu(e,t,n){return e==null?[null]:Array.isArray(e)?e.map(r=>$s(r,t,n-t)):$s(e,t,n-t)}function vm(e,t){return B(()=>e==null?null:Array.isArray(e)?e.map(n=>vm(n,t)):dI(e,t.dtype==="int32"?t:se(t,"int32")))}function zf(e,t){let n=[],r=0,a=null;for(;r<e;)a=r+t,a>=e&&(a=e),n.push([r,a]),r=a;return n}function MI(e){let t=[];e instanceof Fe&&(e=[e]);for(let n=0;n<e.length;++n){let r=e[n];if(r.rank===1)t.push(dd(r,1));else{if(r.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function mr(e,t){if(e==null)return;let n=[];if(t instanceof Fe)n.push(t.id);else if(Array.isArray(t))t.forEach(a=>n.push(a.id));else if(t!=null)for(let a in t){let s=t[a];n.push(s.id)}let r=[];if(e instanceof Fe)n.indexOf(e.id)===-1&&r.push(e);else if(Array.isArray(e))e.forEach(a=>{n.indexOf(a.id)===-1&&r.push(a)});else if(e!=null)for(let a in e){let s=e[a];n.indexOf(s.id)===-1&&r.push(s)}r.forEach(a=>{a.isDisposed||a.dispose()})}function $4(e){return e instanceof Fe}function wm(e){return Array.isArray(e)}function gw(e){return!$4(e)&&!wm(e)}function yw(e,t,n,r=!0,a=""){if(t==null||t.length===0){if(e!=null){let i=!1;if(wm(e)&&e.length>0)i=!0;else if(gw(e)){for(let o in e)if(e.hasOwnProperty(o)){i=!0;break}}else i=!0;if(i)throw new V(`Error when checking model ${a} expected no data, but got ${e}`)}return[]}if(e==null)return t.map(i=>null);let s;if(gw(e)){e=e,s=[];for(let i of t){if(e[i]==null)throw new V(`No data provided for "${i}". Need data for each key in: ${t}`);s.push(e[i])}}else if(wm(e)){if(e=e,e.length!==t.length)throw new V(`Error when checking model ${a}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);s=e}else{if(e=e,t.length>1)throw new V(`The model ${a} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);s=[e]}if(s=MI(s),n!=null)for(let i=0;i<t.length;++i){if(n[i]==null)continue;let o=s[i];if(o.shape.length!==n[i].length)throw new V(`Error when checking ${a}: expected ${t[i]} to have ${n[i].length} dimension(s). but got array with shape ${o.shape}`);for(let l=0;l<n[i].length;++l){if(l===0&&!r)continue;let p=o.shape[l],u=n[i][l];if(u!=null&&u>=0&&p!==u)throw new V(`${a} expected a batch of elements where each example has shape [${n[i].slice(1,n[i].length)}] (i.e.,tensor shape [*,${n[i].slice(1,n[i].length)}]) but the ${a} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return s}function A4(e,t,n){let r=Da(e.map(s=>s.shape[0]));r.sort();let a=Da(t.map(s=>s.shape[0]));if(a.sort(),r.length>1)throw new V(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(s=>s.shape))}`);if(a.length>1)throw new V(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(s=>s.shape))}`);if(r.length>0&&a.length>0&&!w.arraysEqual(r,a))throw new V(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${a[0]} target sample(s).`)}function F4(e,t,n){let r=[Io,tf,hp];for(let a=0;a<e.length;++a){let s=e[a],i=t[a],o=n[a];if(i!=null){if(i===hp&&s.shape[s.shape.length-1]===1)throw new V(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(r.indexOf(i)!==-1){let l=s.shape.slice(1),p=o.slice(1);for(let u=0;u<l.length;++u){let d=l[u],h=p[u];if(h!=null&&d!==h)throw new V(`A target Tensor with shape ${s.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function bw(e,t,n,r=!0,a=""){let s;if(Array.isArray(e)){if(e.length!==t.length)throw new V(`Error when checking model ${a}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);s=e}else{if(t.length>1)throw new V(`The model expects ${t.length} ${a} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);s=[e]}if(n!=null)for(let i=0;i<t.length;++i){if(n[i]==null)continue;let o=s[i];if(o.shape.length!==n[i].length)throw new V(`Error when checking ${a}: expected ${t[i]} to have ${n[i].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let l=0;l<n[i].length;++l){if(l===0&&!r)continue;let p=o.shape[l],u=n[i][l];if(u!=null&&u!==p)throw new V(`Error when checking ${a}: expected ${t[i]} to have shape ${JSON.stringify(n[i])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}function R4(e,t){if(e==null||Array.isArray(e)&&e.length===0)return t.map(r=>[]);let n;if(typeof e=="string"||typeof e=="function")n=[e];else if(Array.isArray(e)||typeof e=="object")n=e;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);if(Array.isArray(n))return t.map(r=>n);{let r=[];for(let a of t){let s=n.hasOwnProperty(a)?n[a]:[];Array.isArray(s)||(s=[s]),r.push(s)}return r}}var D4="layers-model",ia=class extends w4{constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new V("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");m4(this,e,t,n)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=f4(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof ma))throw new V("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(let s in e.loss)if(this.outputNames.indexOf(s)===-1)throw new V(`Unknown entry in loss dictionary: "${s}". Only expected the following keys: ${this.outputNames}`);for(let s of this.outputNames)e.loss[s]==null&&console.warn(`Output "${s}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${s} during training`),t.push(Of(e.loss[s]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new V(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(s=>Of(s))}else{let s=Of(e.loss);this.outputs.forEach(i=>{t.push(s)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let s=0;s<this.outputs.length;++s){let i=this.internalOutputShapes[s],o=this.outputNames[s];this.feedOutputNames.push(o),this.feedOutputShapes.push(i),this.feedLossFns.push(this.lossFunctions[s])}let n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Es("loss",()=>{for(let s=0;s<this.outputs.length;++s){if(n.indexOf(s)!==-1)continue;let i=this.lossFunctions[s];this.outputs.length>1&&(this.metricsTensors.push([i,s]),this.metricsNames.push(this.outputNames[s]+"_loss"))}});let r=R4(e.metrics,this.outputNames),a=(s,i,o)=>{this.outputNames.length>1&&(i=this.outputNames[s]+"_"+i),this.metricsNames.push(i),this.metricsTensors.push([o,s])};Es("metric",()=>{for(let s=0;s<this.outputs.length;++s){if(n.indexOf(s)!==-1)continue;let i=r[s];(o=>{let l="",p,u,d;for(let h of o){if(typeof h=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(h)!==-1){let f=this.internalOutputShapes[s];f[f.length-1]===1||this.lossFunctions[s]===tf?["accuracy","acc"].indexOf(h)!==-1?u=Xy:["crossentropy","ce"].indexOf(h)!==-1&&(u=_I):this.lossFunctions[s]===Th?["accuracy","acc"].indexOf(h)!==-1?u=EI:["crossentropy","ce"].indexOf(h)!==-1&&(u=$I):["accuracy","acc"].indexOf(h)!==-1?u=Zy:["crossentropy","ce"].indexOf(h)!==-1&&(u=Jy);let m;["accuracy","acc"].indexOf(h)!==-1?m="acc":["crossentropy","ce"].indexOf(h)!==-1&&(m="ce"),d=u,p=l+m}else d=c4(h),p=l+jd(h);let c;Es(p,()=>{c=d}),a(s,p,c)}})(i)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){let r=n.batchSize==null?32:n.batchSize;Lf(r);let a=this.standardizeUserDataXY(e,t,!0,r);try{let s=a[0].concat(a[1]);this.makeTestFunction();let i=this.testFunction,o=this.testLoop(i,s,r,n.verbose,n.steps);return Sn(o)}finally{mr(a[0],e),mr(a[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),E4(this,e,t)}checkNumSamples(e,t,n,r="steps"){let a;if(n!=null){if(a=null,t!=null)throw new V(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?a=e[0].shape[0]:a=e.shape[0];else throw new V(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return a}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new V("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(t),r=n?t:[t],a=this.retrieveSymbolicTensors(r),s=new Po;if(e instanceof Fe&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new V(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let o=0;o<this.inputs.length;++o)s.add(this.inputs[o],e[o])}else for(let o of this.inputs){let l=e[o.name];if(l==null)throw new V(`No value is provided for the model's input ${o.name}`);s.add(o,l)}let i=Gu(a,s);return n?i:i[0]}retrieveSymbolicTensors(e){let t=Gs(null,e.length),n=e.length;for(let r of this.layers){let a=Array.isArray(r.output)?r.output:[r.output],s=a.map(i=>i.name);for(let i=0;i<e.length;++i){let o=s.indexOf(e[i]);if(o!==-1&&(t[i]=a[o],n--),n===0)break}if(n===0)break}if(n>0){let r=[];throw t.forEach((a,s)=>{a==null&&r.push(e[s])}),new V(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return t}predictLoop(e,t=32,n=!1){return B(()=>{let r=this.checkNumSamples(e);if(n)throw new Be("Verbose predictLoop() is not implemented yet.");let a=zf(r,t),s=this.outputs.map(i=>[]);for(let i=0;i<a.length;++i)B(()=>{let o=a[i][0],l=a[i][1],p=zu(e,o,l),u=[];if(Array.isArray(p))for(let h=0;h<p.length;++h)u.push({key:this.inputs[h],value:p[h]});else u.push({key:this.inputs[0],value:p});let d=new Po(u);return Gu(this.outputs,d)}).forEach((o,l)=>s[l].push(o));return Sn(s.map(i=>it(i,0)))})}predict(e,t={}){let n=MI(e);bw(n,this.inputNames,this.feedInputShapes,!1);try{let r=t.batchSize==null?32:t.batchSize;return Lf(r),this.predictLoop(n,r)}finally{mr(n,e)}}predictOnBatch(e){bw(e,this.inputNames,this.feedInputShapes,!0);let t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,r){if(this.optimizer_==null)throw new zr("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let a=[];for(let s=0;s<this.feedOutputShapes.length;++s){let i=this.feedOutputShapes[s];this.feedLossFns[s]===Th?a.push(i.slice(0,i.length-1).concat([1])):a.push(i)}if(e=yw(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=yw(t,this.feedOutputNames,a,!1,"target"),A4(e,t),F4(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&e[0].shape[0]%r!==0)throw new V(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,r,a=!0,s){let[i,o]=this.standardizeUserDataXY(e,t,a,s);if(n!=null)throw new Error("sample weight is not supported yet.");let l=null;if(r!=null){let p=FI(r,this.outputNames);l=[];for(let u=0;u<p.length;++u)l.push(await RI(o[u],null,p[u]))}return[i,o,l]}testLoop(e,t,n,r=0,a){return B(()=>{let s=this.checkNumSamples(t,n,a,"steps"),i=[];if(r>0)throw new Be("Verbose mode is not implemented yet.");if(a!=null)throw new Be("steps mode in testLoop() is not implemented yet");{let o=zf(s,n),l=Ye(Ir(0,s));for(let p=0;p<o.length;++p){let u=o[p][0],d=o[p][1],h=$s(l,u,d-u),c=vm(t,h),f=e(c);if(p===0)for(let m=0;m<f.length;++m)i.push(we(0));for(let m=0;m<f.length;++m){let g=f[m];i[m]=X(i[m],z(d-u,g))}}for(let p=0;p<i.length;++p)i[p]=fe(i[p],s)}return i})}getDedupedMetricsNames(){let e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){let r=e[n],a=r;if(rw(e,r)>1){let s=rw(e.slice(0,n),r);a+=`_${s}`}t.push(a)}return t}makeTrainFunction(){return e=>{let t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),s=[],i=()=>{let l=[];for(let h=0;h<this.inputs.length;++h)l.push({key:this.inputs[h],value:n[h]});let p=new Po(l),u=Gu(this.outputs,p,{training:!0}),d;for(let h=0;h<this.lossFunctions.length;++h){let c=this.lossFunctions[h],f=c(r[h],u[h]);a[h]!=null&&(f=I4(f,a[h]));let m=xt(f);t.push(m),h===0?d=f:d=X(d,f)}for(let h=0;h<this.metricsTensors.length;++h){let c;if(this.outputs.length>1&&h<this.outputs.length)c=t[h];else{let f=this.metricsTensors[h][0],m=this.metricsTensors[h][1];c=xt(f(r[m],u[m]))}Mt(c),s.push(c)}return d=xt(d),this.calculateLosses().forEach(h=>{d=X(d,h)}),d},o=this.collectedTrainableWeights.map(l=>l.read());return[this.optimizer_.minimize(i,!0,o)].concat(s)}}makeTestFunction(){this.testFunction=e=>B(()=>{let t=[],n,r=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=[];for(let l=0;l<this.inputs.length;++l)s.push({key:this.inputs[l],value:r[l]});let i=new Po(s),o=Gu(this.outputs,i);for(let l=0;l<this.lossFunctions.length;++l){let p=this.lossFunctions[l],u=xt(p(a[l],o[l]));l===0?n=u:n=X(n,u),t.push(n)}for(let l=0;l<this.metricsTensors.length;++l){let p=this.metricsTensors[l][0],u=this.metricsTensors[l][1],d=xt(p(a[u],o[u]));t.push(d)}return t})}async fit(e,t,n={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let r,a,s,i,o,l,p,u,d;try{let h=n.batchSize==null?32:n.batchSize;Lf(h);let c=await this.standardizeUserData(e,t,n.sampleWeight,n.classWeight,!1,h);r=c[0],a=c[1],d=c[2];let f=!1,m;if(n.validationData!=null&&n.validationData.length>0){if(f=!0,n.validationData.length===2)o=n.validationData[0],l=n.validationData[1];else throw n.validationData.length===3?new Be("validationData including sample weights is not supported yet."):new V(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);let T=await this.standardizeUserData(o,l,null,null,!0,h);p=T[0],u=T[1],m=p.concat(u)}else if(n.validationSplit!=null&&n.validationSplit>0&&n.validationSplit<1){f=!0;let T=Math.floor(r[0].shape[0]*(1-n.validationSplit)),_=r[0].shape[0];p=zu(r,T,_),s=r,r=zu(r,0,T),u=zu(a,T,_),i=a,a=zu(a,0,T),m=p.concat(u)}else n.validationSteps!=null&&(f=!0);let g=r.concat(a).concat(d);this.checkTrainableWeightsConsistency();let y=this.makeTrainFunction(),b=this.getDedupedMetricsNames(),x,v;f?(this.makeTestFunction(),x=this.testFunction,v=b.slice().concat(b.map(T=>"val_"+T))):(x=null,m=[],v=b.slice());let I=SI(n.callbacks,n.yieldEvery);return await this.fitLoop(y,g,b,h,n.epochs,n.verbose,I,x,m,n.shuffle,v,n.initialEpoch,null,null)}finally{this.isTraining=!1,mr(r,e),mr(a,t),mr(s,e),mr(i,t),mr(p,o),mr(u,l),d!=null&&_e(d)}}async fitLoop(e,t,n,r,a,s,i,o,l,p,u,d,h,c){r==null&&(r=32),a==null&&(a=1),p==null&&(p=!0),d==null&&(d=0);let f=!1;if(o!=null&&l!=null&&(f=!0),c!=null&&(f=!0,h==null))throw new V("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let m=this.checkNumSamples(t,r,h,"steps_per_epoch"),g;m!=null&&(g=Ir(0,m)),s==null&&(s=1);let{callbackList:y,history:b}=NI(i,s,a,d,m,h,r,f,u);y.setModel(this),this.history=b,await y.onTrainBegin(),this.stopTraining_=!1;for(let x=d;x<a;++x){await y.onEpochBegin(x);let v={};if(h!=null)throw new Be("stepsPerEpoch mode is not implemented yet.");{if(p==="batch")throw new Be("batch shuffling is not implemneted yet");p&&w.shuffle(g);let I=Ye(g),T=zf(m,r);for(let _=0;_<T.length;++_){let E={};if(await y.onBatchBegin(_,E),B(()=>{let A=T[_][0],R=T[_][1],F=$s(I,A,R-A);E.batch=_,E.size=R-A;let S=vm(t,F),M=e(S);for(let W=0;W<n.length;++W){let U=n[W],H=M[W];E[U]=H,Mt(H)}if(_===T.length-1&&f){let W=this.testLoop(o,l,r);for(let U=0;U<n.length;++U){let H=n[U],K=W[U];Mt(K),v["val_"+H]=K}}}),await y.onBatchEnd(_,E),vI(E),this.stopTraining_)break}I.dispose()}if(await y.onEpochEnd(x,v),this.stopTraining_)break}return await y.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return T4(this,e,t)}async trainOnBatch(e,t){let n=await this.standardizeUserData(e,t),r=n[0],a=n[1],s=this.makeTrainFunction()(r.concat(a)),i=[];for(let o of s){let l=await o.data();i.push(l[0])}return _e(s),mr(n[0],e),mr(n[1],t),Sn(i)}getNamedWeights(e){let t=[],n=e!=null&&e.trainableOnly,r=n?this.trainableWeights:this.weights,a=this.getWeights(n);for(let s=0;s<r.length;++s)n&&!r[s].trainable||t.push({name:r[s].originalName,tensor:a[s]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let t=nm().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-nm().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=ta(this.loss);else if(Array.isArray(this.loss)){for(let t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>ta(t))}else{let t=Object.keys(this.loss);e={};let n=this.loss;for(let r of t)if(typeof n[r]=="string")e[r]=ta(n[r]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[ta(jd(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>ta(jd(e)));{let e={};for(let t in this.metrics)e[t]=ta(jd(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");let t=cp(e.optimizer_config),n=vr(t),r;if(typeof e.loss=="string")r=Is(e.loss);else if(Array.isArray(e.loss))r=e.loss.map(s=>Is(s));else if(e.loss!=null){r={};for(let s in e.loss)r[s]=Is(e.loss[s])}let a;if(Array.isArray(e.metrics))a=e.metrics.map(s=>Is(s));else if(e.metrics!=null){a={};for(let s in e.metrics)a[s]=Is(e.metrics[s])}this.compile({loss:r,metrics:a,optimizer:n})}async save(e,t){if(typeof e=="string"){let a=nn.getSaveHandlers(e);if(a.length===0)throw new V(`Cannot find any save handlers for URL '${e}'`);if(a.length>1)throw new V(`Found more than one (${a.length}) save handlers for URL '${e}'`);e=a[0]}if(e.save==null)throw new V("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let n=await nn.encodeWeights(this.getNamedWeights(t)),r={modelTopology:this.toJSON(null,!1),format:D4,generatedBy:`TensorFlow.js tfjs-layers v${Yy}`,convertedBy:null};if(t!=null&&t.includeOptimizer&&this.optimizer!=null){r.trainingConfig=this.getTrainingConfig();let a="optimizer",{data:s,specs:i}=await nn.encodeWeights(await this.optimizer.getWeights(),a);n.specs.push(...i),n.data=nn.concatenateArrayBuffers([n.data,s])}return this.userDefinedMetadata!=null&&(cw(this.userDefinedMetadata,this.name,!0),r.userDefinedMetadata=this.userDefinedMetadata),r.weightData=n.data,r.weightSpecs=n.specs,e.save(r)}setUserDefinedMetadata(e){cw(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}};ia.className="Model";ne.registerClass(ia);var OI=class extends ia{};OI.className="Functional";ne.registerClass(OI);async function M4(e,t){"modelTopology"in e||(e={modelTopology:e}),e=e;let n=e.modelTopology;n.model_config!=null&&(n=n.model_config);let r=cp(n),a=vr(r,t);if(e.weightsManifest!=null){let s=await nn.loadWeights(e.weightsManifest,e.pathPrefix,a.weights.map(o=>o.originalName)),i={};for(let o of a.weights)i[o.originalName]=s[o.originalName];a.loadWeights(i),_e(s)}return a}async function O4(e,t){if(t==null&&(t={}),typeof e=="string"){let n=nn.getLoadHandlers(e,t);if(n.length===0)n.push(nn.browserHTTPRequest(e,t));else if(n.length>1)throw new V(`Found more than one (${n.length}) load handlers for URL '${e}'`);e=n[0]}return L4(e,void 0,t)}async function L4(e,t,n){if(n==null&&(n={}),e.load==null)throw new V("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let r=await e.load(),a=r.modelTopology;a.model_config!=null&&(a=a.model_config);let s=n.strict==null?!0:n.strict,i=r.weightData!=null&&r.weightSpecs!=null&&s,o=vr(cp(a),t,i),l=r.trainingConfig;if(l!=null&&o.loadTrainingConfig(l),r.userDefinedMetadata!=null&&o.setUserDefinedMetadata(r.userDefinedMetadata),r.weightData!=null){if(r.weightSpecs==null)throw new V("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:p,optimizerWeights:u}=z4(r.weightData,r.weightSpecs);o.loadWeights(p,s),o.optimizer!=null&&u.length>0&&await o.optimizer.setWeights(u),_e(p),_e(u.map(d=>d.tensor))}return o}function z4(e,t){let n=nn.decodeWeights(e,t),r={},a=[];return t.forEach(s=>{s.group==="optimizer"?a.push({name:s.name,tensor:n[s.name]}):r[s.name]=n[s.name]}),{modelWeights:r,optimizerWeights:a}}var nf=class km extends ia{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:Gc("sequential_"),t.layers!=null)for(let n of t.layers)this.add(n)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(n=>n<0))throw new V(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){let n=t instanceof km||t instanceof ia,r;if(n){if(r=t,r.outputs.length!==1)throw new V("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(r.inputs.length!==1)throw new V("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new V("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let a=mI({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(a)}if(n)this.outputs=r.outputs,this.inputs=r.inputs;else{if(t.inboundNodes.length!==1)throw new V(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new V("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=fI(this.outputs[0])}this.inboundNodes=[],new Qc({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Gs(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(a=>a.shape),outputShapes:this.outputs[0].shape})}else{let a=t.apply(this.outputs[0]);if(Array.isArray(a))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[a],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,n){return this.model==null&&this.build(),this.model.call(t,n)}build(t){if(Xe(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new ia({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,n,r=console.log){this.built||this.build(),super.summary(t,n,r)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,n,r={}){if(!this.built)throw new zr("The model needs to be compiled before being used.");return this.model.evaluate(t,n,r)}async evaluateDataset(t,n){if(!this.built)throw new zr("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,n)}predict(t,n={}){return this.model==null&&this.build(),this.model.predict(t,n)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,n,r={}){if(!this.built)throw new zr("The model needs to be compiled before being used.");return this.model.fit(t,n,r)}async fitDataset(t,n){if(!this.built)throw new zr("The model needs to be compiled before being used.");return this.model.fitDataset(t,n)}async trainOnBatch(t,n){return this.model.trainOnBatch(t,n)}static fromConfig(t,n,r={},a=!1){let s,i={};if(n instanceof Array){if(n[0].className==null||n[0].className==="Merge")throw new V("Legacy serialization format not supported yet.");s=n}else w.assert(n.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),s=n.layers,delete n.layers,i=n;let o=new t(i);if(!(o instanceof km))throw new Be(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(let l of s){let p=vr(l,void 0,a);a&&p.setFastWeightInitDuringBuild(!0),o.add(p)}return o}set stopTraining(t){if(this.model==null)throw new V("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new V("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let t=[];for(let n of this.layers){let r={};r.className=n.getClassName(),r.config=n.getConfig(),t.push(r)}return{name:this.name,layers:t}}};nf.className="Sequential";ne.registerClass(nf);function P4(e){return new ia(e)}function B4(e){return new nf(e)}function LI(e){return mI(e)}function W4(e,t){qy.registerCallbackConstructor(e,t)}var on=class extends ne.Serializable{getConfig(){return{}}},zI=class extends on{apply(e,t=1){return iW(e,t)}};zI.className="elu";ne.registerClass(zI);var PI=class extends on{apply(e){return Cc(e)}};PI.className="selu";ne.registerClass(PI);var BI=class extends on{apply(e){return et(e)}};BI.className="relu";ne.registerClass(BI);var WI=class extends on{apply(e){return B(()=>Va(6,et(e)))}};WI.className="relu6";ne.registerClass(WI);var VI=class extends on{apply(e){return e}};VI.className="linear";ne.registerClass(VI);var UI=class extends on{apply(e){return pr(e)}};UI.className="sigmoid";ne.registerClass(UI);var GI=class extends on{apply(e){return lW(e)}};GI.className="hardSigmoid";ne.registerClass(GI);var HI=class extends on{apply(e){return vo(e)}};HI.className="softplus";ne.registerClass(HI);var jI=class extends on{apply(e){return oW(e)}};jI.className="softsign";ne.registerClass(jI);var qI=class extends on{apply(e){return Wa(e)}};qI.className="tanh";ne.registerClass(qI);var Qy=class extends on{apply(e,t=-1){return ss(e,t)}};Qy.className="softmax";ne.registerClass(Qy);var KI=class extends on{apply(e,t=-1){return vc(e,t)}};KI.className="logSoftmax";ne.registerClass(KI);var XI=class extends on{apply(e){return B(()=>B(()=>{let t=Math.sqrt(2),n=z(.5,X(1,yc(fe(e,t))));return z(e,n)}))}};XI.className="gelu";ne.registerClass(XI);var ZI=class extends on{apply(e){return B(()=>z(.5,z(e,X(1,Wa(z(Kt(fe(2,Math.PI)),X(e,z(.044715,Gr(e,3)))))))))}};ZI.className="gelu_new";ne.registerClass(ZI);var JI=class extends on{apply(e){return B(()=>z(e,Wa(vo(e))))}};JI.className="mish";ne.registerClass(JI);var YI=class extends on{apply(e,t=1){return B(()=>z(pr(z(e,t)),e))}};YI.className="swish";ne.registerClass(YI);function Ha(e){return e.getClassName()}function Pf(e,t={}){return pd(e,ne.SerializationMap.getMap().classNameMap,t,"activation")}function ja(e){if(e==null){let t={};return t.className="linear",t.config={},Pf(t)}if(typeof e=="string"){let t={};return t.className=e,t.config={},Pf(t)}else return e instanceof on?e:Pf(e)}function eb(e){if(e!=null&&typeof e!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}var QI=class extends ne.Serializable{},md=class extends QI{constructor(e){super(),eb(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return B(()=>{let t=vt([1]);return this.hasL1&&(t=X(t,ge(z(this.l1,_t(e))))),this.hasL2&&(t=X(t,ge(z(this.l2,hd(e))))),P(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}};md.className="L1L2";ne.registerClass(md);function V4(e){return eb(e),new md({l1:e!=null?e.l1:null,l2:0})}function U4(e){return eb(e),new md({l2:e!=null?e.l2:null,l1:0})}var xw={l1l2:"L1L2"};function ut(e){return Ay(e)}function vw(e,t={}){return pd(e,ne.SerializationMap.getMap().classNameMap,t,"regularizer")}function yt(e){if(e==null)return null;if(typeof e=="string"){let t={className:e in xw?xw[e]:e,config:{}};return vw(t)}else return e instanceof QI?e:vw(e)}var tb=class extends We{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=Ce(e);let n=et(e);return this.maxValue!=null&&(n=an(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}};tb.className="ReLU";ne.registerClass(tb);var nb=class extends We{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Ce(e);return Qp(n,this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};nb.className="LeakyReLU";ne.registerClass(nb);var rb=class extends We{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=gt(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=yt(e.alphaRegularizer),this.alphaConstraint=Pt(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new V(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=Xe(e);let t=e.slice(1);if(this.sharedAxes!=null)for(let r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(this.sharedAxes!=null)for(let r=1;r<e.length;++r)n[r]=e[r];this.inputSpec=[new Et({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=Ce(e),sd(e,this.alpha.read())}getConfig(){let e={alphaInitializer:wt(this.alphaInitializer),alphaRegularizer:ut(this.alphaRegularizer),alphaConstraint:zt(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}};rb.className="PReLU";ne.registerClass(rb);var ab=class extends We{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new Be(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Ce(e);return cu(n)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};ab.className="ELU";ne.registerClass(ab);var sb=class extends We{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){let n=Ce(e);return z(n,se(xn(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}};sb.className="ThresholdedReLU";ne.registerClass(sb);var ib=class extends We{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new Qy().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){return B(()=>{let n=Ce(e),r=t.mask;if(r!=null){let a=z(de(Nn(n.shape),se(r,n.dtype)),we(-1e9));n=X(n,a)}return this.axis instanceof Array?this.axis.length>1?sn(de(n,td(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)})}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};ib.className="Softmax";ne.registerClass(ib);function Uo(e,t,n){if(typeof e=="number")return Gs(e,t);if(e.length!==t)throw new V(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let r=0;r<t;++r){let a=e[r];if(!nW(a))throw new V(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${a}`)}return e}function wr(e,t,n,r,a=1){if(e==null)return e;let s=t+(t-1)*(a-1),i;return n==="same"?i=e:i=e-s+1,Math.floor((i+r-1)/r)}function Lr(e,t,n,r){if(e==null)return null;if(r==="valid")e=e*t+Ga([n-t,0]);else if(r==="same")e=e*t;else throw new V(`Unsupport padding mode: ${r}.`);return e}function ob(e,t){return B(()=>(Nt(t),t==="channelsFirst"?Le(e,[0,2,3,1]):e))}function eS(e,t){return B(()=>(Nt(t),t==="channelsFirst"?Le(e,[0,2,3,4,1]):e))}function G4(e,t,n,r=1,a="valid",s,i=1){return B(()=>{if(s==null&&(s=Sr()),Nt(s),e.shape.length!==3)throw new V(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(t.shape.length!==3)throw new V(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(n!=null&&n.shape.length!==1)throw new V(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if(s==="channelsFirst"&&(e=Le(e,[0,2,1])),a==="causal")throw new Be("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=cc(e,t,r,a==="same"?"same":"valid","NWC",i);return n!=null&&(o=Er(o,n)),o})}function ww(e,t,n,r=[1,1],a="valid",s,i,o=null){return B(()=>{if(s==null&&(s=Sr()),Nt(s),e.rank!==3&&e.rank!==4)throw new V(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(t.rank!==3&&t.rank!==4)throw new V(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=ob(e,s);if(a==="causal")throw new Be("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=tl.conv2d({x:l,filter:t,strides:r,pad:a==="same"?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),s==="channelsFirst"&&(l=Le(l,[0,3,1,2])),l})}function H4(e,t,n,r=[1,1,1],a="valid",s,i){return B(()=>{if(s==null&&(s=Sr()),Nt(s),e.rank!==4&&e.rank!==5)throw new V(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(t.rank!==4&&t.rank!==5)throw new V(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=eS(e,s);if(a==="causal")throw new Be("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=Mg(o,t,r,a==="same"?"same":"valid","NDHWC",i),n!=null&&(o=Er(o,n)),s==="channelsFirst"&&(o=Le(o,[0,4,1,2,3])),o})}var tS=class nS extends We{constructor(t,n){if(super(n),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",nS.verifyArgs(n),this.rank=t,jt(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Be(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Uo(n.kernelSize,t,"kernelSize"),this.strides=Uo(n.strides==null?1:n.strides,t,"strides"),this.padding=n.padding==null?"valid":n.padding,ar(this.padding),this.dataFormat=n.dataFormat==null?"channelsLast":n.dataFormat,Nt(this.dataFormat),this.activation=ja(n.activation),this.useBias=n.useBias==null?!0:n.useBias,this.biasInitializer=gt(n.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Pt(n.biasConstraint),this.biasRegularizer=yt(n.biasRegularizer),this.activityRegularizer=yt(n.activityRegularizer),this.dilationRate=Uo(n.dilationRate==null?1:n.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new V(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new V(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new V(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(Or("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!Fy(t.kernelSize,"number",1,3))throw new V(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){let t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Ha(this.activation),useBias:this.useBias,biasInitializer:wt(this.biasInitializer),biasRegularizer:ut(this.biasRegularizer),activityRegularizer:ut(this.activityRegularizer),biasConstraint:zt(this.biasConstraint)},n=super.getConfig();return Object.assign(t,n),t}},rf=class rS extends tS{constructor(t,n){super(t,n),this.kernel=null,rS.verifyArgs(n),this.filters=n.filters,jt(this.filters,"filters"),this.kernelInitializer=gt(n.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Pt(n.kernelConstraint),this.kernelRegularizer=yt(n.kernelRegularizer)}build(t){t=Xe(t);let n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null)throw new V(`The channel dimension of the input should be defined. Found ${t[n]}`);let r=t[n],a=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[n]:r}}],this.built=!0}call(t,n){return B(()=>{t=Ce(t);let r,a=this.bias==null?null:this.bias.read(),s=sI(this.activation.getClassName());if(s!=null&&this.rank===2)r=ww(t,this.kernel.read(),a,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(this.rank===1)r=G4(t,this.kernel.read(),a,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)r=ww(t,this.kernel.read(),a,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)r=H4(t,this.kernel.read(),a,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Be("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(r=this.activation.apply(r))}return r})}computeOutputShape(t){t=Xe(t);let n=[],r=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let s=0;s<r.length;++s){let i=wr(r[s],this.kernelSize[s],this.padding,this.strides[s],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[s]);n.push(i)}let a=[t[0]];return this.dataFormat==="channelsLast"?(a=a.concat(n),a.push(this.filters)):(a.push(this.filters),a=a.concat(n)),a}getConfig(){let t={filters:this.filters,kernelInitializer:wt(this.kernelInitializer),kernelRegularizer:ut(this.kernelRegularizer),kernelConstraint:zt(this.kernelConstraint)},n=super.getConfig();return Object.assign(t,n),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new V(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}},af=class aS extends rf{constructor(t){super(2,t),aS.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!Fy(t.kernelSize,"number",1,2))throw new V(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}};af.className="Conv2D";ne.registerClass(af);var sf=class sS extends rf{constructor(t){super(3,t),sS.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new V(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}};sf.className="Conv3D";ne.registerClass(sf);var lb=class extends af{constructor(e){if(super(e),this.inputSpec=[new Et({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new V(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Xe(e),e.length!==4)throw new V("Input should have rank 4; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new V("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Et({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return B(()=>{let n=Ce(e);if(n.shape.length!==4)throw new V(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let r=n.shape,a=r[0],s,i;this.dataFormat==="channelsFirst"?(s=2,i=3):(s=1,i=2);let o=r[s],l=r[i],p=this.kernelSize[0],u=this.kernelSize[1],d=this.strides[0],h=this.strides[1],c=Lr(o,d,p,this.padding),f=Lr(l,h,u,this.padding),m=[a,c,f,this.filters];this.dataFormat!=="channelsLast"&&(n=Le(n,[0,2,3,1]));let g=fc(n,this.kernel.read(),m,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(g=Le(g,[0,3,1,2])),this.bias!=null&&(g=Er(g,this.bias.read(),this.dataFormat)),this.activation!=null&&(g=this.activation.apply(g)),g})}computeOutputShape(e){e=Xe(e);let t=e.slice(),n,r,a;this.dataFormat==="channelsFirst"?(n=1,r=2,a=3):(n=3,r=1,a=2);let s=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return t[n]=this.filters,t[r]=Lr(t[r],o,s,this.padding),t[a]=Lr(t[a],l,i,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};lb.className="Conv2DTranspose";ne.registerClass(lb);var ub=class extends sf{constructor(e){if(super(e),this.inputSpec=[new Et({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new V(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Xe(e),e.length!==5)throw new V("Input should have rank 5; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new V("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Et({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return B(()=>{let n=Ce(e);if(n.shape.length!==5)throw new V(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let r=n.shape,a=r[0],s,i,o;this.dataFormat==="channelsFirst"?(o=2,s=3,i=4):(o=1,s=2,i=3);let l=r[o],p=r[s],u=r[i],d=this.kernelSize[0],h=this.kernelSize[1],c=this.kernelSize[2],f=this.strides[0],m=this.strides[1],g=this.strides[2],y=Lr(l,f,d,this.padding),b=Lr(p,m,h,this.padding),x=Lr(u,g,c,this.padding),v=[a,y,b,x,this.filters];this.dataFormat!=="channelsLast"&&(n=Le(n,[0,2,3,4,1]));let I=Og(n,this.kernel.read(),v,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(I=Le(I,[0,4,1,2,3])),this.bias!==null&&(I=Er(I,this.bias.read(),this.dataFormat)),this.activation!==null&&(I=this.activation.apply(I)),I})}computeOutputShape(e){e=Xe(e);let t=e.slice(),n,r,a,s;this.dataFormat==="channelsFirst"?(n=1,r=2,a=3,s=4):(n=4,r=1,a=2,s=3);let i=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],p=this.strides[0],u=this.strides[1],d=this.strides[2];return t[n]=this.filters,t[r]=Lr(t[r],p,i,this.padding),t[a]=Lr(t[a],u,o,this.padding),t[s]=Lr(t[s],d,l,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};ub.className="Conv3DTranspose";ne.registerClass(ub);var iS=class extends rf{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new V("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new V("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new V(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=gt(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=yt(t.depthwiseRegularizer),this.depthwiseConstraint=Pt(t.depthwiseConstraint),this.pointwiseInitializer=gt(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=yt(t.pointwiseRegularizer),this.pointwiseConstraint=Pt(t.pointwiseConstraint)}build(e){if(e=Xe(e),e.length<this.rank+2)throw new V(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new V(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);let n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),a=[];for(let i=0;i<this.rank;++i)a.push(1);a.push(n*this.depthMultiplier,this.filters);let s=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,s,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,s,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,s,this.biasConstraint):this.bias=null,this.inputSpec=[new Et({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return B(()=>{e=Ce(e);let n;if(this.rank===1)throw new Be("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=Le(e,[0,2,3,1])),n=yu(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(n=Er(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),this.dataFormat==="channelsFirst"&&(n=Le(n,[0,3,1,2])),n})}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=wt(this.depthwiseInitializer),e.pointwiseInitializer=wt(this.pointwiseInitializer),e.depthwiseRegularizer=ut(this.depthwiseRegularizer),e.pointwiseRegularizer=ut(this.pointwiseRegularizer),e.depthwiseConstraint=zt(this.depthwiseConstraint),e.pointwiseConstraint=zt(this.pointwiseConstraint),e}};iS.className="SeparableConv";var pb=class extends iS{constructor(e){super(2,e)}};pb.className="SeparableConv2D";ne.registerClass(pb);var db=class oS extends rf{constructor(t){super(1,t),oS.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){let t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!Fy(t.kernelSize,"number",1,1))throw new V(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}};db.className="Conv1D";ne.registerClass(db);var hb=class extends We{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return B(()=>{if(e=Ce(e),this.dataFormat==="channelsLast"){let n=Hd(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Hd(n,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let n=Hd(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Hd(n,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};hb.className="Cropping2D";ne.registerClass(hb);var cb=class extends We{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Nt(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,QB(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){let t=e[2]==null?null:this.size[0]*e[2],n=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,n]}else{let t=e[1]==null?null:this.size[0]*e[1],n=e[2]==null?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return B(()=>{let n=Ce(e),r=n.shape;if(this.dataFormat==="channelsFirst"){n=Le(n,[0,2,3,1]);let a=this.size[0]*r[2],s=this.size[1]*r[3],i=this.interpolation==="nearest"?Zn.resizeNearestNeighbor(n,[a,s]):Zn.resizeBilinear(n,[a,s]);return Le(i,[0,3,1,2])}else{let a=this.size[0]*r[1],s=this.size[1]*r[2];return this.interpolation==="nearest"?Zn.resizeNearestNeighbor(n,[a,s]):Zn.resizeBilinear(n,[a,s])}})}getConfig(){let e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}};cb.className="UpSampling2D";ne.registerClass(cb);function j4(e,t,n=[1,1],r="valid",a,s){return B(()=>{a==null&&(a=Sr()),Nt(a);let i=ob(e,a);if(e.rank!==4)throw new V(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(t.rank!==4)throw new V(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=xo(i,t,n,r==="same"?"same":"valid","NHWC",s),a==="channelsFirst"&&(i=Le(i,[0,3,1,2])),i})}var fb=class extends tS{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=gt(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Pt(e.depthwiseConstraint),this.depthwiseRegularizer=yt(e.depthwiseRegularizer)}build(e){if(e=Xe(e),e.length<4)throw new V(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);let t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new V(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);let n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return B(()=>{e=Ce(e);let n=j4(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(n=Er(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),n})}computeOutputShape(e){e=Xe(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,a=wr(t,this.kernelSize[0],this.padding,this.strides[0]),s=wr(n,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],r,a,s]:[e[0],a,s,r]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=wt(this.depthwiseInitializer),e.depthwiseRegularizer=ut(this.depthwiseRegularizer),e.depthwiseConstraint=zt(this.depthwiseRegularizer),e}};fb.className="DepthwiseConv2D";ne.registerClass(fb);function lS(e,t,n,r){if(Array.isArray(e)){if(t!=null||n!=null)throw new V("When inputs is an array, neither initialState or constants should be provided");r!=null&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function a(s){return s==null||Array.isArray(s)?s:[s]}return t=a(t),n=a(n),{inputs:e,initialState:t,constants:n}}function uS(e,t,n,r=!1,a,s,i=!1,o=!1){return B(()=>{let l=t.shape.length;if(l<3)throw new V(`Input should be at least 3D, but is ${l}D.`);let p=[1,0].concat(Ir(2,l));t=Le(t,p),s!=null,i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),a!=null&&(a=se(se(a,"bool"),"float32"),a.rank===l-1&&(a=Ht(a,-1)),a=Le(a,p)),r&&(t=rr(t,0),a!=null&&(a=rr(a,0)));let u=[],d,h=n,c=t.shape[0],f=St(t),m;a!=null&&(m=St(a));for(let y=0;y<c;++y){let b=f[y],x=B(()=>e(b,h));if(a==null)d=x[0],h=x[1];else{let v=B(()=>{let I=m[y],T=de(Un(I),I),_=X(z(x[0],I),z(h[0],T)),E=h.map((A,R)=>X(z(x[1][R],I),z(A,T)));return{output:_,newStates:E}});d=v.output,h=v.newStates}o&&u.push(d)}let g;return o&&(g=At(u,1)),[d,g,h]})}var ga=class pS extends We{constructor(t){super(t);let n;if(t.cell==null)throw new V("cell property is missing for the constructor of RNN.");if(Array.isArray(t.cell)?n=new uf({cells:t.cell}):n=t.cell,n.stateSize==null)throw new V("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=n,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new Et({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Ir(0,t).map(n=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){gm(t)&&(t=t[0]),t=t;let n=this.cell.stateSize;Array.isArray(n)||(n=[n]);let r=n[0],a;if(this.returnSequences?a=[t[0],t[1],r]:a=[t[0],r],this.returnState){let s=[];for(let i of n)s.push([t[0],i]);return[a].concat(s)}else return a}computeMask(t,n){return B(()=>{Array.isArray(n)&&(n=n[0]);let r=this.returnSequences?n:null;if(this.returnState){let a=this.states.map(s=>null);return[r].concat(a)}else return r})}get states(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,n=[];for(let r=0;r<t;++r)n.push(null);return n}else return this.states_}set states(t){this.states_=t}build(t){if(this.numConstants!=null)throw new Be("Constants support is not implemented in RNN yet.");gm(t)&&(t=t[0]),t=t;let n=this.stateful?t[0]:null,r=t.slice(2);this.inputSpec[0]=new Et({shape:[n,null,...r]});let a=[t[0]].concat(t.slice(2));this.cell.build(a);let s;if(Array.isArray(this.cell.stateSize)?s=this.cell.stateSize:s=[this.cell.stateSize],this.stateSpec!=null){if(!w.arraysEqual(this.stateSpec.map(i=>i.shape[i.shape.length-1]),s))throw new V(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=s.map(i=>new Et({shape:[null,i]}));this.stateful&&this.resetStates()}resetStates(t,n=!1){B(()=>{if(!this.stateful)throw new Ta("Cannot call resetStates() on an RNN Layer that is not stateful.");let r=this.inputSpec[0].shape[0];if(r==null)throw new V("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(a=>vt([r,a])):this.states_=[vt([r,this.cell.stateSize])];else if(t==null)_e(this.states_),this.keptStates!=null&&(_e(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(a=>vt([r,a])):this.states_[0]=vt([r,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new V(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);n===!0?this.keptStates.push(this.states_.slice()):_e(this.states_);for(let a=0;a<this.states_.length;++a){let s=t[a],i=Array.isArray(this.cell.stateSize)?this.cell.stateSize[a]:this.cell.stateSize,o=[r,i];if(!w.arraysEqual(s.shape,o))throw new V(`State ${a} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${s.shape}`);this.states_[a]=s}}this.states_=this.states_.map(a=>Mt(a.clone()))})}apply(t,n){let r=n==null?null:n.initialState,a=n==null?null:n.constants;n==null&&(n={});let s=lS(t,r,a,this.numConstants);t=s.inputs,r=s.initialState,a=s.constants;let i=[],o=[];if(r!=null){n.initialState=r,i=i.concat(r),this.stateSpec=[];for(let l of r)this.stateSpec.push(new Et({shape:l.shape}));o=o.concat(this.stateSpec)}if(a!=null&&(n.constants=a,i=i.concat(a),this.numConstants=a.length),i[0]instanceof Nr){let l=[t].concat(i),p=this.inputSpec.concat(o),u=this.inputSpec;this.inputSpec=p;let d=super.apply(l,n);return this.inputSpec=u,d}else return super.apply(t,n)}call(t,n){return B(()=>{let r=n==null?null:n.mask,a=n==null?null:n.training,s=n==null?null:n.initialState;t=Ce(t),s==null&&(this.stateful?s=this.states_:s=this.getInitialState(t));let i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==i)throw new V(`RNN Layer has ${i} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let o={training:a},l=uS((c,f)=>{let m=this.cell.call([c].concat(f),o);return[m[0],m.slice(1)]},t,s,this.goBackwards,r,null,this.unroll,this.returnSequences),p=l[0],u=l[1],d=l[2];this.stateful&&this.resetStates(d,a);let h=this.returnSequences?u:p;return this.returnState?[h].concat(d):h})}getInitialState(t){return B(()=>{let n=vt(t.shape);return n=ge(n,[1,2]),n=dd(n),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(r=>r>1?fm(n,[1,r]):n):this.cell.stateSize>1?[fm(n,[1,this.cell.stateSize])]:[n]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){let t=super.getConfig(),n={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(n.numConstants=this.numConstants);let r=this.cell.getConfig();return this.getClassName()===pS.className&&(n.cell={className:this.cell.getClassName(),config:r}),Object.assign(Object.assign(Object.assign({},r),t),n)}static fromConfig(t,n,r={}){let a=n.cell,s=vr(a,r);return new t(Object.assign(n,{cell:s}))}};ga.className="RNN";ne.registerClass(ga);var gd=class extends We{},of=class extends gd{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,jt(this.units,"units"),this.activation=ja(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=gt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=gt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=gt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=yt(e.kernelRegularizer),this.recurrentRegularizer=yt(e.recurrentRegularizer),this.biasRegularizer=yt(e.biasRegularizer),this.kernelConstraint=Pt(e.kernelConstraint),this.recurrentConstraint=Pt(e.recurrentConstraint),this.biasConstraint=Pt(e.biasConstraint),this.dropout=nl([1,Ga([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=nl([1,Ga([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Xe(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return B(()=>{if(e=e,e.length!==2)throw new V(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];let r=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=qa({ones:()=>Un(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=qa({ones:()=>Un(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let a,s=this.dropoutMask,i=this.recurrentDropoutMask;s!=null?a=Vr(z(e,s),this.kernel.read()):a=Vr(e,this.kernel.read()),this.bias!=null&&(a=Er(a,this.bias.read())),i!=null&&(n=z(n,i));let o=X(a,Vr(n,this.recurrentKernel.read()));return this.activation!=null&&(o=this.activation.apply(o)),[o,o]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Ha(this.activation),useBias:this.useBias,kernelInitializer:wt(this.kernelInitializer),recurrentInitializer:wt(this.recurrentInitializer),biasInitializer:wt(this.biasInitializer),kernelRegularizer:ut(this.kernelRegularizer),recurrentRegularizer:ut(this.recurrentRegularizer),biasRegularizer:ut(this.biasRegularizer),activityRegularizer:ut(this.activityRegularizer),kernelConstraint:zt(this.kernelConstraint),recurrentConstraint:zt(this.recurrentConstraint),biasConstraint:zt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}};of.className="SimpleRNNCell";ne.registerClass(of);var mb=class extends ga{constructor(e){e.cell=new of(e),super(e)}call(e,t){return B(()=>{this.cell.dropoutMask!=null&&(_e(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(_e(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,r=t==null?null:t.training,a=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})})}static fromConfig(e,t){return new e(t)}};mb.className="SimpleRNN";ne.registerClass(mb);var lf=class extends gd{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new V("GRUCell does not support reset_after parameter set to true.");this.units=e.units,jt(this.units,"units"),this.activation=ja(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=ja(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=gt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=gt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=gt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=yt(e.kernelRegularizer),this.recurrentRegularizer=yt(e.recurrentRegularizer),this.biasRegularizer=yt(e.biasRegularizer),this.kernelConstraint=Pt(e.kernelConstraint),this.recurrentConstraint=Pt(e.recurrentConstraint),this.biasConstraint=Pt(e.biasConstraint),this.dropout=nl([1,Ga([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=nl([1,Ga([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Xe(e);let t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return B(()=>{if(e=e,e.length!==2)throw new V(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training==null?!1:t.training,r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=qa({ones:()=>Un(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=qa({ones:()=>Un(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));let a=this.dropoutMask,s=this.recurrentDropoutMask,i,o,l;0<this.dropout&&this.dropout<1&&(e=z(e,a[0]));let p=Vr(e,this.kernel.read());this.useBias&&(p=Er(p,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=z(r,s[0]));let u=this.recurrentKernel.read(),[d,h]=Tn(u,[2*this.units,this.units],u.rank-1),c=Vr(r,d),[f,m,g]=Tn(p,3,p.rank-1),[y,b]=Tn(c,2,c.rank-1);i=this.recurrentActivation.apply(X(f,y)),o=this.recurrentActivation.apply(X(m,b));let x=Vr(z(o,r),h);l=this.activation.apply(X(g,x));let v=X(z(i,r),z(X(1,ct(i)),l));return[v,v]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Ha(this.activation),recurrentActivation:Ha(this.recurrentActivation),useBias:this.useBias,kernelInitializer:wt(this.kernelInitializer),recurrentInitializer:wt(this.recurrentInitializer),biasInitializer:wt(this.biasInitializer),kernelRegularizer:ut(this.kernelRegularizer),recurrentRegularizer:ut(this.recurrentRegularizer),biasRegularizer:ut(this.biasRegularizer),activityRegularizer:ut(this.activityRegularizer),kernelConstraint:zt(this.kernelConstraint),recurrentConstraint:zt(this.recurrentConstraint),biasConstraint:zt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}};lf.className="GRUCell";ne.registerClass(lf);var gb=class extends ga{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new lf(e),super(e)}call(e,t){return B(()=>{this.cell.dropoutMask!=null&&(_e(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(_e(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,r=t==null?null:t.training,a=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};gb.className="GRU";ne.registerClass(gb);var yd=class extends gd{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,jt(this.units,"units"),this.activation=ja(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=ja(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=gt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=gt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=gt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=yt(e.kernelRegularizer),this.recurrentRegularizer=yt(e.recurrentRegularizer),this.biasRegularizer=yt(e.biasRegularizer),this.kernelConstraint=Pt(e.kernelConstraint),this.recurrentConstraint=Pt(e.recurrentConstraint),this.biasConstraint=Pt(e.biasConstraint),this.dropout=nl([1,Ga([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=nl([1,Ga([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=Xe(e);let n=e[e.length-1];this.kernel=this.addWeight("kernel",[n,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){let a=this.biasInitializer,s=this.units;r=new(t=class extends cr{apply(i,o){let l=a.apply([s]),p=new jc().apply([s]),u=a.apply([s*2]);return sw(sw(l,p),u)}},t.className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return B(()=>{let n=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new V(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1],a=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=qa({ones:()=>Un(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=qa({ones:()=>Un(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let s=this.dropoutMask,i=this.recurrentDropoutMask,o,l,p,u;0<this.dropout&&this.dropout<1&&(e=z(e,s[0]));let d=Vr(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=z(r,i[0])),d=X(d,Vr(r,this.recurrentKernel.read())),this.useBias&&(d=Er(d,this.bias.read()));let[h,c,f,m]=Tn(d,4,d.rank-1);o=this.recurrentActivation.apply(h),l=this.recurrentActivation.apply(c),p=X(z(l,a),z(o,this.activation.apply(f))),u=this.recurrentActivation.apply(m);let g=z(u,this.activation.apply(p));return[g,g,p]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Ha(this.activation),recurrentActivation:Ha(this.recurrentActivation),useBias:this.useBias,kernelInitializer:wt(this.kernelInitializer),recurrentInitializer:wt(this.recurrentInitializer),biasInitializer:wt(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:ut(this.kernelRegularizer),recurrentRegularizer:ut(this.recurrentRegularizer),biasRegularizer:ut(this.biasRegularizer),activityRegularizer:ut(this.activityRegularizer),kernelConstraint:zt(this.kernelConstraint),recurrentConstraint:zt(this.recurrentConstraint),biasConstraint:zt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}};yd.className="LSTMCell";ne.registerClass(yd);var yb=class extends ga{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new yd(e),super(e)}call(e,t){return B(()=>{this.cell.dropoutMask!=null&&(_e(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(_e(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,r=t==null?null:t.training,a=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};yb.className="LSTM";ne.registerClass(yb);var uf=class extends gd{constructor(e){super(e),this.cells=e.cells}get stateSize(){let e=[];for(let t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return B(()=>{e=e;let n=e.slice(1),r=[];for(let i of this.cells.slice().reverse())Array.isArray(i.stateSize)?r.push(n.splice(0,i.stateSize.length)):r.push(n.splice(0,1));r.reverse();let a=[],s;for(let i=0;i<this.cells.length;++i){let o=this.cells[i];n=r[i],i===0?s=[e[0]].concat(n):s=[s[0]].concat(n),s=o.call(s,t),a.push(s.slice(1))}n=[];for(let i of a.slice().reverse())n.push(...i);return[s[0]].concat(n)})}build(e){gm(e)&&(e=e[0]),e=e;let t;this.cells.forEach((n,r)=>{Es(`RNNCell_${r}`,()=>{n.build(e),Array.isArray(n.stateSize)?t=n.stateSize[0]:t=n.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){let e=super.getConfig(),t=r=>({className:r.getClassName(),config:r.getConfig()}),n={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),n)}static fromConfig(e,t,n={}){let r=[];for(let a of t.cells)r.push(vr(a,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let n of this.cells)t.push(...n.trainableWeights);return t.concat(e)}return e}getWeights(){let e=[];for(let t of this.cells)e.push(...t.weights);return ym(e)}setWeights(e){let t=[];for(let n of this.cells){let r=n.weights.length,a=e.splice(r);for(let s=0;s<n.weights.length;++s)t.push([n.weights[s],a[s]])}Wy(t)}};uf.className="StackedRNNCells";ne.registerClass(uf);function qa(e){let{ones:t,rate:n,training:r=!1,count:a=1,dropoutFunc:s}=e,i=()=>s!=null?s(t(),n):hI(t(),n),o=()=>cd(i,t,r);return!a||a<=1?Mt(o().clone()):Array(a).fill(void 0).map(o).map(l=>Mt(l.clone()))}var q4=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(e!=null&&typeof Object.getOwnPropertySymbols=="function")for(var a=0,r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]]);return n},dS=class extends ga{constructor(e){if(e.unroll)throw new Be("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Be("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Et({ndim:5})]}call(e,t){return B(()=>{if(this.cell.dropoutMask!=null&&(_e(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(_e(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new V("ConvRNN2D cell does not support constants");let n=t==null?null:t.mask,r=t==null?null:t.training,a=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return B(()=>{let{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),a=[r[0],...r.slice(2)],s=vt(a);return Array.isArray(t)?Array(t.length).fill(s):[s]})}resetStates(e,t=!1){B(()=>{if(!this.stateful)throw new Ta("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),a=[r[0],...r.slice(2)];if(n[0]==null)throw new V("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>vt(a)):this.states_=[vt(a)];else if(e==null)_e(this.states_),this.keptStates!=null&&(_e(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>vt(a)):this.states_[0]=vt(a);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new V(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):_e(this.states_);for(let s=0;s<this.states_.length;++s){let i=e[s],o=a;if(!w.arraysEqual(i.shape,o))throw new V(`State ${s} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${i.shape}`);this.states_[s]=i}}this.states_=this.states_.map(s=>Mt(s.clone()))})}computeSingleOutputShape(e){let{dataFormat:t,filters:n,kernelSize:r,padding:a,strides:s,dilationRate:i}=this.cell,o=t==="channelsFirst",l=e[o?3:2],p=e[o?4:3],u=wr(l,r[0],a,s[0],i[0]),d=wr(p,r[1],a,s[1],i[1]);return[...e.slice(0,2),...o?[n,u,d]:[u,d,n]]}};dS.className="ConvRNN2D";var pf=class extends yd{constructor(e){let{filters:t,kernelSize:n,strides:r,padding:a,dataFormat:s,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,jt(this.filters,"filters"),this.kernelSize=Uo(n,2,"kernelSize"),this.kernelSize.forEach(o=>jt(o,"kernelSize")),this.strides=Uo(r||1,2,"strides"),this.strides.forEach(o=>jt(o,"strides")),this.padding=a||"valid",ar(this.padding),this.dataFormat=s||"channelsLast",Nt(this.dataFormat),this.dilationRate=Uo(i||1,2,"dilationRate"),this.dilationRate.forEach(o=>jt(o,"dilationRate"))}build(e){var t;e=Xe(e);let n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new V(`The channel dimension of the input should be defined. Found ${e[n]}`);let r=e[n],a=4,s=this.kernelSize.concat([r,this.filters*a]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let i=this.kernelSize.concat([this.filters,this.filters*a]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",i,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let o;if(this.unitForgetBias){let l=this.biasInitializer,p=this.filters;o=new(t=class extends cr{apply(u,d){let h=l.apply([p]),c=Nn([p]),f=l.apply([p*2]);return Ry([h,c,f])}},t.className="CustomInit",t)}else o=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*a],null,o,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return B(()=>{if(e.length!==3)throw new V(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training||!1,r=e[0],a=e[1],s=e[2],i=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=qa({ones:()=>Un(r),rate:this.dropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));let o=this.dropoutMask,l=(Z,ee,Y)=>!ee||!ee[Y]?Z:z(ee[Y],Z),p=l(r,o,0),u=l(r,o,1),d=l(r,o,2),h=l(r,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=qa({ones:()=>Un(a),rate:this.recurrentDropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));let c=this.recurrentDropoutMask,f=l(a,c,0),m=l(a,c,1),g=l(a,c,2),y=l(a,c,3),b=3,[x,v,I,T]=Tn(this.kernel.read(),i,b),[_,E,A,R]=this.useBias?Tn(this.bias.read(),i):[null,null,null,null];p=this.inputConv(p,x,_,this.padding),u=this.inputConv(u,v,E,this.padding),d=this.inputConv(d,I,A,this.padding),h=this.inputConv(h,T,R,this.padding);let[F,S,M,W]=Tn(this.recurrentKernel.read(),i,b);f=this.recurrentConv(f,F),m=this.recurrentConv(m,S),g=this.recurrentConv(g,M),y=this.recurrentConv(y,W);let U=this.recurrentActivation.apply(X(p,f)),H=this.recurrentActivation.apply(X(u,m)),K=X(z(H,s),z(U,this.activation.apply(X(d,g)))),j=z(this.recurrentActivation.apply(X(h,y)),this.activation.apply(K));return[j,j,K]})}getConfig(){let e=super.getConfig(),{units:t}=e,n=q4(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),r)}inputConv(e,t,n,r){let a=fn(e,t,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return n?Er(a,n,this.dataFormat):a}recurrentConv(e,t){return fn(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}};pf.className="ConvLSTM2DCell";ne.registerClass(pf);var bb=class extends dS{constructor(e){let t=new pf(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}};bb.className="ConvLSTM2D";ne.registerClass(bb);var df=class extends We{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;let t=e.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(this.noiseShape[r]==null?t[r]:this.noiseShape[r]);return n}call(e,t){return B(()=>{this.invokeCallHook(e,t);let n=Ce(e);if(0<this.rate&&this.rate<1){let r=t.training==null?!1:t.training,a=this.getNoiseShape(n);return cd(()=>hI(n,this.rate,a,this.seed),()=>n,r)}return e})}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}};df.className="Dropout";ne.registerClass(df);var xb=class extends df{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){let t=e.shape;return[t[0],1,t[2]]}};xb.className="SpatialDropout1D";ne.registerClass(xb);var vb=class extends We{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,jt(this.units,"units"),this.activation=ja(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=gt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=gt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Pt(e.kernelConstraint),this.biasConstraint=Pt(e.biasConstraint),this.kernelRegularizer=yt(e.kernelRegularizer),this.biasRegularizer=yt(e.biasRegularizer),this.activityRegularizer=yt(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=Xe(e);let t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=Xe(e);let t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return B(()=>{this.invokeCallHook(e,t);let n=Ce(e),r=sI(this.activation.getClassName()),a;return r!=null?a=Vr(n,this.kernel.read(),r,this.bias?this.bias.read():null):(a=Vr(n,this.kernel.read()),this.bias!=null&&(a=Er(a,this.bias.read())),this.activation!=null&&(a=this.activation.apply(a))),a})}getConfig(){let e={units:this.units,activation:Ha(this.activation),useBias:this.useBias,kernelInitializer:wt(this.kernelInitializer),biasInitializer:wt(this.biasInitializer),kernelRegularizer:ut(this.kernelRegularizer),biasRegularizer:ut(this.biasRegularizer),activityRegularizer:ut(this.activityRegularizer),kernelConstraint:zt(this.kernelConstraint),biasConstraint:zt(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}};vb.className="Dense";ne.registerClass(vb);var wb=class extends We{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Xe(e);for(let t of e.slice(1))if(t==null)throw new V(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Ma(e,1)]}call(e,t){return B(()=>{this.invokeCallHook(e,t);let n=Ce(e);if(this.dataFormat==="channelsFirst"&&n.rank>1){let r=[0];for(let a=2;a<n.rank;++a)r.push(a);r.push(1),n=Le(n,r)}return sW(n)})}getConfig(){let e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);let t=super.getConfig();return Object.assign(e,t),e}};wb.className="Flatten";ne.registerClass(wb);var kb=class extends We{constructor(e){super(e),this.supportsMasking=!0,this.activation=ja(e.activation)}call(e,t){return B(()=>{this.invokeCallHook(e,t);let n=Ce(e);return this.activation.apply(n)})}getConfig(){let e={activation:Ha(this.activation)},t=super.getConfig();return Object.assign(e,t),e}};kb.className="Activation";ne.registerClass(kb);var Ib=class extends We{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return B(()=>(e=Ce(e),rW(e,this.n)))}getConfig(){let e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}};Ib.className="RepeatVector";ne.registerClass(Ib);var Sb=class extends We{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){let n="Total size of new array must be unchanged.",r=t.slice(),a=1,s=null;for(let o=0;o<r.length;++o){let l=r[o];if(this.isUnknown(l))if(s===null)s=o;else throw new V("Can only specifiy one unknown dimension.");else a*=l}let i=Ma(e);if(s!==null){if(a===0||i%a!==0)throw new V(n);r[s]=i/a}else if(i!==a)throw new V(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return B(()=>{this.invokeCallHook(e,t);let n=Ce(e),r=n.shape,a=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return P(n,a)})}getConfig(){let e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};Sb.className="Reshape";ne.registerClass(Sb);var Nb=class extends We{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);let t=Ir(1,e.dims.length+1);if(!w.arraysEqual(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Et({ndim:this.dims.length+1})]}computeOutputShape(e){e=Xe(e);let t=e.slice();return this.dims.forEach((n,r)=>{t[r+1]=e[n]}),t}call(e,t){return Le(Ce(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}};Nb.className="Permute";ne.registerClass(Nb);var Tb=class extends We{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){let n=Ce(e);return lp(Vs(n,this.maskValue),-1)}call(e,t){return B(()=>{this.invokeCallHook(e,t);let n=Ce(e),r=lp(Vs(n,this.maskValue),-1,!0);return z(n,se(r,n.dtype))})}};Tb.className="Masking";ne.registerClass(Tb);var Cb=class extends We{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(Qe(e.inputLength))}this.inputDim=e.inputDim,jt(this.inputDim,"inputDim"),this.outputDim=e.outputDim,jt(this.outputDim,"outputDim"),this.embeddingsInitializer=gt(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=yt(e.embeddingsRegularizer),this.activityRegularizer=yt(e.activityRegularizer),this.embeddingsConstraint=Pt(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return B(()=>this.maskZero?(e=Ce(e),Vs(e,He(e))):null)}computeOutputShape(e){if(e=Xe(e),this.inputLength==null)return[...e,this.outputDim];let t=Qe(this.inputLength);if(t.length!==e.length-1)throw new V(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){let a=t[r],s=e[r+1];if(a!=null&&s!=null&&a!==s)throw new V(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);a==null&&(t[n]=s),n++}}return[e[0],...t,this.outputDim]}call(e,t){return B(()=>{this.invokeCallHook(e,t);let n=Ce(e);n.dtype!=="int32"&&(n=ua(n,"int32"));let r=dI(this.embeddings.read(),P(n,[n.size]));return P(r,Xe(this.computeOutputShape(n.shape)))})}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:wt(this.embeddingsInitializer),embeddingsRegularizer:ut(this.embeddingsRegularizer),activityRegularizer:ut(this.activityRegularizer),embeddingsConstraint:zt(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}};Cb.className="Embedding";ne.registerClass(Cb);var So=class extends We{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new Be}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;let n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){let a=e[e.length-t.length+r],s=t[r];if(a==null||s==null||a<0||s<0)n.push(null);else if(a===1)n.push(s);else if(s===1)n.push(a);else{if(a!==s)throw new V("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(a)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[Xe(e)]),e=e,e.length<2)throw new V(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(let a of e)a!=null&&a[0]!==null&&t.push(a[0]);if(t=Da(t),t.length>1)throw new V(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=e[0]==null?null:e[0].slice(1);for(let a=1;a<e.length;++a){let s=e[a]==null?null:e[a].slice(1);n=this.computeElementwiseOpOutputShape(n,s)}let r=e.map(a=>a.length);e.indexOf(null)===-1&&Da(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return B(()=>{if(e=e,this.reshapeRequired){let n=[],r=e.map(a=>a.rank);if(r.indexOf(null)===-1){let a=Ga(r);for(let s of e){let i=s.rank;for(let o=0;o<a-i;++o)s=dd(s,1);n.push(s)}return this.mergeFunction(n)}else{let a=!1;for(let o of e){let l=o.rank;if(l==null){let p=o.shape,u=p[0],d=p.slice(1).concat([u]),h=P(o,[u].concat(Ma(p.slice(1))));h=Le(h,[1,0]),h=P(h,d),n.push(h),a=!0}else if(l>1){let p=Ir(1,l).concat([0]);n.push(Le(o,p)),a=!0}else n.push(o)}let s=this.mergeFunction(n),i=s.rank;if(a){if(i==null){let o=s.shape,l=o.length,p=o[l-1],u=[p].concat(o.slice(0,o.length-1));s=P(Le(P(s,[-1,p]),[1,0]),u)}else if(i>1){let o=[i-1].concat(Ir(0,i-1));s=Le(s,o)}}return s}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let r=1;r<e.length;++r){let a=e[r]==null?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,a)}let n=[];for(let r of e)r!=null&&r[0]!==null&&n.push(r[0]);return n=Da(n),n.length===1?t=n.concat(t):t=[null].concat(t),t}computeMask(e,t){return B(()=>{if(t==null)return null;if(!Array.isArray(t))throw new V("`mask` should be an Array");if(!Array.isArray(e))throw new V("`inputs` should be an Array");if(t.length!==e.length)throw new V(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(r=>r==null))return null;t=t.map(r=>r==null?r:Ht(r,0));let n=t[0];for(let r=1;r<t.length-1;++r)n=dr(n,t[r]);return n})}},_b=class extends So{constructor(e){super(e)}mergeFunction(e){return B(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=X(t,e[n]);return t})}};_b.className="Add";ne.registerClass(_b);var Eb=class extends So{constructor(e){super(e)}mergeFunction(e){return B(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=z(t,e[n]);return t})}};Eb.className="Multiply";ne.registerClass(Eb);var $b=class extends So{constructor(e){super(e)}mergeFunction(e){return B(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=X(t,e[n]);return z(1/e.length,t)})}};$b.className="Average";ne.registerClass($b);var Ab=class extends So{constructor(e){super(e)}mergeFunction(e){return B(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Kr(t,e[n]);return t})}};Ab.className="Maximum";ne.registerClass(Ab);var Fb=class extends So{constructor(e){super(e)}mergeFunction(e){return B(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Va(t,e[n]);return t})}};Fb.className="Minimum";ne.registerClass(Fb);var Rb=class extends So{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new V("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(let r of e)if(r!=null){t=!1;break}if(t)return;let n=[];for(let r=0;r<e.length;++r){let a=e[r].slice();a.splice(this.axis,1);let s=!1;for(let i of n)if(w.arraysEqual(i,a)){s=!0;break}s||n.push(a)}if(n.length>1)throw new V("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return B(()=>Ry(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new V("A `Concatenate` layer should be called on a list of inputs.");let t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(let a of t.slice(1)){if(n[r]==null||a[r]==null){n[r]=null;break}n[r]+=a[r]}return n}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new V("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new V("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new V(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return B(()=>{let n=!0;if(t.forEach(s=>{if(s!=null){n=!1;return}}),n)return null;let r=[];for(let s=0;s<e.length;++s)t[s]==null?r.push(se(Un(e[s]),"bool")):t[s].rank<e[s].rank?r.push(Ht(t[s],-1)):r.push(t[s]);let a=it(r,this.axis);return hc(a,-1,!1)})}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};Rb.className="Concatenate";ne.registerClass(Rb);function Pu(e,t){for(;e<0;)e+=t;return e}function K4(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new Be("batchDot is not implemented for tensors of 4D or higher rank yet");if(w.assert(e.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`),w.assert(e.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof n=="number"&&(n=[n,n]),e.dtype==="complex64"||t.dtype==="complex64")throw new Be("batchDot is not implemented for complex64-type Tensors yet.");let r=e.shape.length,a=t.shape.length;n==null&&(n=[r-1,a-2]);let s=n;return B(()=>{let i;if(r>a){i=r-a;let l=[];for(let p=0;p<i;++p)l.push(1);t=P(t,t.shape.concat(l))}else if(a>r){i=a-r;let l=[];for(let p=0;p<i;++p)l.push(1);e=P(e,e.shape.concat(l))}else i=0;let o;if(e.shape.length===2&&t.shape.length===2)s[0]===s[1]?o=ge(z(e,t),s[0]):o=ge(z(Le(e,[1,0]),t),s[1]);else{let l=s[0]!==e.shape.length-1,p=s[1]===t.shape.length-1;o=Oe(e,t,l,p)}if(i>0){let l;r>a?l=r+a-3:l=r-1;let p=[];for(let u=l;u<l+i;++u)p.push(u);o=is(o,p)}return o.shape.length===1&&(o=Ht(o,1)),o})}var Db=class extends So{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){w.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0],n=e[1];if(t.length>3||n.length>3)throw new Be("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new V(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(e.length!==2)throw new V(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],n=e[1],r;return Array.isArray(this.axes)?r=this.axes.map((a,s)=>Pu(a,e[s].shape.length)):r=[Pu(this.axes,t.shape.length),Pu(this.axes,n.shape.length)],this.normalize&&(t=Nh(t,r[0]),n=Nh(n,r[1])),K4(t,n,r)}interpretAxes(e,t){let n;return Array.isArray(this.axes)?n=this.axes:n=[Pu(this.axes,e.length),Pu(this.axes,t.length)],n}computeOutputShape(e){w.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new Be("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);let a=t.concat(n);return a.length===1&&a.push(1),a}computeMask(e,t){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}};Db.className="Dot";ne.registerClass(Db);var Mb=class extends We{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return B(()=>{this.invokeCallHook(e,t);let n=Ce(e);return cd(()=>X(Hc(n.shape,0,this.stddev),n),()=>n,t.training||!1)})}};Mb.className="GaussianNoise";ne.registerClass(Mb);var Ob=class extends We{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return B(()=>{this.invokeCallHook(e,t);let n=Ce(e);return this.rate>0&&this.rate<1?cd(()=>{let r=Math.sqrt(this.rate/(1-this.rate));return z(n,Hc(n.shape,1,r))},()=>n,t.training||!1):n})}};Ob.className="GaussianDropout";ne.registerClass(Ob);var Lb=class extends We{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Ce(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return B(()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(e);return cd(()=>{let r=Ce(e),a=-1.6732632423543772*1.0507009873554805,s=ca(as(n),this.rate);s=ua(s,"float32");let i=((1-this.rate)*(1+this.rate*a**2))**-.5,o=-i*a*this.rate,l=X(z(r,s),z(X(s,-1),a));return X(z(l,i),o)},()=>Ce(e),t.training||!1)}return e})}};Lb.className="AlphaDropout";ne.registerClass(Lb);function fp(e,t,n,r,a,s=.001){let i;if(e.rank===2)i=Ng(e,t,n,r,a,s);else if(e.rank===3)i=Tg(e,t,n,r,a,s);else if(e.rank===4)i=Cg(e,t,n,r,a,s);else throw new Be(`batchNormalization is not implemented for array of rank ${e.rank} yet`);return i}function X4(e,t,n,r,a=.001){return B(()=>{let s=rd(e,r),i=s.mean,o=s.variance;return[fp(e,i,o,n,t,a),i,o]})}function Z4(e,t,n,r,a=.001){return B(()=>{let s=rd(e,r),i=s.mean,o=s.variance,l=[];for(let c of Ir(0,e.rank))r.indexOf(c)!==-1?l.push(1):l.push(e.shape[c]);let p=P(i,l),u=P(o,l),d=t==null?null:P(t,l),h=n==null?null:P(n,l);return[fp(e,p,u,h,d,a),i,o]})}function J4(e,t,n,r,a=.001){return w.arraysEqual(r.slice().sort(),Ir(0,e.rank-1))?X4(e,t,n,r,a):Z4(e,t,n,r,a)}var zb=class extends We{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=gt(e.betaInitializer||"zeros"),this.gammaInitializer=gt(e.gammaInitializer||"ones"),this.movingMeanInitializer=gt(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=gt(e.movingVarianceInitializer||"ones"),this.betaConstraint=Pt(e.betaConstraint),this.gammaConstraint=Pt(e.gammaConstraint),this.betaRegularizer=yt(e.betaRegularizer),this.gammaRegularizer=yt(e.gammaRegularizer)}build(e){e=Xe(e);let t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(n==null)throw new V(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Et({ndim:e.length,axes:{[t]:n}})];let r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return B(()=>{let n=t.training==null?!1:t.training,r=Ce(e),a=r.shape,s=a.length,i=Ir(0,s),o=this.axis>=0?this.axis:this.axis+s;i.splice(o,1);let l=Gs(1,s);l[o]=a[o];let p=i.slice();p.sort();let u=!w.arraysEqual(p,Ir(0,s).slice(0,s-1)),d=()=>{if(u){let g=P(this.movingMean.read(),l),y=P(this.movingVariance.read(),l),b=this.center?P(this.beta.read(),l):null,x=this.scale?P(this.gamma.read(),l):null;return fp(r,g,y,b,x,this.epsilon)}else return fp(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!n)return d();let[h,c,f]=J4(r,this.gamma.read(),this.beta.read(),i,this.epsilon),m=(g,y,b)=>{B(()=>{let x=1-b,v=g.read(),I=z(de(v,y),x);g.write(de(v,I))})};return m(this.movingMean,c,this.momentum),m(this.movingVariance,f,this.momentum),h})}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:wt(this.betaInitializer),gammaInitializer:wt(this.gammaInitializer),movingMeanInitializer:wt(this.movingMeanInitializer),movingVarianceInitializer:wt(this.movingVarianceInitializer),betaRegularizer:ut(this.betaRegularizer),gammaRegularizer:ut(this.gammaRegularizer),betaConstraint:zt(this.betaConstraint),gammaConstraint:zt(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}};zb.className="BatchNormalization";ne.registerClass(zb);var Pb=class extends We{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=gt(e.betaInitializer||"zeros"),this.gammaInitializer=gt(e.gammaInitializer||"ones"),this.betaRegularizer=yt(e.betaRegularizer),this.gammaRegularizer=yt(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=Xe(e);let t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let a=0;a<this.axis.length;++a)this.axis[a]<0&&(this.axis[a]+=t);for(let a of this.axis)if(a<0||a>=t)throw new Error(`Invalid axis: ${a}`);if(this.axis.length!==Da(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map(a=>e[a]),r=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){let n=Ce(e),r=n.shape,a=r.length;return B(()=>{let{mean:s,variance:i}=rd(n,this.axis,!0),o=Gs(1,a);for(let c of this.axis)o[c]=r[c];let l=c=>c!=null&&c.shape.length!==a?P(c,o):c,p=this.scale?l(this.gamma.read()):null,u=this.center?l(this.beta.read()):null,d=[],h=[];for(let c=0;c<a;++c)this.axis.indexOf(c)!==-1?(d.push(r[c]),h.push(1)):(d.push(1),h.push(r[c]));return s=Pn(s,d),i=Pn(i,d),p!=null&&(p=Pn(p,h)),u!=null&&(u=Pn(u,h)),fp(n,s,i,u,p,this.epsilon)})}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:wt(this.betaInitializer),gammaInitializer:wt(this.gammaInitializer),betaRegularizer:ut(this.betaRegularizer),gammaRegularizer:ut(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}};Pb.className="LayerNormalization";ne.registerClass(Pb);function Y4(e,t,n){return B(()=>{if(e.rank!==4)throw new V(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new V("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(n==null&&(n=Sr()),n!=="channelsLast"&&n!=="channelsFirst")throw new V(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return n==="channelsFirst"?r=[[0,0],[0,0],t[0],t[1]]:r=[[0,0],t[0],t[1],[0,0]],_r(e,r)})}var Bb=class extends We{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?Sr():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new V(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new V(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new V(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new Et({ndim:4})]}computeOutputShape(e){e=Xe(e);let t,n;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?n=e[3]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],e[1],t,n]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?n=e[2]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],t,n,e[3]])}call(e,t){return B(()=>Y4(Ce(e),this.padding,this.dataFormat))}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};Bb.className="ZeroPadding2D";ne.registerClass(Bb);function hf(e,t,n,r,a,s){return B(()=>{Nt(a),oI(s),ar(r),n==null&&(n=[1,1]),r==null&&(r="valid"),a==null&&(a=Sr()),s==null&&(s="max"),e=ob(e,a);let i,o=r==="same"?"same":"valid";return s==="max"?i=Vt(e,t,n,o):i=ha(e,t,n,o),a==="channelsFirst"&&(i=Le(i,[0,3,1,2])),i})}function hS(e,t,n,r,a,s){return B(()=>{Nt(a),oI(s),ar(r),n==null&&(n=[1,1,1]),r==null&&(r="valid"),a==null&&(a=Sr()),s==null&&(s="max"),e=eS(e,a);let i,o=r==="same"?"same":"valid";return s==="max"?i=Jg(e,t,n,o):i=Sg(e,t,n,o),a==="channelsFirst"&&(i=Le(i,[0,4,1,2,3])),i})}var cS=class extends We{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new V(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(jt(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new V(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);jt(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,ar(this.padding),this.inputSpec=[new Et({ndim:3})]}computeOutputShape(e){e=Xe(e);let t=wr(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return B(()=>{this.invokeCallHook(e,t),e=dd(Ce(e),2);let n=this.poolingFunction(Ce(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return is(n,[2])})}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}},Wb=class extends cS{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Nt(a),ar(r),hf(e,t,n,r,a,"max")}};Wb.className="MaxPooling1D";ne.registerClass(Wb);var Vb=class extends cS{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Nt(a),ar(r),hf(e,t,n,r,a,"avg")}};Vb.className="AveragePooling1D";ne.registerClass(Vb);var fS=class extends We{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new V(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];jt(this.poolSize,"poolSize"),jt(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Nt(this.dataFormat),ar(this.padding),this.inputSpec=[new Et({ndim:4})]}computeOutputShape(e){e=Xe(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=wr(t,this.poolSize[0],this.padding,this.strides[0]),n=wr(n,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return B(()=>(this.invokeCallHook(e,t),this.poolingFunction(Ce(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},Ub=class extends fS{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Nt(a),ar(r),hf(e,t,n,r,a,"max")}};Ub.className="MaxPooling2D";ne.registerClass(Ub);var Gb=class extends fS{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Nt(a),ar(r),hf(e,t,n,r,a,"avg")}};Gb.className="AveragePooling2D";ne.registerClass(Gb);var mS=class extends We{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new V(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];jt(this.poolSize,"poolSize"),jt(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Nt(this.dataFormat),ar(this.padding),this.inputSpec=[new Et({ndim:5})]}computeOutputShape(e){e=Xe(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=wr(t,this.poolSize[0],this.padding,this.strides[0]),n=wr(n,this.poolSize[1],this.padding,this.strides[1]),r=wr(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return B(()=>(this.invokeCallHook(e,t),this.poolingFunction(Ce(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},Hb=class extends mS{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Nt(a),ar(r),hS(e,t,n,r,a,"max")}};Hb.className="MaxPooling3D";ne.registerClass(Hb);var jb=class extends mS{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return Nt(a),ar(r),hS(e,t,n,r,a,"avg")}};jb.className="AveragePooling3D";ne.registerClass(jb);var gS=class extends We{constructor(e){super(e),this.inputSpec=[new Et({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new Be}},qb=class extends gS{constructor(e){super(e||{})}call(e,t){return B(()=>{let n=Ce(e);return xt(n,1)})}};qb.className="GlobalAveragePooling1D";ne.registerClass(qb);var Kb=class extends gS{constructor(e){super(e||{})}call(e,t){return B(()=>{let n=Ce(e);return er(n,1)})}};Kb.className="GlobalMaxPooling1D";ne.registerClass(Kb);var yS=class extends We{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Nt(this.dataFormat),this.inputSpec=[new Et({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new Be}getConfig(){let e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},Xb=class extends yS{call(e,t){return B(()=>{let n=Ce(e);return this.dataFormat==="channelsLast"?xt(n,[1,2]):xt(n,[2,3])})}};Xb.className="GlobalAveragePooling2D";ne.registerClass(Xb);var Zb=class extends yS{call(e,t){return B(()=>{let n=Ce(e);return this.dataFormat==="channelsLast"?er(n,[1,2]):er(n,[2,3])})}};Zb.className="GlobalMaxPooling2D";ne.registerClass(Zb);var bS=class extends We{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){let e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){let r=t.layer,a=vr(r,n);delete t.layer;let s={layer:a};return Object.assign(s,t),new e(s)}},Jb=class extends bS{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=Xe(e),e.length<3)throw new V(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];let t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=Xe(e);let t=[e[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return B(()=>(e=Ce(e),uS((n,r)=>[Ce(this.layer.call(n,t)),[]],e,[],!1,null,null,!1,!0)[1]))}};Jb.className="TimeDistributed";ne.registerClass(Jb);function Q4(e){ko(YB,"BidirectionalMergeMode",e)}var eV="concat",Yb=class extends bS{constructor(e){super(e);let t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=vr(n),t.goBackwards=t.goBackwards!==!0;let r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=vr(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?eV:e.mergeMode,Q4(this.mergeMode),e.weights)throw new Be("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let n,r,a;return this.returnState&&(a=t.slice(1)),n=t[0],n=n,this.mergeMode==="concat"?(n[n.length-1]*=2,r=[n]):this.mergeMode==null?r=[n,n.slice()]:r=[n],this.returnState?this.mergeMode==null?r.concat(a).concat(a.slice()):[n].concat(a).concat(a.slice()):Sn(r)}apply(e,t){let n=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});let a=lS(e,n,r,this.numConstants);if(e=a.inputs,n=a.initialState,r=a.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(n==null||n.length===0)&&r==null)return super.apply(e,t);let s=[],i=[];if(n!=null){let l=n.length;if(l%2>0)throw new V("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,s.push(...n);let p=n.map(u=>new Et({shape:u.shape}));this.forwardLayer.stateSpec=p.slice(0,l/2),this.backwardLayer.stateSpec=p.slice(l/2),i.push(...p)}if(r!=null)throw new Be("Support for constants in Bidirectional layers is not implemented yet.");let o=s[0]instanceof Nr;for(let l of s)if(l instanceof Nr!==o)throw new V("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){let l=[e].concat(s),p=this.inputSpec.concat(i),u=this.inputSpec;this.inputSpec=p;let d=super.apply(l,t);return this.inputSpec=u,d}else return super.apply(e,t)}call(e,t){return B(()=>{let n=t.initialState,r,a;if(n==null)r=this.forwardLayer.call(e,t),a=this.backwardLayer.call(e,t);else{let o=n.slice(0,n.length/2),l=n.slice(n.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:o})),a=this.backwardLayer.call(e,Object.assign(t,{initialState:l}))}let s;this.returnState&&(Array.isArray(r)&&(s=r.slice(1).concat(a.slice(1))),r=r[0],a=a[0]),this.returnSequences&&(a=rr(a,1));let i;return this.mergeMode==="concat"?i=Ry([r,a]):this.mergeMode==="sum"?i=X(r,a):this.mergeMode==="ave"?i=z(.5,X(r,a)):this.mergeMode==="mul"?i=z(r,a):this.mergeMode==null&&(i=[r,a]),this.returnState?this.mergeMode==null?i.concat(s):[i].concat(s):i})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Es(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),Es(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let n;if(this.returnSequences?this.mergeMode==null?n=[t,t]:n=t:this.mergeMode==null?n=[null,null]:n=null,this.returnState){let r=this.forwardLayer.states.map(a=>null);return Array.isArray(n)?n.concat(r).concat(r):[n].concat(r).concat(r)}else return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){let n=vr(t.layer);if(delete t.layer,t.numConstants!=null)throw new Be("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let r=t;return r.layer=n,new e(r)}};Yb.className="Bidirectional";ne.registerClass(Yb);var Qb=class extends We{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){let e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return B(()=>(e=Ce(e),e.dtype!=="float32"&&(e=ua(e,"float32")),X(z(e,this.scale),this.offset)))}};Qb.className="Rescaling";ne.registerClass(Qb);var{resizeBilinear:tV,cropAndResize:nV}=Zn,ex=class extends We{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,r,a,s,i,o){return B(()=>{let l,p=!1,u=t/s,d=n/i,h=(r+t)/s,c=(a+n)/i,f=[u,d,h,c],m=[];e.rank===3?(p=!0,l=At([e])):l=e;for(let x=0;x<l.shape[0];x++)m.push(f);let g=cn(m,[m.length,4]),y=Us(0,m.length,1,"int32"),b=nV(l,g,y,[r,a],"nearest");return ua(p?Ce(St(b)):b,o)})}upsize(e,t,n,r){return B(()=>{let a=tV(e,[t,n]);return ua(a,r)})}call(e,t){return B(()=>{let n=Ce(e),r=n.dtype,a=n.shape,s=a[a.length-3],i=a[a.length-2],o=0;s!==this.height&&(o=Math.floor((s-this.height)/2));let l=0;return i!==this.width&&(l=Math.floor((i-this.width)/2),l===0&&(l=1)),o>=0&&l>=0?this.centerCrop(n,o,l,this.height,this.width,s,i,r):this.upsize(e,this.height,this.width,r)})}getConfig(){let e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=Xe(e);let t=e.length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}};ex.className="CenterCrop";ne.registerClass(ex);function rV(e,t,n,r){let a=Ce(e);if(a.dtype!=="int32"&&(a=ua(a,"int32")),t==="int")return a;let s=a.shape;if(a.rank===0&&(a=Ht(a,-1)),t==="oneHot"&&a.shape[a.shape.length-1]!==1&&(a=Ht(a,-1)),a.rank>2)throw new V(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${s} which would result in output rank ${a.rank}.`);let i=["multiHot","oneHot"].includes(t),o=a,l;if(typeof r<"u"&&t==="count"?l=xh(o,r,n,i):l=xh(o,[],n,i),t!=="tfIdf")return l;if(r)return z(l,r);throw new V("When outputMode is 'tfIdf', weights must be provided.")}var tx=class extends We{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){let e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=Xe(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return B(()=>{e=Ce(e),e.dtype!=="int32"&&(e=ua(e,"int32"));let n;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new V(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);n=Ce(t.countWeights)}let r=er(e),a=Xo(e),s=xn(this.numTokens,r).bufferSync().get(0),i=ca(a,0).bufferSync().get(0);if(!(s&&i))throw new V(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return rV(e,this.outputMode,this.numTokens,n)})}};tx.className="CategoryEncoding";ne.registerClass(tx);var aV=["bilinear","nearest"],kw=new Set(aV),nx=class extends We{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(kw.has(e.interpolation))this.interpolation=e.interpolation;else throw new V(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=Xe(e);let t=e[2];return[this.height,this.width,t]}getConfig(){let e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return B(()=>{let n=[this.height,this.width];if(this.interpolation==="bilinear")return Zn.resizeBilinear(e,n,!this.cropToAspectRatio);if(this.interpolation==="nearest")return Zn.resizeNearestNeighbor(e,n,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...kw]} are supported`)})}};nx.className="Resizing";ne.registerClass(nx);var xS=class{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}};xS.className="RandomSeed";var vS=class extends We{constructor(e){super(e),this.randomGenerator=new xS(e.seed)}getConfig(){let e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}};vS.className="BaseRandomLayer";var sV=["bilinear","nearest"],Iw=new Set(sV),rx=class extends vS{constructor(e){super(e);let{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new V(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new V(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new V(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(n)if(Iw.has(n))this.interpolation=n;else throw new V(`Invalid interpolation parameter: ${n} is not implemented`)}getConfig(){let e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=Xe(e);let t=e[2];return[this.imgHeight,-1,t]}call(e,t){return B(()=>{let n=Ce(e);this.imgHeight=n.shape[n.shape.length-3];let r=n.shape[n.shape.length-2];this.widthFactor=as([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let a=this.widthFactor.dataSync()[0]*r;a=Math.round(a);let s=[this.imgHeight,a];switch(this.interpolation){case"bilinear":return Zn.resizeBilinear(e,s);case"nearest":return Zn.resizeNearestNeighbor(e,s);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...Iw]} are supported`)}})}};rx.className="RandomWidth";ne.registerClass(rx);function iV(e){return new vu(e)}function oV(e){return new ab(e)}function lV(e){return new tb(e)}function uV(e){return new nb(e)}function pV(e){return new rb(e)}function dV(e){return new ib(e)}function hV(e){return new sb(e)}function cV(e){return new db(e)}function fV(e){return new af(e)}function mV(e){return new lb(e)}function gV(e){return new sf(e)}function yV(e){return new ub(e)}function bV(e){return new pb(e)}function xV(e){return new hb(e)}function vV(e){return new cb(e)}function wV(e){return new fb(e)}function kV(e){return new kb(e)}function IV(e){return new vb(e)}function SV(e){return new df(e)}function NV(e){return new xb(e)}function TV(e){return new wb(e)}function CV(e){return new Ib(e)}function _V(e){return new Sb(e)}function EV(e){return new Nb(e)}function $V(e){return new Cb(e)}function AV(e){return new _b(e)}function FV(e){return new $b(e)}function RV(e){return new Rb(e)}function DV(e){return new Ab(e)}function MV(e){return new Fb(e)}function OV(e){return new Eb(e)}function LV(e){return new Db(e)}function zV(e){return new zb(e)}function PV(e){return new Pb(e)}function BV(e){return new Bb(e)}function ax(e){return new Vb(e)}function WV(e){return ax(e)}function VV(e){return ax(e)}function sx(e){return new Gb(e)}function UV(e){return sx(e)}function GV(e){return sx(e)}function ix(e){return new jb(e)}function HV(e){return ix(e)}function jV(e){return ix(e)}function qV(e){return new qb(e)}function KV(e){return new Xb(e)}function wS(e){return new Kb(e)}function kS(e){return new Zb(e)}function IS(e){return new Wb(e)}function SS(e){return new Ub(e)}function XV(e){return new Hb(e)}function ZV(e){return new gb(e)}function JV(e){return new lf(e)}function YV(e){return new yb(e)}function QV(e){return new yd(e)}function eU(e){return new mb(e)}function tU(e){return new of(e)}function nU(e){return new bb(e)}function rU(e){return new pf(e)}function aU(e){return new ga(e)}function sU(e){return new uf(e)}function iU(e){return new Yb(e)}function oU(e){return new Jb(e)}var lU=wS,uU=kS,pU=IS,dU=SS;function hU(e){return new Mb(e)}function cU(e){return new Ob(e)}function fU(e){return new Lb(e)}function mU(e){return new Tb(e)}function gU(e){return new Qb(e)}function yU(e){return new ex(e)}function bU(e){return new nx(e)}function xU(e){return new tx(e)}function vU(e){return new rx(e)}var NS={};Ee(NS,{MAPE:()=>AU,MSE:()=>DU,binaryAccuracy:()=>wU,binaryCrossentropy:()=>kU,categoricalAccuracy:()=>SU,categoricalCrossentropy:()=>NU,cosineProximity:()=>_U,mape:()=>FU,meanAbsoluteError:()=>EU,meanAbsolutePercentageError:()=>$U,meanSquaredError:()=>RU,mse:()=>MU,precision:()=>TU,r2Score:()=>OU,recall:()=>CU,sparseCategoricalAccuracy:()=>IU});function wU(e,t){return Xy(e,t)}function kU(e,t){return _I(e,t)}function IU(e,t){return EI(e,t)}function SU(e,t){return Zy(e,t)}function NU(e,t){return Jy(e,t)}function TU(e,t){return CI(e,t)}function CU(e,t){return a4(e,t)}function _U(e,t){return Ky(e,t)}function EU(e,t){return ef(e,t)}function $U(e,t){return wu(e,t)}function AU(e,t){return wu(e,t)}function FU(e,t){return wu(e,t)}function RU(e,t){return Io(e,t)}function DU(e,t){return Io(e,t)}function MU(e,t){return Io(e,t)}function OU(e,t){return s4(e,t)}var TS={};Ee(TS,{modelFromJSON:()=>M4});var CS={};Ee(CS,{l1:()=>zU,l1l2:()=>LU,l2:()=>PU});function LU(e){return new md(e)}function zU(e){return V4(e)}function PU(e){return U4(e)}var _S=class extends rl{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof ia))throw new Error("model must be a LayersModel, not some other Container");this.model=e}};function qd(e,t){return e<t}function Sw(e,t){return e>t}var ES=class extends _S{constructor(e){if(super(),e==null&&(e={}),e.restoreBestWeights)throw new Be("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=qd:this.mode==="max"?this.monitorFunc=Sw:this.monitor.indexOf("acc")!==-1?this.monitorFunc=Sw:this.monitorFunc=qd,this.monitorFunc===qd&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===qd?1/0:-1/0}async onEpochEnd(e,t){await Sa(t);let n=this.getMonitorValue(t);n!=null&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){e==null&&(e={});let t=e[this.monitor];return t==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}};function BU(e){return new ES(e)}var WU={earlyStopping:BU},VU=G();VU.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var Mn;(function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"})(Mn||(Mn={}));var Nw;(function(e){(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))})(Nw||(Nw={}));var ox={};function UU(e,t){let n={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};ox[e]=n}function $S(e){return ox[e]}function GU(e){delete ox[e]}function k(e,t,n,r,a){let s=t.inputParams[e];if(s&&s.inputIndexStart!==void 0){let o=s.inputIndexStart,l=s.inputIndexEnd===0?void 0:s.inputIndexEnd===void 0?o+1:s.inputIndexEnd,p=o<0?t.inputNames.length+o:o;if(s.type==="tensor")return en(t.inputNames[p],n,r,a);if(s.type==="tensors"){let h=t.inputs.slice(o,l);return t.inputNames.slice(o,l).filter((c,f)=>{var m;return((m=h[f])===null||m===void 0?void 0:m.op)!=="NoOp"}).map(c=>en(c,n,r,a))}let u=en(t.inputNames[p],n,r,a),d=u.dataSync();return s.type==="number"?d[0]:w.toNestedArray(u.shape,d)}let i=t.attrParams[e];return i&&i.value}function en(e,t,n,r){let[a,s]=Ln(e,n);if(r!=null){let o=r.getHashTableHandleByName(a);if(o!=null)return o}let i=n.currentContextIds.find(o=>!!t[$h(a,o)]);return i!==void 0?t[$h(a,i)][s]:void 0}function Tw(e,t,n){return t[$h(e,n.currentContextId)]}function na(e,t){let[n,r,a]=Ln(e,t);return[$h(n,t&&t.currentContextId),r,a]}function $h(e,t){return t?`${e}-${t}`:e}function Ln(e,t){if(e==="")return["",0,void 0];let n=t!=null&&t.parseNodeNameCache!=null;if(n){let s=t.parseNodeNameCache.get(e);if(s!=null)return s}let r=e.split(":"),a;if(r.length===1)a=[e,0,void 0];else{let s=r[0],i=r.length===3?r[1]:void 0,o=Number(r[r.length-1]);a=[s,o,i]}return n&&t.parseNodeNameCache.set(e,a),a}function ih(e,t,n){let r=k("pad",e,t,n);if(r==="explicit"){r=k("explicitPaddings",e,t,n);let a=[[0,0],[0,0],[0,0],[0,0]];for(let s=0;s<4;s++)a[s][0]=r[s*2],a[s][1]=r[s*2+1];return a}return r}function ra(e){return e.kept?e:Br(e)}var AS={};Ee(AS,{json:()=>HU});var HU=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],FS={};Ee(FS,{json:()=>jU});var jU=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],RS={};Ee(RS,{json:()=>qU});var qU=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],DS={};Ee(DS,{json:()=>KU});var KU=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],MS={};Ee(MS,{json:()=>XU});var XU=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],OS={};Ee(OS,{json:()=>ZU});var ZU=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],LS={};Ee(LS,{json:()=>JU});var JU=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],zS={};Ee(zS,{json:()=>YU});var YU=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],PS={};Ee(PS,{json:()=>QU});var QU=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],BS={};Ee(BS,{json:()=>eG});var eG=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],WS={};Ee(WS,{json:()=>tG});var tG=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],VS={};Ee(VS,{json:()=>nG});var nG=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],US={};Ee(US,{json:()=>rG});var rG=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],GS={};Ee(GS,{json:()=>aG});var aG=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],HS={};Ee(HS,{json:()=>sG});var sG=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],jS={};Ee(jS,{json:()=>iG});var iG=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],qS={};Ee(qS,{json:()=>oG});var oG=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],KS={};Ee(KS,{json:()=>lG});var lG=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],XS={};Ee(XS,{json:()=>uG});var uG=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],Cw=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let e=[AS,FS,RS,DS,MS,OS,LS,zS,PS,BS,WS,VS,US,GS,HS,jS,qS,KS,XS],t=[].concat(...e.map(n=>n.json));this.opMappers=t.reduce((n,r)=>(n[r.tfOpName]=r,n),{})}transformGraph(e,t={}){let n=e.node,r=[],a=[],s=[],i=n.reduce((f,m)=>(f[m.name]=this.mapNode(m),m.op.startsWith("Placeholder")?r.push(f[m.name]):m.op==="Const"?a.push(f[m.name]):(m.input==null||m.input.length===0)&&s.push(f[m.name]),f),{}),o=[],l=[],p={},u={};t!=null&&(p=this.mapSignatureEntries(t.inputs),u=this.mapSignatureEntries(t.outputs));let d=Object.keys(i);d.forEach(f=>{let m=i[f];m.inputNames.forEach((g,y)=>{let[b,,x]=na(g),v=i[b];if(v.outputs!=null){let I=v.outputs.indexOf(x);if(I!==-1){let T=`${b}:${I}`;m.inputNames[y]=T}}m.inputs.push(v),v.children.push(m)})}),Object.keys(u).length===0?d.forEach(f=>{let m=i[f];m.children.length===0&&l.push(m)}):Object.keys(u).forEach(f=>{let[m]=na(f),g=i[m];g!=null&&(g.signatureKey=u[f],l.push(g))}),Object.keys(p).length>0?Object.keys(p).forEach(f=>{let[m]=na(f),g=i[m];g&&(g.signatureKey=p[f],o.push(g))}):o=r;let h={};e.library!=null&&e.library.function!=null&&(h=e.library.function.reduce((f,m)=>(f[m.signature.name]=this.mapFunction(m),f),{}));let c={nodes:i,inputs:o,outputs:l,weights:a,placeholders:r,signature:t,functions:h};return s.length>0&&(c.initNodes=s),c}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){let t=$S(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});let n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(n.inputParams=t.inputs.reduce((r,a)=>(r[a.name]={type:a.type,inputIndexStart:a.start,inputIndexEnd:a.end},r),{})),t.attrs!=null&&(n.attrParams=t.attrs.reduce((r,a)=>{let s=a.type,i;switch(a.type){case"string":i=Im(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Im(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"string[]":i=$m(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=$m(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number":i=Nm(e.attr,a.tfName,a.defaultValue||0),i===void 0&&a.tfDeprecatedName&&(i=Nm(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number[]":i=Em(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Em(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool":i=Sm(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Sm(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool[]":i=Fm(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Fm(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape":i=_m(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=_m(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape[]":i=Am(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Am(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype":i=Tm(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Tm(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype[]":i=Cm(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Cm(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"func":i=_w(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=_w(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${a.type} for op: ${e.op}`)}return r[a.name]={value:i,type:s},r},{})),n}mapFunction(e){let t=e.nodeDef,n=[],r=[],a={};t!=null&&(a=t.reduce((p,u)=>(p[u.name]=this.mapNode(u),u.op==="Const"&&r.push(p[u.name]),p),{}));let s=[],i=[];e.signature.inputArg.forEach(p=>{let[u]=na(p.name),d={name:u,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:lx(p.type),type:"dtype"}},children:[]};d.signatureKey=p.name,s.push(d),a[u]=d}),Object.keys(a).forEach(p=>{let u=a[p];u.inputNames.forEach((d,h)=>{let[c,,f]=na(d),m=a[c];if(m.outputs!=null){let g=m.outputs.indexOf(f);if(g!==-1){let y=`${c}:${g}`;u.inputNames[h]=y}}u.inputs.push(m),m.children.push(u)})});let o=e.ret;e.signature.outputArg.forEach(p=>{let[u,d]=na(o[p.name]),h=a[u];h!=null&&(h.defaultOutput=d,i.push(h))});let l=this.mapArgsToSignature(e);return{nodes:a,inputs:s,outputs:i,weights:r,placeholders:n,signature:l}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n),t),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return t!=null&&(n=t[n]),{name:n,dtype:e.type}}};function pG(e){let t=G().global;if(typeof t.atob<"u")return t.atob(e);if(typeof Buffer<"u")return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function ZS(e,t){let n=Array.isArray(e)?String.fromCharCode.apply(null,e):pG(e);return t?n:n.toLowerCase()}function Im(e,t,n,r=!1){let a=e[t];return a!=null?ZS(a.s,r):n}function Sm(e,t,n){let r=e[t];return r?r.b:n}function Nm(e,t,n){let r=e[t]||{},a=r.i!=null?r.i:r.f!=null?r.f:n;return typeof a=="number"?a:parseInt(a,10)}function lx(e){switch(typeof e=="string"&&(e=Mn[e]),e){case Mn.DT_FLOAT:case Mn.DT_HALF:return"float32";case Mn.DT_INT32:case Mn.DT_INT64:case Mn.DT_INT8:case Mn.DT_UINT8:return"int32";case Mn.DT_BOOL:return"bool";case Mn.DT_DOUBLE:return"float32";case Mn.DT_STRING:return"string";case Mn.DT_COMPLEX64:case Mn.DT_COMPLEX128:return"complex64";default:return null}}function _w(e,t,n){let r=e[t];return r&&r.func?r.func.name:n}function Tm(e,t,n){let r=e[t];return r&&r.type?lx(r.type):n}function Cm(e,t,n){let r=e[t];return r&&r.list&&r.list.type?r.list.type.map(a=>lx(a)):n}function JS(e){if(!e.unknownRank)return e.dim!=null?e.dim.map(t=>typeof t.size=="number"?t.size:parseInt(t.size,10)):[]}function _m(e,t,n){let r=e[t];return r&&r.shape?JS(r.shape):n}function Em(e,t,n){let r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(a=>typeof a=="number"?a:parseInt(a,10)):n}function $m(e,t,n,r=!1){let a=e[t];return a&&a.list&&a.list.s?a.list.s.map(s=>ZS(s,r)):n}function Am(e,t,n){let r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map(a=>JS(a)):n}function Fm(e,t,n){let r=e[t];return r&&r.list&&r.list.b?r.list.b:n}var dG=class{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(r=>this.getInput(r)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((r,a)=>(r[a]=this.getAttr(a),r),{}))}getInput(e){return en(e,this.tensorMap,this.context)}getAttr(e,t){let n=this.node.rawAttrs[e];if(n.tensor!=null)return en(e,this.tensorMap,this.context);if(n.i!=null||n.f!=null)return Nm(this.node.rawAttrs,e,t);if(n.s!=null)return Im(this.node.rawAttrs,e,t);if(n.b!=null)return Sm(this.node.rawAttrs,e,t);if(n.shape!=null)return _m(this.node.rawAttrs,e,t);if(n.type!=null)return Tm(this.node.rawAttrs,e,t);if(n.list!=null){if(n.list.i!=null||n.list.f!=null)return Em(this.node.rawAttrs,e,t);if(n.list.s!=null)return $m(this.node.rawAttrs,e,t);if(n.list.shape!=null)return Am(this.node.rawAttrs,e,t);if(n.list.b!=null)return Fm(this.node.rawAttrs,e,t);if(n.list.type!=null)return Cm(this.node.rawAttrs,e,t)}return t}},Zt={};Ee(Zt,{OP_SCOPE_SUFFIX:()=>pg,abs:()=>_t,acos:()=>mg,acosh:()=>gg,add:()=>X,addN:()=>d1,all:()=>hc,any:()=>lp,argMax:()=>Ps,argMin:()=>yg,asin:()=>bg,asinh:()=>xg,atan:()=>vg,atan2:()=>wg,atanh:()=>kg,avgPool:()=>ha,avgPool3d:()=>Sg,basicLSTMCell:()=>m1,batchNorm:()=>bo,batchNorm2d:()=>Ng,batchNorm3d:()=>Tg,batchNorm4d:()=>Cg,batchToSpaceND:()=>Zp,bincount:()=>_g,bitwiseAnd:()=>g1,booleanMaskAsync:()=>sk,broadcastArgs:()=>y1,broadcastTo:()=>_s,buffer:()=>ze,cast:()=>se,ceil:()=>Eg,clipByValue:()=>an,clone:()=>Br,complex:()=>la,concat:()=>it,concat1d:()=>$g,concat2d:()=>Ag,concat3d:()=>Fg,concat4d:()=>Rg,conv1d:()=>cc,conv2d:()=>fn,conv2dTranspose:()=>fc,conv3d:()=>Mg,conv3dTranspose:()=>Og,cos:()=>Jp,cosh:()=>mc,cosineWindow:()=>zc,cumprod:()=>dp,cumsum:()=>gc,denseBincount:()=>xh,depthToSpace:()=>Lg,depthwiseConv2d:()=>xo,diag:()=>x1,dilation2d:()=>zg,div:()=>fe,divNoNan:()=>Pg,dot:()=>Bg,dropout:()=>my,einsum:()=>ks,elu:()=>cu,enclosingPowerOfTwo:()=>gy,ensureShape:()=>w1,equal:()=>Wn,erf:()=>yc,euclideanNorm:()=>Ug,exp:()=>sn,expandDims:()=>Ht,expm1:()=>Gg,eye:()=>bc,fft:()=>od,fill:()=>Bn,floor:()=>mu,floorDiv:()=>dc,fused:()=>tl,gather:()=>gu,gatherND:()=>uk,greater:()=>xn,greaterEqual:()=>ca,ifft:()=>el,imag:()=>Yp,image:()=>Zn,inTopKAsync:()=>pk,irfft:()=>Ac,isFinite:()=>Hg,isInf:()=>jg,isNaN:()=>qg,leakyRelu:()=>Qp,less:()=>Zo,lessEqual:()=>rs,linalg:()=>xy,linspace:()=>T1,localResponseNormalization:()=>Kg,log:()=>Vn,log1p:()=>ed,logSigmoid:()=>Xg,logSoftmax:()=>vc,logSumExp:()=>td,logicalAnd:()=>dr,logicalNot:()=>nd,logicalOr:()=>wc,logicalXor:()=>Zg,losses:()=>kk,lowerBound:()=>_1,matMul:()=>Oe,max:()=>er,maxPool:()=>Vt,maxPool3d:()=>Jg,maxPoolWithArgmax:()=>E1,maximum:()=>Kr,mean:()=>xt,meshgrid:()=>$1,min:()=>Xo,minimum:()=>Va,mirrorPad:()=>Yg,mod:()=>Qg,moments:()=>rd,movingAverage:()=>ik,mul:()=>z,multiRNNCell:()=>A1,multinomial:()=>F1,neg:()=>ct,norm:()=>fu,notEqual:()=>Vs,oneHot:()=>Jo,ones:()=>Nn,onesLike:()=>Un,op:()=>L,outerProduct:()=>R1,pad:()=>_r,pad1d:()=>D1,pad2d:()=>M1,pad3d:()=>O1,pad4d:()=>L1,pool:()=>ey,pow:()=>Gr,prelu:()=>sd,print:()=>fg,prod:()=>ty,raggedGather:()=>z1,raggedRange:()=>P1,raggedTensorToTensor:()=>B1,rand:()=>W1,randomGamma:()=>H1,randomNormal:()=>Ic,randomStandardNormal:()=>j1,randomUniform:()=>as,randomUniformInt:()=>q1,range:()=>Us,real:()=>Yo,reciprocal:()=>iy,relu:()=>et,relu6:()=>Sc,reshape:()=>P,reverse:()=>rr,reverse1d:()=>K1,reverse2d:()=>X1,reverse3d:()=>Z1,reverse4d:()=>J1,rfft:()=>ld,round:()=>Nc,rsqrt:()=>Tc,scalar:()=>we,scatterND:()=>ok,searchSorted:()=>kc,selu:()=>Cc,separableConv2d:()=>yu,setdiff1dAsync:()=>Y1,sigmoid:()=>pr,sign:()=>oy,signal:()=>wk,sin:()=>_c,sinh:()=>Ec,slice:()=>Ue,slice1d:()=>id,slice2d:()=>$c,slice3d:()=>bu,slice4d:()=>Qo,softmax:()=>ss,softplus:()=>vo,spaceToBatchND:()=>ad,sparse:()=>Ik,sparseToDense:()=>lk,spectral:()=>vk,split:()=>Tn,sqrt:()=>Kt,square:()=>st,squaredDifference:()=>Fc,squeeze:()=>is,stack:()=>At,step:()=>wo,stridedSlice:()=>ly,string:()=>Sk,sub:()=>de,sum:()=>ge,tan:()=>uy,tanh:()=>Wa,tensor:()=>cn,tensor1d:()=>Ye,tensor2d:()=>Wr,tensor3d:()=>Rc,tensor4d:()=>Ua,tensor5d:()=>Q1,tensor6d:()=>ek,tensorScatterUpdate:()=>nk,tile:()=>Pn,topk:()=>dy,transpose:()=>Le,truncatedNormal:()=>Oc,unique:()=>hy,unsortedSegmentSum:()=>Lc,unstack:()=>St,upperBound:()=>rk,variable:()=>cy,where:()=>qt,whereAsync:()=>fy,zeros:()=>vt,zerosLike:()=>He});var hG=(e,t,n,r=Zt)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(k("a",e,t,n),k("b",e,t,n))];case"AddN":return[r.addN(k("tensors",e,t,n))];case"FloorMod":case"Mod":return[r.mod(k("a",e,t,n),k("b",e,t,n))];case"Mul":return[r.mul(k("a",e,t,n),k("b",e,t,n))];case"RealDiv":case"Div":return[r.div(k("a",e,t,n),k("b",e,t,n))];case"DivNoNan":return[r.divNoNan(k("a",e,t,n),k("b",e,t,n))];case"FloorDiv":return[r.floorDiv(k("a",e,t,n),k("b",e,t,n))];case"Sub":return[r.sub(k("a",e,t,n),k("b",e,t,n))];case"Minimum":return[r.minimum(k("a",e,t,n),k("b",e,t,n))];case"Maximum":return[r.maximum(k("a",e,t,n),k("b",e,t,n))];case"Pow":return[r.pow(k("a",e,t,n),k("b",e,t,n))];case"SquaredDifference":return[r.squaredDifference(k("a",e,t,n),k("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},cG=(e,t,n,r=Zt)=>{switch(e.op){case"Abs":case"ComplexAbs":return[r.abs(k("x",e,t,n))];case"Acos":return[r.acos(k("x",e,t,n))];case"Acosh":return[r.acosh(k("x",e,t,n))];case"Asin":return[r.asin(k("x",e,t,n))];case"Asinh":return[r.asinh(k("x",e,t,n))];case"Atan":return[r.atan(k("x",e,t,n))];case"Atan2":return[r.atan2(k("x",e,t,n),k("y",e,t,n))];case"Atanh":return[r.atanh(k("x",e,t,n))];case"Ceil":return[r.ceil(k("x",e,t,n))];case"Complex":return[r.complex(k("real",e,t,n),k("imag",e,t,n))];case"Cos":return[r.cos(k("x",e,t,n))];case"Cosh":return[r.cosh(k("x",e,t,n))];case"Elu":return[r.elu(k("x",e,t,n))];case"Erf":return[r.erf(k("x",e,t,n))];case"Exp":return[r.exp(k("x",e,t,n))];case"Expm1":return[r.expm1(k("x",e,t,n))];case"Floor":return[r.floor(k("x",e,t,n))];case"Log":return[r.log(k("x",e,t,n))];case"Log1p":return[r.log1p(k("x",e,t,n))];case"Imag":return[r.imag(k("x",e,t,n))];case"Neg":return[r.neg(k("x",e,t,n))];case"Reciprocal":return[r.reciprocal(k("x",e,t,n))];case"Real":return[r.real(k("x",e,t,n))];case"Relu":return[r.relu(k("x",e,t,n))];case"Round":return[r.round(k("x",e,t,n))];case"Selu":return[r.selu(k("x",e,t,n))];case"Sigmoid":return[r.sigmoid(k("x",e,t,n))];case"Sin":return[r.sin(k("x",e,t,n))];case"Sign":return[r.sign(k("x",e,t,n))];case"Sinh":return[r.sinh(k("x",e,t,n))];case"Softplus":return[r.softplus(k("x",e,t,n))];case"Sqrt":return[r.sqrt(k("x",e,t,n))];case"Square":return[r.square(k("x",e,t,n))];case"Tanh":return[r.tanh(k("x",e,t,n))];case"Tan":return[r.tan(k("x",e,t,n))];case"ClipByValue":return[r.clipByValue(k("x",e,t,n),k("clipValueMin",e,t,n),k("clipValueMax",e,t,n))];case"Relu6":return[r.relu6(k("x",e,t,n))];case"Rsqrt":return[r.rsqrt(en(e.inputNames[0],t,n))];case"LeakyRelu":return[r.leakyRelu(k("x",e,t,n),k("alpha",e,t,n))];case"Prelu":return[r.prelu(k("x",e,t,n),k("alpha",e,t,n))];case"IsNan":return[r.isNaN(en(e.inputNames[0],t,n))];case"IsInf":return[r.isInf(en(e.inputNames[0],t,n))];case"IsFinite":return[r.isFinite(en(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function ur(e,t,n=""){if(!(typeof e=="number"||typeof t=="number")){w.assert(e.length===t.length,()=>n+` Shapes ${e} and ${t} must match`);for(let r=0;r<e.length;r++){let a=e[r],s=t[r];w.assert(a<0||s<0||a===s,()=>n+` Shapes ${e} and ${t} must match`)}}}function Ew(e){return!(typeof e=="number"||e.some(t=>t<0))}function Bu(e,t,n){let r=Rm(e,n),a=!Ew(r);if(a&&t.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(a&&t.forEach(s=>{r=Rm(s.shape,r)}),!Ew(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function Rm(e,t){if(typeof e=="number")return t;if(typeof t=="number")return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);let n=[];for(let r=0;r<e.length;++r){let a=e[r],s=t[r];if(a>=0&&s>=0&&a!==s)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=a>=0?a:s}return n}var fG=class{constructor(e,t,n,r,a,s,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=a,this.dynamicSize=s,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=we(0),Mt(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),ur(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,Mt(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((n,r)=>this.write(n,t[r]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let r=0;r<this.size();r++)e.push(r)}if(e.length===0)return cn([],[0].concat(this.elementShape));let n=this.readMany(e);return ur(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),At(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return cn([],[0].concat(this.elementShape));let t=[];for(let r=0;r<this.size();r++)t.push(r);let n=this.readMany(t);return ur(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),it(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,St(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0,r=e.map(o=>(n+=o,n));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let a=n===0?0:t.size/n,s=[];B(()=>{t=P(t,[1,n,a]);for(let o=0;o<e.length;++o){let l=[0,o===0?0:r[o-1],0],p=[1,e[o],a];s[o]=P(Ue(t,l,p),this.elementShape)}return s});let i=[];for(let o=0;o<e.length;o++)i[o]=o;this.writeMany(i,s)}},cf=class Dm{get id(){return this.idTensor.id}constructor(t,n,r,a=-1){this.tensors=t,this.elementShape=n,this.elementDtype=r,t!=null&&t.forEach(s=>{if(r!==s.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${s.dtype}`);ur(n,s.shape,"TensorList shape mismatch: "),Mt(s)}),this.idTensor=we(0),this.maxNumElements=a,Mt(this.idTensor)}copy(){return new Dm([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(n=>{(t==null||!t.has(n.id))&&n.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,n,r=-1){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(r!==-1&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);ur(t,this.elementShape,"TensorList shape mismatch: ");let a=Bu(this.elementShape,this.tensors,t);return B(()=>{let s=this.tensors.map(i=>P(i,a));return At(s,0)})}popBack(t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");let r=Bu(this.elementShape,this.tensors,t),a=this.tensors.pop();return a.kept=!1,ur(a.shape,t,"TensorList shape mismatch: "),P(a,r)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(ur(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Mt(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(this.maxNumElements!==-1&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);let n=new Dm([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=t;for(let r=0;r<Math.min(this.tensors.length,t);++r)n.tensors[r]=this.tensors[r];return n}getItem(t,n,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(this.tensors[t]==null)throw new Error(`element at index ${t} is null.`);ur(this.tensors[t].shape,n,"TensorList shape mismatch: ");let a=Bu(this.elementShape,this.tensors,n);return P(this.tensors[t],a)}setItem(t,n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(t<0||this.maxNumElements!==-1&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);ur(this.elementShape,n.shape,"TensorList shape mismatch: "),Mt(n),this.tensors[t]!=null&&(this.tensors[t].kept=!1),this.tensors[t]=n}gather(t,n,r){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);ur(this.elementShape,r,"TensorList shape mismatch: "),t=t.slice(0,this.size());let a=Bu(this.elementShape,this.tensors,r);return t.length===0?cn([],[0].concat(a)):B(()=>{let s=t.map(i=>P(this.tensors[i],a));return At(s,0)})}concat(t,n){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);ur(this.elementShape,n,"TensorList shape mismatch: ");let r=Bu(this.elementShape,this.tensors,n);return this.size()===0?cn([],[0].concat(r)):B(()=>{let a=this.tensors.map(s=>P(s,r));return it(a,0)})}};function mG(e,t,n){let r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);let a=e.shape.slice(1);ur(a,t,"TensorList shape mismatch: ");let s=St(e);return new cf(s,t,r)}function gG(e,t,n,r){return new cf([],e,t,r)}function yG(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let a=Math.max(...t);if(r!=null&&r!==-1&&a>=r)throw new Error(`Max index must be < array size (${a}  vs. ${r})`);let s=new cf([],n,e.dtype,r),i=St(e,0);return t.forEach((o,l)=>{s.setItem(o,i[l])}),s}function bG(e,t,n){let r=0,a=t.map(u=>(r+=u,r));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${e.shape}`);let s=e.shape.slice(1),i=Rm(s,n),o=r===0?0:e.size/r,l=B(()=>{let u=[];e=P(e,[1,r,o]);for(let d=0;d<t.length;++d){let h=[0,d===0?0:a[d-1],0],c=[1,t[d],o];u[d]=P(Ue(e,h,c),i)}return e.dispose(),u}),p=new cf([],n,e.dtype,t.length);for(let u=0;u<l.length;u++)p.setItem(u,l[u]);return p}var xG=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{let r=k("thenBranch",e,t,n),a=k("elseBranch",e,t,n),s=k("cond",e,t,n),i=k("args",e,t,n);return(await s.data())[0]?n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[a].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{let r=k("body",e,t,n),a=k("cond",e,t,n),s=k("args",e,t,n),i=await n.functionMap[a].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap),o=s.map(u=>u.id),l=await i[0].data();i.forEach(u=>{!u.kept&&o.indexOf(u.id)===-1&&u.dispose()});let p=s;for(;l[0];){let u=p;p=await n.functionMap[r].executeFunctionAsync(p,n.tensorArrayMap,n.tensorListMap);let d=p.map(c=>c.id);u.forEach(c=>{!c.kept&&o.indexOf(c.id)===-1&&d.indexOf(c.id)===-1&&c.dispose()});let h=await n.functionMap[a].executeFunctionAsync(p,n.tensorArrayMap,n.tensorListMap);l=await h[0].data(),h.forEach(c=>{!c.kept&&o.indexOf(c.id)===-1&&d.indexOf(c.id)===-1&&c.dispose()})}return p}case"LoopCond":{let r=k("pred",e,t,n);return[ra(r)]}case"Switch":{let r=k("pred",e,t,n),a=k("data",e,t,n);return a.kept||(a=ra(a)),(await r.data())[0]?[void 0,a]:[a,void 0]}case"Merge":{let r=e.inputNames.find(a=>en(a,t,n)!==void 0);if(r){let a=en(r,t,n);return[ra(a)]}return}case"Enter":{let r=k("frameName",e,t,n),a=k("tensor",e,t,n);return n.enterFrame(r),[ra(a)]}case"Exit":{let r=k("tensor",e,t,n);return n.exitFrame(),[ra(r)]}case"NextIteration":{let r=k("tensor",e,t,n);return n.nextIteration(),[ra(r)]}case"TensorArrayV3":{let r=k("size",e,t,n),a=k("dtype",e,t,n),s=k("elementShape",e,t,n),i=k("dynamicSize",e,t,n),o=k("clearAfterRead",e,t,n),l=k("identicalElementShapes",e,t,n),p=k("name",e,t,n),u=new fG(p,a,r,s,l,i,o);return n.addTensorArray(u),[u.idTensor,we(1)]}case"TensorArrayWriteV3":{let r=k("tensorArrayId",e,t,n),a=k("index",e,t,n),s=k("tensor",e,t,n),i=n.getTensorArray(r.id);return i.write(a,s),[i.idTensor]}case"TensorArrayReadV3":{let r=k("tensorArrayId",e,t,n),a=k("index",e,t,n);return[n.getTensorArray(r.id).read(a)]}case"TensorArrayGatherV3":{let r=k("tensorArrayId",e,t,n),a=k("indices",e,t,n),s=k("dtype",e,t,n);return[n.getTensorArray(r.id).gather(a,s)]}case"TensorArrayScatterV3":{let r=k("tensorArrayId",e,t,n),a=k("indices",e,t,n),s=k("tensor",e,t,n),i=n.getTensorArray(r.id);return i.scatter(a,s),[i.idTensor]}case"TensorArrayConcatV3":{let r=k("tensorArrayId",e,t,n),a=n.getTensorArray(r.id),s=k("dtype",e,t,n);return[a.concat(s)]}case"TensorArraySplitV3":{let r=k("tensorArrayId",e,t,n),a=k("tensor",e,t,n),s=k("lengths",e,t,n),i=n.getTensorArray(r.id);return i.split(s,a),[i.idTensor]}case"TensorArraySizeV3":{let r=k("tensorArrayId",e,t,n),a=n.getTensorArray(r.id);return[we(a.size(),"int32")]}case"TensorArrayCloseV3":{let r=k("tensorArrayId",e,t,n),a=n.getTensorArray(r.id);return a.clearAndClose(),[a.idTensor]}case"TensorListSetItem":{let r=k("tensorListId",e,t,n),a=k("index",e,t,n),s=k("tensor",e,t,n),i=n.getTensorList(r.id);return i.setItem(a,s),[i.idTensor]}case"TensorListGetItem":{let r=k("tensorListId",e,t,n),a=k("index",e,t,n),s=k("elementShape",e,t,n),i=k("elementDType",e,t,n);return[n.getTensorList(r.id).getItem(a,s,i)]}case"TensorListScatterV2":case"TensorListScatter":{let r=k("indices",e,t,n),a=k("tensor",e,t,n),s=k("elementShape",e,t,n),i=k("numElements",e,t,n),o=yG(a,r,s,i);return n.addTensorList(o),[o.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let r=k("elementShape",e,t,n),a=k("elementDType",e,t,n),s;e.op==="TensorListReserve"?s="numElements":s="maxNumElements";let i=k(s,e,t,n),o=e.op==="TensorListReserve"?-1:i,l=gG(r,a,i,o);return n.addTensorList(l),[l.idTensor]}case"TensorListGather":{let r=k("tensorListId",e,t,n),a=k("indices",e,t,n),s=k("elementShape",e,t,n),i=k("elementDType",e,t,n);return[n.getTensorList(r.id).gather(a,i,s)]}case"TensorListStack":{let r=k("tensorListId",e,t,n),a=k("elementShape",e,t,n),s=k("elementDType",e,t,n),i=k("numElements",e,t,n);return[n.getTensorList(r.id).stack(a,s,i)]}case"TensorListFromTensor":{let r=k("tensor",e,t,n),a=k("elementShape",e,t,n),s=k("elementDType",e,t,n),i=mG(r,a,s);return n.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let r=k("tensorListId",e,t,n),a=n.getTensorList(r.id),s=k("dtype",e,t,n),i=k("elementShape",e,t,n);return[a.concat(s,i)]}case"TensorListPushBack":{let r=k("tensorListId",e,t,n),a=k("tensor",e,t,n),s=n.getTensorList(r.id);return s.pushBack(a),[s.idTensor]}case"TensorListPopBack":{let r=k("tensorListId",e,t,n),a=k("elementShape",e,t,n),s=k("elementDType",e,t,n);return[n.getTensorList(r.id).popBack(a,s)]}case"TensorListSplit":{let r=k("tensor",e,t,n),a=k("elementShape",e,t,n),s=k("lengths",e,t,n),i=bG(r,s,a);return n.addTensorList(i),[i.idTensor]}case"TensorListLength":{let r=k("tensorListId",e,t,n),a=n.getTensorList(r.id);return[we(a.size(),"int32")]}case"TensorListResize":{let r=k("tensorListId",e,t,n),a=k("size",e,t,n),s=n.getTensorList(r.id).resize(a);return n.addTensorList(s),[s.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function $w(e,t,n){let[r,a]=k("fusedOps",e,t,n),s=r==="biasadd",i=!s,o=a==="prelu",l=r==="fusedbatchnorm",p=k("numArgs",e,t,n);if(s){if(o&&p!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&s&&p!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let u=k("strides",e,t,n),d=ih(e,t,n),h=k("dataFormat",e,t,n).toUpperCase(),c=k("dilations",e,t,n),[f,m]=k("args",e,t,n);i&&(m=f,f=void 0);let g=k("leakyreluAlpha",e,t,n);return{stride:u,pad:d,dataFormat:h,dilations:c,biasArg:f,preluArg:m,activationFunc:a,leakyreluAlpha:g}}var vG=(e,t,n,r=Zt)=>{switch(e.op){case"Conv1D":{let a=k("stride",e,t,n),s=k("pad",e,t,n),i=k("dataFormat",e,t,n).toUpperCase(),o=k("dilation",e,t,n);return[r.conv1d(k("x",e,t,n),k("filter",e,t,n),a,s,i,o)]}case"Conv2D":{let a=k("strides",e,t,n),s=ih(e,t,n),i=k("dataFormat",e,t,n).toUpperCase(),o=k("dilations",e,t,n);return[r.conv2d(k("x",e,t,n),k("filter",e,t,n),[a[1],a[2]],s,i,[o[1],o[2]])]}case"_FusedConv2D":{let{stride:a,pad:s,dataFormat:i,dilations:o,biasArg:l,preluArg:p,activationFunc:u,leakyreluAlpha:d}=$w(e,t,n);return[r.fused.conv2d({x:k("x",e,t,n),filter:k("filter",e,t,n),strides:[a[1],a[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:u,preluActivationWeights:p,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{let{stride:a,pad:s,dataFormat:i,dilations:o,biasArg:l,preluArg:p,activationFunc:u,leakyreluAlpha:d}=$w(e,t,n);return[r.fused.depthwiseConv2d({x:k("x",e,t,n),filter:k("filter",e,t,n),strides:[a[1],a[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:u,preluActivationWeights:p,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let a=k("outputShape",e,t,n),s=k("strides",e,t,n),i=ih(e,t,n);return[r.conv2dTranspose(k("x",e,t,n),k("filter",e,t,n),a,[s[1],s[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let a=k("strides",e,t,n),s=ih(e,t,n),i=k("dilations",e,t,n),o=k("dataFormat",e,t,n).toUpperCase();return[r.depthwiseConv2d(k("input",e,t,n),k("filter",e,t,n),[a[1],a[2]],s,o,[i[1],i[2]])]}case"Conv3D":{let a=k("strides",e,t,n),s=k("pad",e,t,n),i=k("dataFormat",e,t,n).toUpperCase(),o=k("dilations",e,t,n);return[r.conv3d(k("x",e,t,n),k("filter",e,t,n),[a[1],a[2],a[3]],s,i,[o[1],o[2],o[3]])]}case"AvgPool":{let a=k("strides",e,t,n),s=k("pad",e,t,n),i=k("kernelSize",e,t,n);return[r.avgPool(k("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s)]}case"MaxPool":{let a=k("strides",e,t,n),s=k("pad",e,t,n),i=k("kernelSize",e,t,n);return[r.maxPool(k("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s)]}case"MaxPoolWithArgmax":{let a=k("strides",e,t,n),s=k("pad",e,t,n),i=k("kernelSize",e,t,n),o=k("includeBatchInIndex",e,t,n),{result:l,indexes:p}=r.maxPoolWithArgmax(k("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s,o);return[l,p]}case"AvgPool3D":{let a=k("strides",e,t,n),s=k("pad",e,t,n),i=k("kernelSize",e,t,n);return[r.avgPool3d(k("x",e,t,n),[i[1],i[2],i[3]],[a[1],a[2],a[3]],s)]}case"MaxPool3D":{let a=k("strides",e,t,n),s=k("pad",e,t,n),i=k("kernelSize",e,t,n);return[r.maxPool3d(k("x",e,t,n),[i[1],i[2],i[3]],[a[1],a[2],a[3]],s)]}case"Dilation2D":{let a=k("strides",e,t,n),s=k("pad",e,t,n),i=k("dilations",e,t,n),o=a[1],l=a[2],p=i[1],u=i[2];return[r.dilation2d(k("x",e,t,n),k("filter",e,t,n),[o,l],s,[p,u],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},wG=(e,t,n,r=Zt)=>{switch(e.op){case"Fill":{let a=k("shape",e,t,n),s=k("dtype",e,t,n),i=k("value",e,t,n);return[r.fill(a,i,s)]}case"LinSpace":{let a=k("start",e,t,n),s=k("stop",e,t,n),i=k("num",e,t,n);return[r.linspace(a,s,i)]}case"Multinomial":{let a=k("logits",e,t,n),s=k("numSamples",e,t,n),i=k("seed",e,t,n);return[r.multinomial(a,s,i)]}case"OneHot":{let a=k("indices",e,t,n),s=k("depth",e,t,n),i=k("onValue",e,t,n),o=k("offValue",e,t,n),l=k("dtype",e,t,n);return[r.oneHot(a,s,i,o,l)]}case"Ones":return[r.ones(k("shape",e,t,n),k("dtype",e,t,n))];case"OnesLike":return[r.onesLike(k("x",e,t,n))];case"RandomStandardNormal":return[r.randomStandardNormal(k("shape",e,t,n),k("dtype",e,t,n),k("seed",e,t,n))];case"RandomUniform":return[r.randomUniform(k("shape",e,t,n),k("minval",e,t,n),k("maxval",e,t,n),k("dtype",e,t,n))];case"RandomUniformInt":return[r.randomUniformInt(k("shape",e,t,n),k("minval",e,t,n),k("maxval",e,t,n),k("seed",e,t,n))];case"Range":{let a=k("start",e,t,n),s=k("stop",e,t,n),i=k("step",e,t,n);return[r.range(a,s,i,k("dtype",e,t,n))]}case"TruncatedNormal":{let a=k("shape",e,t,n),s=k("mean",e,t,n),i=k("stdDev",e,t,n),o=k("seed",e,t,n);return[r.truncatedNormal(a,s,i,k("dtype",e,t,n),o)]}case"Zeros":return[r.zeros(k("shape",e,t,n),k("dtype",e,t,n))];case"ZerosLike":return[r.zerosLike(k("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function Bf(e,t,n){let r=k("boxes",e,t,n),a=k("scores",e,t,n),s=k("maxOutputSize",e,t,n),i=k("iouThreshold",e,t,n),o=k("scoreThreshold",e,t,n),l=k("softNmsSigma",e,t,n);return{boxes:r,scores:a,maxOutputSize:s,iouThreshold:i,scoreThreshold:o,softNmsSigma:l}}var kG=async(e,t,n,r,a=Zt)=>{switch(e.op){case"NonMaxSuppressionV5":{let{boxes:s,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:p,softNmsSigma:u}=Bf(e,t,n),d=await a.image.nonMaxSuppressionWithScoreAsync(s,i,o,l,p,u);return[d.selectedIndices,d.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:s,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:p}=Bf(e,t,n),u=k("padToMaxOutputSize",e,t,n),d=await a.image.nonMaxSuppressionPaddedAsync(s,i,o,l,p,u);return[d.selectedIndices,d.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:s,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:p}=Bf(e,t,n);return[await a.image.nonMaxSuppressionAsync(s,i,o,l,p)]}case"Where":{let s=a.cast(k("condition",e,t,n),"bool"),i=[await a.whereAsync(s)];return s.dispose(),i}case"ListDiff":return a.setdiff1dAsync(k("x",e,t,n),k("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}},IG=(e,t,n,r=Zt)=>{switch(e.op){case"LowerBound":{let a=k("sortedSequence",e,t,n),s=k("values",e,t,n);return[r.lowerBound(a,s)]}case"TopKV2":{let a=k("x",e,t,n),s=k("k",e,t,n),i=k("sorted",e,t,n),o=r.topk(a,s,i);return[o.values,o.indices]}case"UpperBound":{let a=k("sortedSequence",e,t,n),s=k("values",e,t,n);return[r.upperBound(a,s)]}case"Unique":{let a=k("x",e,t,n),s=r.unique(a);return[s.values,s.indices]}case"UniqueV2":{let a=k("x",e,t,n),s=k("axis",e,t,n),i=r.unique(a,s);return[i.values,i.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},SG=(e,t,n,r=Zt)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":let a=k("default",e,t,n);return[en(e.name,t,n)||a];case"Placeholder":return[en(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let u=k("x",e,t,n);return[ra(u)]}case"IdentityN":return k("x",e,t,n).map(u=>ra(u));case"Snapshot":let s=k("x",e,t,n);return[ra(s)];case"Shape":return[r.tensor1d(k("x",e,t,n).shape,"int32")];case"ShapeN":return k("x",e,t,n).map(u=>r.tensor1d(u.shape));case"Size":return[r.scalar(k("x",e,t,n).size,"int32")];case"Rank":return[r.scalar(k("x",e,t,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":let i=k("x",e,t,n),o=k("data",e,t,n),l=k("message",e,t,n),p=k("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let u=0;u<o.length;u++)console.log(Array.prototype.slice.call(o[u].dataSync()).slice(0,p));return[i];default:throw TypeError(`Node type ${e.op} is not implemented`)}},NG=class{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=we(0),this.tensorMap=new Map,Mt(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return we(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),B(()=>{let r=St(t),a=n.length,s=r.length;w.assert(a===s,()=>`The number of elements doesn't match, keys has ${a} elements, the values has ${s} elements.`);for(let i=0;i<a;i++){let o=n[i],l=r[i];Mt(l),this.tensorMap.set(o,l)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return B(()=>{let r=[];for(let a=0;a<n.length;a++){let s=n[a],i=this.findWithDefault(s,t);r.push(i)}return At(r)})}findWithDefault(e,t){let n=this.tensorMap.get(e);return n??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}},TG=async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{let a=r.getHashTableHandleByName(e.name);if(a!=null)return[a];{let s=k("keyDType",e,t,n),i=k("valueDType",e,t,n),o=new NG(s,i);return r.addHashTable(e.name,o),[o.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{let a=k("tableHandle",e,t,n,r),s=k("keys",e,t,n),i=k("values",e,t,n);return[await r.getHashTableById(a.id).import(s,i)]}case"LookupTableFind":case"LookupTableFindV2":{let a=k("tableHandle",e,t,n,r),s=k("keys",e,t,n),i=k("defaultValue",e,t,n);return[await r.getHashTableById(a.id).find(s,i)]}case"LookupTableSize":case"LookupTableSizeV2":{let a=k("tableHandle",e,t,n,r);return[r.getHashTableById(a.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},CG=(e,t,n,r=Zt)=>{switch(e.op){case"ResizeBilinear":{let a=k("images",e,t,n),s=k("size",e,t,n),i=k("alignCorners",e,t,n),o=k("halfPixelCenters",e,t,n);return[r.image.resizeBilinear(a,[s[0],s[1]],i,o)]}case"ResizeNearestNeighbor":{let a=k("images",e,t,n),s=k("size",e,t,n),i=k("alignCorners",e,t,n),o=k("halfPixelCenters",e,t,n);return[r.image.resizeNearestNeighbor(a,[s[0],s[1]],i,o)]}case"CropAndResize":{let a=k("image",e,t,n),s=k("boxes",e,t,n),i=k("boxInd",e,t,n),o=k("cropSize",e,t,n),l=k("method",e,t,n),p=k("extrapolationValue",e,t,n);return[r.image.cropAndResize(a,s,i,o,l,p)]}case"ImageProjectiveTransformV3":{let a=k("images",e,t,n),s=k("transforms",e,t,n),i=k("outputShape",e,t,n),o=k("fillValue",e,t,n),l=k("interpolation",e,t,n),p=k("fillMode",e,t,n);return[r.image.transform(a,s,l.toLowerCase(),p.toLowerCase(),o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},_G=(e,t,n,r=Zt)=>{switch(e.op){case"Equal":return[r.equal(k("a",e,t,n),k("b",e,t,n))];case"NotEqual":return[r.notEqual(k("a",e,t,n),k("b",e,t,n))];case"Greater":return[r.greater(k("a",e,t,n),k("b",e,t,n))];case"GreaterEqual":return[r.greaterEqual(k("a",e,t,n),k("b",e,t,n))];case"Less":return[r.less(k("a",e,t,n),k("b",e,t,n))];case"LessEqual":return[r.lessEqual(k("a",e,t,n),k("b",e,t,n))];case"LogicalAnd":return[r.logicalAnd(k("a",e,t,n),k("b",e,t,n))];case"LogicalNot":return[r.logicalNot(k("a",e,t,n))];case"LogicalOr":return[r.logicalOr(k("a",e,t,n),k("b",e,t,n))];case"Select":case"SelectV2":return[r.where(k("condition",e,t,n),k("a",e,t,n),k("b",e,t,n))];case"BitwiseAnd":return[r.bitwiseAnd(k("a",e,t,n),k("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},EG=(e,t,n,r=Zt)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(k("a",e,t,n),k("b",e,t,n),k("transposeA",e,t,n),k("transposeB",e,t,n))];case"Einsum":return[r.einsum(k("equation",e,t,n),...k("tensors",e,t,n))];case"Transpose":return[r.transpose(k("x",e,t,n),k("perm",e,t,n))];case"_FusedMatMul":let[a,s]=k("fusedOps",e,t,n),i=a==="biasadd",o=s==="prelu",l=k("numArgs",e,t,n),p=k("leakyreluAlpha",e,t,n);if(i){if(o&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[u,d]=k("args",e,t,n);return[r.fused.matMul({a:k("a",e,t,n),b:k("b",e,t,n),transposeA:k("transposeA",e,t,n),transposeB:k("transposeB",e,t,n),bias:u,activation:s,preluActivationWeights:d,leakyreluAlpha:p})];case"MatrixBandPart":return[r.linalg.bandPart(k("a",e,t,n),k("numLower",e,t,n),k("numUpper",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},$G=(e,t,n,r=Zt)=>{switch(e.op){case"EuclideanNorm":return[r.euclideanNorm(k("x",e,t,n),k("axis",e,t,n),k("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[r.batchNorm(k("x",e,t,n),k("mean",e,t,n),k("variance",e,t,n),k("offset",e,t,n),k("scale",e,t,n),k("epsilon",e,t,n))];case"FusedBatchNormV3":return[r.batchNorm(k("x",e,t,n),k("mean",e,t,n),k("variance",e,t,n),k("offset",e,t,n),k("scale",e,t,n),k("epsilon",e,t,n))];case"LRN":return[r.localResponseNormalization(k("x",e,t,n),k("radius",e,t,n),k("bias",e,t,n),k("alpha",e,t,n),k("beta",e,t,n))];case"Softmax":return[r.softmax(k("x",e,t,n))];case"LogSoftmax":return[r.logSoftmax(k("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},AG=(e,t,n,r=Zt)=>{switch(e.op){case"RaggedGather":{let{outputNestedSplits:a,outputDenseValues:s}=r.raggedGather(k("paramsNestedSplits",e,t,n),k("paramsDenseValues",e,t,n),k("indices",e,t,n),k("outputRaggedRank",e,t,n));return a.concat(s)}case"RaggedRange":{let{rtNestedSplits:a,rtDenseValues:s}=r.raggedRange(k("starts",e,t,n),k("limits",e,t,n),k("splits",e,t,n));return[a,s]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(k("shape",e,t,n),k("values",e,t,n),k("defaultValue",e,t,n),k("rowPartitionTensors",e,t,n),k("rowPartitionTypes",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},FG=(e,t,n,r=Zt)=>{switch(e.op){case"Max":{let o=k("axis",e,t,n),l=k("keepDims",e,t,n);return[r.max(k("x",e,t,n),o,l)]}case"Mean":{let o=k("axis",e,t,n),l=k("keepDims",e,t,n);return[r.mean(k("x",e,t,n),o,l)]}case"Min":{let o=k("axis",e,t,n),l=k("keepDims",e,t,n);return[r.min(k("x",e,t,n),o,l)]}case"Sum":{let o=k("axis",e,t,n),l=k("keepDims",e,t,n);return[r.sum(k("x",e,t,n),o,l)]}case"All":{let o=k("axis",e,t,n),l=k("keepDims",e,t,n);return[r.all(k("x",e,t,n),o,l)]}case"Any":{let o=k("axis",e,t,n),l=k("keepDims",e,t,n);return[r.any(k("x",e,t,n),o,l)]}case"ArgMax":{let o=k("axis",e,t,n);return[r.argMax(k("x",e,t,n),o)]}case"ArgMin":{let o=k("axis",e,t,n);return[r.argMin(k("x",e,t,n),o)]}case"Prod":{let o=k("axis",e,t,n),l=k("keepDims",e,t,n);return[r.prod(k("x",e,t,n),o,l)]}case"Cumprod":{let o=k("axis",e,t,n),l=k("exclusive",e,t,n),p=k("reverse",e,t,n);return[r.cumprod(k("x",e,t,n),o,l,p)]}case"Cumsum":{let o=k("axis",e,t,n),l=k("exclusive",e,t,n),p=k("reverse",e,t,n);return[r.cumsum(k("x",e,t,n),o,l,p)]}case"Bincount":let a=k("x",e,t,n),s=k("weights",e,t,n),i=k("size",e,t,n);return[r.bincount(a,s,i)];case"DenseBincount":{let o=k("x",e,t,n),l=k("weights",e,t,n),p=k("size",e,t,n),u=k("binaryOutput",e,t,n);return[r.denseBincount(o,l,p,u)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},RG=(e,t,n,r=Zt)=>{switch(e.op){case"ConcatV2":case"Concat":{let a=k("n",e,t,n),s=k("axis",e,t,n),i=k("tensors",e,t,n);return i=i.slice(0,a),[r.concat(i,s)]}case"Gather":{let a=k("x",e,t,n),s=k("indices",e,t,n);return[r.gather(a,r.cast(s,"int32"),0)]}case"GatherV2":{let a=k("axis",e,t,n),s=k("batchDims",e,t,n),i=k("x",e,t,n),o=k("indices",e,t,n);return[r.gather(i,r.cast(o,"int32"),a,s)]}case"Reverse":{let a=k("dims",e,t,n),s=[];for(let o=0;o<a.length;o++)a[o]&&s.push(o);let i=k("x",e,t,n);return[r.reverse(i,s)]}case"ReverseV2":{let a=k("axis",e,t,n),s=k("x",e,t,n);return[r.reverse(s,a)]}case"Slice":{let a=k("begin",e,t,n),s=k("size",e,t,n);return[r.slice(k("x",e,t,n),a,s)]}case"StridedSlice":{let a=k("begin",e,t,n),s=k("end",e,t,n),i=k("strides",e,t,n),o=k("beginMask",e,t,n),l=k("endMask",e,t,n),p=k("ellipsisMask",e,t,n),u=k("newAxisMask",e,t,n),d=k("shrinkAxisMask",e,t,n),h=k("x",e,t,n);return[r.stridedSlice(h,a,s,i,o,l,p,u,d)]}case"Pack":return B(()=>{let a=k("axis",e,t,n),s=k("tensors",e,t,n),i=s[0].shape,o=r.squeeze(s[0]).shape,l=s.map(p=>{let u=w.arraysEqual(p.shape,i);if(!u&&!w.arraysEqual(r.squeeze(p).shape,o))throw new Error("the input tensors shape does not match");return u?p:r.reshape(p,i)});return[r.stack(l,a)]});case"Unpack":{let a=k("axis",e,t,n),s=k("tensor",e,t,n);return r.unstack(s,a)}case"Tile":{let a=k("reps",e,t,n);return[r.tile(k("x",e,t,n),a)]}case"Split":case"SplitV":{let a=k("axis",e,t,n),s=k("numOrSizeSplits",e,t,n),i=k("x",e,t,n);return r.split(i,s,a)}case"ScatterNd":{let a=k("indices",e,t,n),s=k("values",e,t,n),i=k("shape",e,t,n);return[r.scatterND(a,s,i)]}case"GatherNd":{let a=k("x",e,t,n),s=k("indices",e,t,n);return[r.gatherND(a,s)]}case"SparseToDense":{let a=k("sparseIndices",e,t,n),s=k("outputShape",e,t,n),i=k("sparseValues",e,t,n),o=k("defaultValue",e,t,n);return[r.sparseToDense(a,i,s,i.dtype===o.dtype?o:r.cast(o,i.dtype))]}case"TensorScatterUpdate":{let a=k("indices",e,t,n),s=k("values",e,t,n),i=k("tensor",e,t,n);return[r.tensorScatterUpdate(i,a,s)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},DG=(e,t,n,r=Zt)=>{switch(e.op){case"SparseFillEmptyRows":{let{outputIndices:a,outputValues:s,emptyRowIndicator:i,reverseIndexMap:o}=r.sparse.sparseFillEmptyRows(k("indices",e,t,n),k("values",e,t,n),k("denseShape",e,t,n),k("defaultValue",e,t,n));return[a,s,i,o]}case"SparseReshape":{let{outputIndices:a,outputShape:s}=r.sparse.sparseReshape(k("inputIndices",e,t,n),k("inputShape",e,t,n),k("newShape",e,t,n));return[a,s]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(k("data",e,t,n),k("indices",e,t,n),k("segmentIds",e,t,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(k("data",e,t,n),k("indices",e,t,n),k("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},MG=(e,t,n,r=Zt)=>{switch(e.op){case"FFT":return[r.fft(k("x",e,t,n))];case"IFFT":return[r.ifft(k("x",e,t,n))];case"RFFT":return[r.rfft(k("x",e,t,n))];case"IRFFT":return[r.irfft(k("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},OG=(e,t,n,r=Zt)=>{switch(e.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(k("input",e,t,n),k("pattern",e,t,n),k("rewrite",e,t,n),k("replaceGlobal",e,t,n))];case"StringNGrams":{let{nGrams:a,nGramsSplits:s}=r.string.stringNGrams(k("data",e,t,n),k("dataSplits",e,t,n),k("separator",e,t,n),k("nGramWidths",e,t,n),k("leftPad",e,t,n),k("rightPad",e,t,n),k("padWidth",e,t,n),k("preserveShortSequences",e,t,n));return[a,s]}case"StringSplit":{let{indices:a,values:s,shape:i}=r.string.stringSplit(k("input",e,t,n),k("delimiter",e,t,n),k("skipEmpty",e,t,n));return[a,s,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(k("input",e,t,n),k("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},LG=(e,t,n,r=Zt)=>{switch(e.op){case"Cast":return[r.cast(k("x",e,t,n),k("dtype",e,t,n))];case"ExpandDims":{let a=k("axis",e,t,n);return[r.expandDims(k("x",e,t,n),a)]}case"Squeeze":{let a=k("axis",e,t,n);return[r.squeeze(k("x",e,t,n),a)]}case"Reshape":return[r.reshape(k("x",e,t,n),k("shape",e,t,n))];case"EnsureShape":return[r.ensureShape(k("x",e,t,n),k("shape",e,t,n))];case"MirrorPad":return[r.mirrorPad(k("x",e,t,n),k("padding",e,t,n),k("mode",e,t,n))];case"PadV2":case"Pad":return[r.pad(k("x",e,t,n),k("padding",e,t,n),k("constantValue",e,t,n))];case"SpaceToBatchND":{let a=k("blockShape",e,t,n),s=k("paddings",e,t,n);return[r.spaceToBatchND(k("x",e,t,n),a,s)]}case"BatchToSpaceND":{let a=k("blockShape",e,t,n),s=k("crops",e,t,n);return[r.batchToSpaceND(k("x",e,t,n),a,s)]}case"DepthToSpace":{let a=k("blockSize",e,t,n),s=k("dataFormat",e,t,n).toUpperCase();return[r.depthToSpace(k("x",e,t,n),a,s)]}case"BroadcastTo":return[r.broadcastTo(k("x",e,t,n),k("shape",e,t,n))];case"BroadcastArgs":return[r.broadcastArgs(k("s0",e,t,n),k("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function Aw(e,t,n,r,a=B){let s=((i,o,l)=>{switch(i.category){case"arithmetic":return a(()=>hG(i,o,l));case"basic_math":return a(()=>cG(i,o,l));case"control":return xG(i,o,l);case"convolution":return a(()=>vG(i,o,l));case"creation":return a(()=>wG(i,o,l));case"dynamic":return kG(i,o,l);case"evaluation":return a(()=>IG(i,o,l));case"image":return a(()=>CG(i,o,l));case"graph":return a(()=>SG(i,o,l));case"logical":return a(()=>_G(i,o,l));case"matrices":return a(()=>EG(i,o,l));case"normalization":return a(()=>$G(i,o,l));case"ragged":return a(()=>AG(i,o,l));case"reduction":return a(()=>FG(i,o,l));case"slice_join":return a(()=>RG(i,o,l));case"sparse":return a(()=>DG(i,o,l));case"spectral":return a(()=>MG(i,o,l));case"string":return a(()=>OG(i,o,l));case"transformation":return a(()=>LG(i,o,l));case"hash_table":return TG(i,o,l,r);case"custom":let p=$S(i.op);if(p&&p.customExecutor)return p.customExecutor(new dG(i,o,l));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return w.isPromise(s)?s.then(i=>[].concat(i)):[].concat(s)}var Fw=class{constructor(e={},t={},n={},r={},a){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.parseNodeNameCache=a,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}};function Rw(e,t,n,r){let a=new Set,s=[],i=null,o=null,l=new Set,p=new Set(Object.keys(e).map(h=>Ln(h)[0]));r=r||[];let u=new Set(r.map(h=>Ln(h.name)[0])),d=[...t];for(;d.length>0;){let h=d.pop();if((Ss(h)||HG(h)||jG(h))&&i==null&&(i=h,o=i.children.map(c=>c.name).filter(c=>a.has(c))),a.add(h.name),n[h.name]==null&&!p.has(h.name)&&!u.has(h.name)){if(h.inputs.length===0){s.push(h.name);continue}h.inputs.forEach(c=>{l.has(c.name)||(l.add(c.name),d.push(c))})}}return{inputs:e,outputs:t,usedNodes:a,missingInputs:s,dynamicNode:i,syncInputs:o}}function zG(e,t){let{usedNodes:n,inputs:r}=t,a=Object.keys(r).map(g=>Ln(g)[0]).map(g=>e.nodes[g]),s=e.initNodes||[],i=g=>n.has(typeof g=="string"?g:g.name);function o(g){return[...new Map(g.map(y=>[y.name,y])).values()]}let l=o([...a,...e.weights,...s]).filter(i),p=o([...l,...Object.values(e.nodes)]).filter(i),u=new Map(p.map(g=>[g.name,g])),d={};for(let g of p){d[g.name]=d[g.name]||0;for(let y of g.children)i(y)||(d[y.name]=Number.POSITIVE_INFINITY),d[y.name]=(d[y.name]||0)+1}let h=Object.entries(d).filter(([,g])=>g===0).map(([g])=>g),c=[...h];for(;h.length>0;){let g=h.pop(),y=u.get(g);for(let b of y.children.filter(i))--d[b.name]===0&&(c.push(b.name),h.push(b.name))}let f=c.map(g=>u.get(g)),m=PG(f,l);return BG(m,l),m}function PG(e,t){let n=new Map(e.map(s=>[s.name,s])),r=t.map(s=>s.name),a=new Set(r);for(;r.length>0;){let s=r.pop(),i=n.get(s);for(let o of i.children)!n.has(o.name)||a.has(o.name)||(a.add(o.name),r.push(o.name))}return e.filter(s=>a.has(s.name))}var Kd=class extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}};function BG(e,t){let n=new Map(e.map((o,l)=>[o.name,l])),r=new Set(t.map(o=>o.name)),a=o=>r.has(typeof o=="string"?o:o.name),s=new Set(e.map(o=>o.name)),i=o=>s.has(typeof o=="string"?o:o.name);for(let o of e){for(let l of o.children.filter(i)){if(!n.has(l.name))throw new Kd(`Child ${l.name} of node ${o.name} is unreachable.`);if(n.get(o.name)>n.get(l.name))throw new Kd(`Node ${o.name} is scheduled to run after its child ${l.name}.`)}if(!a(o))for(let l of o.inputs){if(!n.has(l.name))throw new Kd(`Input ${l.name} of node ${o.name} is unreachable.`);if(n.get(l.name)>n.get(o.name))throw new Kd(`Node ${o.name} is scheduled to run before its input ${l.name}.`)}}}function WG(e){let t=new Map(e.map((o,l)=>[o.name,l])),n=Number.MAX_SAFE_INTEGER,r=e.map((o,l)=>Ss(o)?n:l),a=o=>{let l=r[t.get(o.name)];return l??-1},s=e.map((o,l)=>o.children.map(a).reduce((p,u)=>Math.max(p,u),r[l])),i=new Map;for(let o=0;o<e.length;++o){let l=s[o];if(l===n)continue;let p=e[o],u=e[l];i.has(u.name)||i.set(u.name,[]),i.get(u.name).push(p)}return i}var VG=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),UG=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),GG=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Ss(e){return VG.has(e.op)}function HG(e){return UG.has(e.op)}function jG(e){return GG.has(e.op)}var Dw=class YS{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){let n=Object.keys(t).map(r=>t[r].map(a=>a.id));this._weightIds=[].concat(...n),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{let n=t.signatureKey||t.name;return t.defaultOutput?`${n}:${t.defaultOutput}`:n})}get functions(){return Object.keys(this._functions).reduce((t,n)=>(t[n]=this._functions[n].signature,t),{})}constructor(t,n){this.graph=t,this.parent=n,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,t.functions!=null&&Object.keys(t.functions).forEach(r=>{this._functionExecutorMap[r]=new YS(t.functions[r],this)})}getCompilationKey(t,n){let r=t.map(s=>s.name).sort(),a=n.map(s=>s.name).sort();return r.join(this.SEPARATOR)+"--"+a.join(this.SEPARATOR)}compile(t,n){let r=Rw(t,n,this.weightMap,this._initNodes),{missingInputs:a,dynamicNode:s,syncInputs:i}=r;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(a.length>0){let p=n.map(d=>d.name),u=Object.keys(t);throw new Error(`Cannot compute the outputs [${p}] from the provided inputs [${u}]. Missing the following inputs: [${a}]`)}let o=zG(this.graph,r),l=WG(o);return{orderedNodes:o,nodeLiveUntilMap:l}}cloneAndKeepTensor(t){if(t==null)return null;let n=t.clone();return Mt(n),n}cloneTensorList(t){return t?t.map(n=>this.cloneAndKeepTensor(n)):null}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map(([n,r])=>[n,this.cloneTensorList(r)]))}execute(t,n){this.disposeIntermediateTensors(),t=this.mapInputs(t);let r=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n);let a=r.map(h=>this.graph.nodes[Ln(h)[0]]),s=n.map(h=>Ln(h)[0]),i=new Set(s),o=s.map(h=>this.graph.nodes[h]);o.length===0&&(o=this._outputs);let l=this.getCompilationKey(a,o),p=this.compiledMap.get(l);p==null&&(p=this.compile(t,o),this.compiledMap.set(l,p));try{this.keepIntermediateTensors=G().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(h){this.keepIntermediateTensors=!1,console.warn(h.message)}let u={},d={};return B(()=>{let h=new Fw(this.weightMap,u,d,this.functionExecutorMap,this.parseNodeNameCache),c=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach(y=>{let[b,x]=Ln(y,h),v=[];v[x]=t[y],c[b]=v,this.keepIntermediateTensors&&(this.clonedTensorsMap[b]=this.cloneTensorList(v))});let f=this.getFrozenTensorIds(c),{orderedNodes:m,nodeLiveUntilMap:g}=p;for(let y of m){if(c[y.name])continue;let b=Aw(y,c,h,this._resourceManager);if(w.isPromise(b))throw new Error(`The execution of the op '${y.op}' returned a promise. Please use model.executeAsync() instead.`);c[y.name]=b,this.keepIntermediateTensors&&(this.clonedTensorsMap[y.name]=this.cloneTensorList(b)),this.checkTensorForDisposalWithNodeLiveUntilInfo(y,c,h,f,i,g.get(y.name))}return this.parent==null&&h.dispose(f),n.map(y=>en(y,c,h))})}getFrozenTensorIds(t){let n=[].concat.apply([],Object.keys(t).map(r=>t[r]).map(r=>r.map(a=>a.id)));return new Set(n)}checkTensorForDisposal(t,n,r,a,s,i,o){if(!(Ss(n)||i.has(t))){for(let l of r[t])l!=null&&(o[l.id]=(o[l.id]||0)+n.children.length);for(let l of n.inputs){if(Ss(l))continue;let p=Tw(l.name,r,a);if(p!=null)for(let u of p){if(!u||u.kept||s.has(u.id))continue;let d=o[u.id];d===1?(u.dispose(),delete o[u.id]):d!=null&&o[u.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(t,n,r,a,s,i){function o(l){return Ss(l)||s.has(l.name)}if(!(Ss(t)||i==null))for(let l of i){if(o(l))continue;let p=Tw(l.name,n,r);for(let u of p)!u||u.kept||a.has(u.id)||u.dispose()}}async executeAsync(t,n){return this._executeAsync(t,n)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(t=>{for(let n of t)n&&!n.isDisposed&&n.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(t,n,r=!1,a={},s={}){this.disposeIntermediateTensors(),r||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n));try{this.keepIntermediateTensors=G().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(h){this.keepIntermediateTensors=!1,console.warn(h.message)}let i=new Fw(this.weightMap,a,s,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));let o=await this.executeWithControlFlow(t,i,n,r),l=n.map(h=>en(h,o,i)),p=l.map(h=>h.id),u=Object.keys(t).map(h=>t[h].id),d=new Set([...p,...u,...this.weightIds]);return Object.values(o).forEach(h=>{h.forEach(c=>{c&&!c.isDisposed&&!d.has(c.id)&&c.dispose()})}),this.parent==null&&i.dispose(d),l}async executeFunctionAsync(t,n,r){let a=t.reduce((s,i,o)=>(s[this.inputs[o].name]=i,s),{});return this._executeAsync(a,this.outputNodes,!0,n,r)}async executeWithControlFlow(t,n,r,a){let s=Object.keys(t),i=s.map(v=>this.graph.nodes[Ln(v)[0]]),o=r.map(v=>Ln(v)[0]),l=new Set(o),p=o.map(v=>this.graph.nodes[v]);p.length===0&&(p=this._outputs);let{usedNodes:u,missingInputs:d,dynamicNode:h,syncInputs:c}=Rw(t,p,this.weightMap,this._initNodes),f=[...i,...this.graph.weights,...this._initNodes||[]].map(v=>({node:v,contexts:n.currentContext})),m=Object.assign({},this.weightMap);Object.keys(t).forEach(v=>{let[I,T]=Ln(v),_=[];_[T]=t[v],m[I]=_});let g={},y=this.getFrozenTensorIds(m),b={};for(;f.length>0;){let v=this.processStack(i,f,n,m,b,y,l,g,u);await Promise.all(v)}h==null&&!a&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let x=p.filter(v=>!Ss(v)&&!en(v.name,m,n)).map(v=>v.name);if(x.length>0){let v="";throw h!=null&&(v=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${c}]`),new Error(`Cannot compute the outputs [${x}] from the provided inputs [${s}]. Consider providing the following inputs: [${d}]. ${v}`)}return m}processStack(t,n,r,a,s,i,o,l,p){let u=[];for(;n.length>0;){let d=n.pop();r.currentContext=d.contexts;let h="";if(d.node.op==="Enter"&&k("isConstant",d.node,a,r)&&([h]=na(d.node.name,r)),a[d.node.name]==null){let c=Aw(d.node,a,r,this._resourceManager);h||([h]=na(d.node.name,r));let f=r.currentContext;w.isPromise(c)?u.push(c.then(m=>(a[h]=m,this.keepIntermediateTensors&&(this.clonedTensorsMap[h]=this.cloneTensorList(m)),r.currentContext=f,this.checkTensorForDisposal(h,d.node,a,r,i,o,l),this.processChildNodes(d.node,n,r,a,s,p),m))):(a[h]=c,this.keepIntermediateTensors&&(this.clonedTensorsMap[h]=this.cloneTensorList(c)),this.checkTensorForDisposal(h,d.node,a,r,i,o,l),this.processChildNodes(d.node,n,r,a,s,p))}else this.processChildNodes(d.node,n,r,a,s,p)}return u}processChildNodes(t,n,r,a,s,i){t.children.forEach(o=>{let[l]=na(o.name,r);s[l]||!i.has(o.name)||(o.op==="Merge"?o.inputNames.some(p=>!!en(p,a,r))&&(s[l]=!0,n.push({contexts:r.currentContext,node:o})):o.inputNames.every(p=>!!en(p,a,r))&&(s[l]=!0,n.push({contexts:r.currentContext,node:o})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(n=>n.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(n=>{let r=t[n],[a]=Ln(n),s=this.graph.nodes[a];if(s.attrParams.shape&&s.attrParams.shape.value){let i=s.attrParams.shape.value,o=i.length===r.shape.length&&r.shape.every((l,p)=>i[p]===-1||i[p]===l);w.assert(o,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${i}], but was [${r.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&w.assert(r.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(t){var n,r;let a={};for(let s in t){let i=(r=(n=this._signature)===null||n===void 0?void 0:n.inputs)===null||r===void 0?void 0:r[s];i!=null?a[i.name]=t[s]:a[s]=t[s]}return a}checkInputs(t){let n=Object.keys(t).filter(r=>{let[a]=Ln(r);return this.graph.nodes[a]==null});if(n.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`)}mapOutputs(t){return t.map(n=>{var r,a;let s=(a=(r=this._signature)===null||r===void 0?void 0:r.outputs)===null||a===void 0?void 0:a[n];return s!=null?s.name:n},{})}checkOutputs(t){t.forEach(n=>{let[r]=Ln(n);if(!this.graph.nodes[r])throw new Error(`The output '${n}' is not found in the graph`)})}},qG=class{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}},KG="?tfjs-format=file",XG="model.json",ux=class{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},n=nn){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=n,t==null&&(this.loadOptions={}),this.resourceManager=new qG}findIOHandler(){let e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{let t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let e=this.handler.load();return w.isPromise(e)?e.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){let t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");let t=await t1(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;let n=this.artifacts.modelTopology,r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){let a=this.artifacts.userDefinedMetadata;a.signature!=null&&(r=a.signature),a.structuredOutputKeys!=null&&(this.structuredOutputKeys=a.structuredOutputKeys)}if(this.signature=r,this.version=`${n.versions.producer}.${n.versions.minConsumer}`,this.executor=new Dw(Cw.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){let a=Cw.Instance.transformGraph(e.modelInitializer);this.initializer=new Dw(a),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){let n=this.io.getSaveHandlers(e);if(n.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(n.length>1)throw new Error(`Found more than one (${n.length}) save handlers for URL '${e}'`);e=n[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){let t=e instanceof Fe?[e]:e,n={};return t.forEach((r,a)=>n[this.structuredOutputKeys[a]]=r),n}return e}predict(e,t){let n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){let n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof Fe)&&!Array.isArray(e)){let a=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(a!=null)for(let s in a){let i=a[s];i.resourceId!=null&&(e[s]=this.resourceIdToCapturedInput[i.resourceId])}return e}e=Array.isArray(e)?e:[e];let n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce((a,s)=>{var i,o,l;let p=(l=(o=(i=this.signature)===null||i===void 0?void 0:i.inputs)===null||o===void 0?void 0:o[s])===null||l===void 0?void 0:l.resourceId;return p!=null?a[s]=this.resourceIdToCapturedInput[p]:a[s]=e[r++],a},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){let t=this.initializerSignature.outputs,n=Object.keys(t);for(let r=0;r<n.length;r++){let a=n[r],s=t[a];this.resourceIdToCapturedInput[s.resourceId]=e[r]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&_e(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}};async function ZG(e,t={},n=nn){if(e==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");t==null&&(t={}),t.fromTFHub&&typeof e=="string"&&(e=YG(e));let r=new ux(e,t,n);return await r.load(),r}function JG(e){if(e==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let t;if(e instanceof Array){let[r,a]=e;if(!r)throw new Error("modelJSON must be the first element of the array");if(!a||!(a instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in r))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in r))throw new Error("Model JSON is missing 'weightsManifest'");let s=nn.getWeightSpecs(r.weightsManifest),i=nn.getModelArtifactsForJSONSync(r,s,a);t=nn.fromMemorySync(i)}else if("load"in e)t=e;else if("modelTopology"in e&&"weightSpecs"in e&&"weightData"in e)t=nn.fromMemorySync(e);else throw new Error("Unknown model format");let n=new ux(t);return n.load(),n}function YG(e){return e.endsWith("/")||(e=e+"/"),`${e}${XG}${KG}`}var QG="4.22.0",QS={};Ee(QS,{CSVDataset:()=>pN,Dataset:()=>ku,FileDataSource:()=>yN,TextLineDataset:()=>uN,URLDataSource:()=>bN,array:()=>kH,csv:()=>MH,func:()=>OH,generator:()=>LH,microphone:()=>PH,version_data:()=>BH,webcam:()=>zH,zip:()=>IH});var eH=Ja(Hh()),tH=Ja(Hh());function nH(e,t){return Ah(e,t)}function Ah(e,t,n=new Map,r=new Set){if(e==null)return null;if(typeof Blob=="function"&&e instanceof Blob)return e.slice();if(r.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);let a=t(e);if(a.recurse&&a.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(a.recurse)if(al(e)){let s=Array.isArray(e)?[]:{};r.add(e);for(let i in e){let o=e[i],l=Ah(o,t,n,r);s[i]=l}return r.delete(e),e.__proto__&&(s.__proto__=e.__proto__),s}else throw new Error(`Can't recurse into non-iterable type: ${e}`);else return n.set(e,a.value),a.value}function rH(e,t=tN){return eN(e,t)}function eN(e,t,n=new Set){let r=e[0];if(n.has(r))throw new Error("Circular references are not supported.");let a=t(e);if(a.recurse&&a.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(a.recurse)if(al(r)){let s=Array.isArray(r)?[]:{};n.add(r);for(let i in r){let o=e.map(p=>p[i]),l=eN(o,t,n);s[i]=l}return n.delete(r),s}else throw new Error(`Can't recurse into non-iterable type: ${r}`);else return a.value}function tN(e){return e===null?null:al(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function nN(e,t){let n=new Map;Ah(e,t,n);for(let r of Array.from(n.keys())){let a=n.get(r);if(w.isPromise(a)){let s=await a;n.set(r,s)}}return Ah(e,t,n)}function al(e){let t=!1;if(G().get("IS_BROWSER"))t=e instanceof TextDecoder;else{let{StringDecoder:n}=w0();t=e instanceof n}return e!=null&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||typeof e=="object"&&!(e instanceof Fe)&&!(e instanceof Promise)&&!t)}function aH(e){return e==null||sH(e)||Array.isArray(e)||typeof e=="object"&&e instanceof Fe||w.isTypedArray(e)}function sH(e){return e===null||typeof e!="object"&&typeof e!="function"}function iH(e){return nH(e,oH)}function oH(e){return e instanceof Fe?{value:e.clone(),recurse:!1}:al(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}var rN=class{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,e==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(let t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}},aN=class sN extends rN{constructor(){super(sN.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){let t=this.capacity*2,n=new Array(t),r=this.length();for(let a=0;a<r;a++)n[a]=this.get(this.wrap(this.begin+a));this.data=n,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=r}};aN.INITIAL_CAPACITY=32;function iN(e){return new pH(e)}function px(e){return new dH(e)}function lH(e,t){return new oN(e,t)}function uH(e,t=Aa.FAIL){return new vH(e,t)}var Xt=class{async toArray(){let e=[],t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){let e=this.prefetch(100),t=[],n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new bH(this,e)}filter(e){return new gH(this,e)}map(e){return new yH(this,e)}mapAsync(e){return new Mw(this,e)}serialMapAsync(e){return new Mw(this,e).serial()}flatmap(e){return new xH(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(t=>t===!0)}rowMajorBatch(e,t=!0){return new mH(this,e,t)}columnMajorBatch(e,t=!0,n=tN){return this.rowMajorBatch(e,t).map(r=>rH(r,n))}concatenate(e,t){return new oN(iN([this,e]),t)}take(e){return e<0||e==null?this:new fH(this,e)}skip(e){return e<0||e==null?this:new cH(this,e)}prefetch(e){return new lN(this,e)}shuffle(e,t){return new wH(this,e,t)}serial(){return new hH(this)}},pH=class extends Xt{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let e=this.items[this.trav];return this.trav++,{value:iH(e),done:!1}}},dH=class extends Xt{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}},hH=class extends Xt{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}},cH=class extends Xt{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let e=await this.upstream.next();if(e.done)return e;_e(e.value)}return this.upstream.next()}},fH=class extends Xt{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},mH=class extends Xt{constructor(e,t,n=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let e=[];for(;e.length<this.batchSize;){let t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}},gH=class extends Xt{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;_e(e.value)}}},yH=class extends Xt{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=xr.getTensorsInContainer(e.value),n=this.transform(e.value),r=xr.getTensorsInContainer(n);for(let a of t)xr.isTensorInList(a,r)||a.dispose();return{value:n,done:!1}}},bH=class extends Xt{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}},Mw=class extends Xt{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=xr.getTensorsInContainer(e.value),n=await this.transform(e.value),r=xr.getTensorsInContainer(n);for(let a of t)xr.isTensorInList(a,r)||a.dispose();return{value:n,done:!1}}},dx=class extends Xt{constructor(){super(),this.outputQueue=new aN,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},xH=class extends dx{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let e=await this.upstream.next();if(e.done)return!1;let t=xr.getTensorsInContainer(e.value),n=this.transform(e.value),r=xr.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(let a of t)xr.isTensorInList(a,r)||a.dispose();return!0}},oN=class extends Xt{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){let n=await this.moreIterators.next();if(n.done)return{value:null,done:!0};this.iterator=n.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}},Aa;(function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"})(Aa||(Aa={}));var vH=class extends Xt{constructor(e,t=Aa.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,n=0;function r(s){return s instanceof Xt?{value:s.next().then(i=>(t++,i.done&&n++,i.value)),recurse:!1}:{value:null,recurse:!0}}let a=await nN(this.iterators,r);if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case Aa.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case Aa.SHORTEST:return{value:null,done:!0};case Aa.LONGEST:}return this.count++,{value:a,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},lN=class extends Xt{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new rN(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}},wH=class extends lN{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=tH.alea(n||w.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(t.done)this.upstreamExhausted=!0;else return this.refill(),t}return{value:null,done:!0}}},ku=class{constructor(){this.size=null}batch(e,t=!0){let n=this;w.assert(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`);let r;return this.size===1/0||this.size==null?r=this.size:t?r=Math.ceil(this.size/e):r=Math.floor(this.size/e),On(async()=>(await n.iterator()).columnMajorBatch(e,t,SH),r)}concatenate(e){let t=this,n;return this.size===1/0||e.size===1/0?n=1/0:this.size!=null&&e.size!=null?n=this.size+e.size:n=null,On(async()=>(await t.iterator()).concatenate(await e.iterator()),n)}filter(e){let t=this,n;return this.size===1/0?n=1/0:n=null,On(async()=>(await t.iterator()).filter(r=>B(()=>e(r))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){let t=this;return On(async()=>(await t.iterator()).map(n=>B(()=>e(n))),this.size)}mapAsync(e){let t=this;return On(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let t=this;return On(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){let t=this,n;return this.size!=null&&e>0?n=this.size*e:e===0?n=0:this.size!=null&&(e===void 0||e<0)?n=1/0:n=null,On(async()=>{let r=px(async()=>({value:await t.iterator(),done:!1}));return lH(r.take(e))},n)}skip(e){let t=this,n;return this.size!=null&&e>=0&&this.size>=e?n=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?n=0:n=null,On(async()=>(await t.iterator()).skip(e),n)}shuffle(e,t,n=!0){if(e==null||e<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let r=this,a=eH.alea(t||w.now().toString());return On(async()=>{let s=a.int32();return n&&(s+=a.int32()),(await r.iterator()).shuffle(e,s.toString())},this.size)}take(e){let t=this,n;return this.size!=null&&this.size>e?n=e:this.size!=null&&this.size<=e?n=this.size:n=null,On(async()=>(await t.iterator()).take(e),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};ku.MAX_BUFFER_SIZE=1e4;function On(e,t=null){return new class extends ku{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function kH(e){return On(async()=>iN(e),e.length)}function IH(e){if(!al(e))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(e))for(let n=0;n<e.length;n++)t=t==null?e[n].size:Math.min(t,e[n].size);else if(e instanceof Object)for(let n in e)t=t==null?e[n].size:Math.min(t,e[n].size);return On(async()=>{let n=await nN(e,r=>{if(r instanceof ku)return{value:r.iterator(),recurse:!1};if(al(r))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return uH(n,Aa.SHORTEST)},t)}function SH(e){if(e===null)return null;let t=e[0];return aH(t)?{value:NH(e),recurse:!1}:{value:null,recurse:!0}}function NH(e){if(e.length===0)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof Fe?At(e):cn(e)}var uN=class extends ku{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(e=>(e.endsWith("\r")&&(e=e.slice(0,-1)),e))}},Xd='"',Wu=Symbol("out"),Ow=Symbol("field"),Zd=Symbol("quote"),Wf=Symbol("quoteafterquote"),Lw=Symbol("quoteinquote"),pN=class extends ku{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&w.assert(e.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=e);let t=this.fullColumnNames.reduce((r,a)=>(r[a]=r[a]+1||1,r),{}),n=Object.keys(t).filter(r=>t[r]>1);if(w.assert(n.length===0,()=>"Duplicate column names found: "+n.toString()),this.columnConfigs){for(let r of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(r)===-1)throw new Error('The key "'+r+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let e=await(await this.base.iterator()).next();if(e.done)throw new Error("No data was found for CSV parsing.");let t=e.value;return this.parseRow(t,!1)}else return null}constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new uN(e),t||(t={}),this.hasHeader=t.hasHeader!==!1,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(w.assert(t.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(t=>this.makeDataElement(t))}makeDataElement(e){let t=this.parseRow(e),n={},r={};for(let a=0;a<this.fullColumnNames.length;a++){let s=this.fullColumnNames[a],i=this.columnConfigs?this.columnConfigs[s]:null;if(!(this.configuredColumnsOnly&&!i)){let o=t[a],l=null;if(o==="")if(i&&i.default!==void 0)l=i.default;else{if(i&&(i.required||i.isLabel))throw new Error(`Required column ${s} is empty in this line: ${e}`);l=void 0}else{let p=Number(o);if(isNaN(p))i&&i.dtype==="bool"?l=this.getBoolean(o):l=o;else if(!i||!i.dtype)l=p;else switch(i.dtype){case"float32":l=p;break;case"int32":l=Math.floor(p);break;case"bool":l=this.getBoolean(o);break;default:l=p}}i&&i.isLabel?r[s]=l:n[s]=l}}return Object.keys(r).length===0?n:{xs:n,ys:r}}getBoolean(e){return e==="1"||e.toLowerCase()==="true"?1:0}parseRow(e,t=!0){let n=[],r=0,a=e.length,s=Wu;for(let i=0;i<a;i++)switch(s){case Wu:switch(e.charAt(i)){case Xd:r=i+1,s=Zd;break;case this.delimiter:if(r=i+1,this.delimiter===" "&&this.delimWhitespace)break;n.push(""),s=Wu;break;default:s=Ow,r=i;break}break;case Ow:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(r,i)),s=Wu,r=i+1;break}break;case Zd:switch(e.charAt(i)){case Xd:s=Wf;break}break;case Wf:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(r,i-1)),s=Wu,r=i+1;break;case Xd:s=Zd;break;default:s=Lw;break}break;case Lw:switch(e.charAt(i)){case Xd:s=Zd;break}break}if(s===Wf?n.push(e.substring(r,a-1)):n.push(e.substring(r)),t&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}},TH=class dN extends Xt{constructor(t){super(),this.microphoneConfig=t,this.isClosed=!1,this.fftSize=t.fftSize||1024;let n=Math.log2(this.fftSize);if(this.fftSize<0||n<4||n>14||!Number.isInteger(n))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=t.numFramesPerSpectrogram||43,this.sampleRateHz=t.sampleRateHz,this.columnTruncateLength=t.columnTruncateLength||this.fftSize,this.audioTrackConstraints=t.audioTrackConstraints,this.smoothingTimeConstant=t.smoothingTimeConstant||0,this.includeSpectrogram=t.includeSpectrogram!==!1,this.includeWaveform=t.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(t={}){if(!G().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");let n=new dN(t);return await n.start(),n}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(r){throw new Error(`Error thrown while initializing video stream: ${r.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let t=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new t,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);let n=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,n.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let t,n,r=await this.getAudioData();if(this.includeSpectrogram){let a=this.flattenQueue(r.freqDataQueue);t=this.getTensorFromAudioDataArray(a,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let a=this.flattenQueue(r.timeDataQueue);n=this.getTensorFromAudioDataArray(a,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:t,waveform:n},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let t=[],n=[],r=0;return new Promise(a=>{let s=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&a({freqDataQueue:t,timeDataQueue:n}),t.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),n.push(this.timeData.slice())),++r===this.numFrames&&(clearInterval(s),a({freqDataQueue:t,timeDataQueue:n}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(t){let n=t[0].length,r=new Float32Array(t.length*n);return t.forEach((a,s)=>r.set(a,s*n)),r}getTensorFromAudioDataArray(t,n){let r=new Float32Array(w.sizeFromShape(n));return r.set(t,r.length-t.length),cn(r,n)}},CH=class hN extends Xt{constructor(t,n){if(super(),this.webcamVideoElement=t,this.webcamConfig=n,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=Ye([0],"int32"),this.webcamConfig.centerCrop){let r=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,a=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,s=(1-r)/2,i=(1-a)/2,o=s+r,l=a+i;this.cropBox=Wr([i,s,l,o],[1,4])}else this.cropBox=Wr([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(t,n={}){if(!G().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!t){if(t=document.createElement("video"),!n.resizeWidth||!n.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");t.width=n.resizeWidth,t.height=n.resizeHeight}let r=new hN(t,n);return await r.start(),r}async start(){this.webcamConfig.facingMode&&w.assert(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(t){throw t.message=`Error thrown while initializing video stream: ${t.message}`,t}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(t){console.log(t),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(t=>{this.webcamVideoElement.onloadedmetadata=()=>{t()}})}async next(){if(this.isClosed)return{value:null,done:!0};let t;try{t=ud.fromPixels(this.webcamVideoElement)}catch(n){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(n)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(t),done:!1}}catch(n){throw new Error(`Error thrown cropping the video: ${n.message}`)}finally{t.dispose()}else return{value:t,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(t){return B(()=>{let n=Ht(se(t,"float32"),0),r;r=Zn.cropAndResize(n,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let a=r.shape;return P(r,a.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(t=>t.stop());try{this.webcamVideoElement.srcObject=null}catch(t){console.log(t),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}},cN=class{},fN=class extends Xt{split(e){return new _H(this,e)}},_H=class extends fN{constructor(e,t){super(),this.upstream=e,this.impl=new EH(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},EH=class extends dx{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let e=await this.upstream.next();if(e.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);let t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(let n of t.slice(0,-1))this.outputQueue.push(n);return this.carryover=t[t.length-1],!0}},$H=class extends Xt{decodeUTF8(){return new AH(this)}},AH=class extends fN{constructor(e){super(),this.upstream=e,this.impl=new FH(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},FH=class extends dx{constructor(e){if(super(),this.upstream=e,G().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:t}=w0();this.decoder=new t("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let e=await this.upstream.next(),t;if(e.done)return!1;t=e.value;let n;return G().get("IS_BROWSER")?n=this.decoder.decode(t,{stream:!0}):n=this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(n),!0}},mN=class extends $H{constructor(e,t={}){super(),this.file=e,this.options=t,w.assert(e instanceof Uint8Array||(G().get("IS_BROWSER")?e instanceof File||e instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((e,t)=>{let n=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,n)));else{let r=new FileReader;r.onload=s=>{let i=r.result;if(i instanceof ArrayBuffer&&(i=new Uint8Array(i)),!(i instanceof Uint8Array))return t(new TypeError("FileReader returned unknown type."));e(i)},r.onabort=s=>t(new Error("Aborted")),r.onerror=s=>t(new Error(s.type));let a=this.file.slice(this.offset,n);r.readAsArrayBuffer(a)}this.offset=n}),done:!1}}};async function RH(e,t={},n){let r,a;typeof e=="string"?r=e:(r=e.url,a=DH(e));let s=await(0,w.fetch)(r,a);if(s.ok){let i=new Uint8Array(await s.arrayBuffer());return new mN(i,t)}else throw new Error(s.statusText)}var DH=e=>({method:e.method,headers:e.headers,body:e.body,mode:e.mode,credentials:e.credentials,cache:e.cache,redirect:e.redirect,referrer:e.referrer,integrity:e.integrity});function gN(e){return typeof e=="string"&&e.slice(0,7)==="file://"}var yN=class extends cN{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){if(gN(this.input)&&G().get("IS_NODE")){let e=ng();this.input=e.readFileSync(this.input.slice(7))}return new mN(this.input,this.options)}},bN=class extends cN{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return gN(this.url)?new yN(this.url,this.fileOptions).iterator():RH(this.url,this.fileOptions)}};function MH(e,t={}){return new pN(new bN(e),t)}function OH(e){let t=px(e);return On(async()=>t)}function LH(e){return On(async()=>{let t=await e();return px(()=>t.next())})}async function zH(e,t){return CH.create(e,t)}async function PH(e){return TH.create(e)}var BH="4.22.0";function ye(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&w.assert(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}var WH=Xr.whereImpl,hx=class xN extends wp{nextDataId(){return xN.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new jh(this,lr())}write(t,n,r){this.firstUse&&(this.firstUse=!1,G().get("IS_NODE")&&N.warn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));let a={id:this.nextDataId()};return this.data.set(a,{values:t,dtype:r,refCount:1}),a}makeTensorInfo(t,n,r){let a;if(n==="string"&&r!=null&&r.length>0&&w.isString(r[0])){let s=r.map(i=>w.encodeString(i));a=this.write(s,t,n)}else a=this.write(r,t,n);return{dataId:a,shape:t,dtype:n}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){let n=this.data.get(t);n.refCount++}decRef(t){if(this.data.has(t)){let n=this.data.get(t);n.refCount--}}move(t,n,r,a,s){this.data.set(t,{values:n,dtype:a,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){let{dtype:n,complexTensorInfos:r}=this.data.get(t);if(n==="complex64"){let a=this.readSync(r.real.dataId),s=this.readSync(r.imag.dataId);return N.mergeRealAndImagArrays(a,s)}return w.convertBackendValuesAndArrayBuffer(this.data.get(t).values,n)}bufferSync(t){let n=this.readSync(t.dataId);if(t.dtype==="string")try{let r=n.map(a=>w.decodeString(a));return ze(t.shape,t.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return ze(t.shape,t.dtype,n)}makeOutput(t,n,r){return lr().makeTensorFromTensorInfo(this.makeTensorInfo(n,r,t),this)}disposeData(t,n=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!n&&this.data.get(t).refCount>0)return!1;let{complexTensorInfos:r}=this.data.get(t);r!=null&&(this.disposeData(r.real.dataId,!0),this.disposeData(r.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){let n=w.now();return t(),{kernelMs:w.now()-n}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){ye([t],"where");let n=this.readSync(t.dataId);return WH(t.shape,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};hx.nextDataId=0;var cx={};Ee(cx,{addImpl:()=>kN,bincountImpl:()=>mx,bincountReduceImpl:()=>IN,bitwiseAndImpl:()=>SN,castImpl:()=>wN,ceilImpl:()=>NN,concatImpl:()=>gx,equalImpl:()=>TN,expImpl:()=>_N,expm1Impl:()=>$N,floorDivImpl:()=>FN,floorImpl:()=>AN,gatherNdImpl:()=>RN,gatherV2Impl:()=>DN,greaterEqualImpl:()=>ON,greaterImpl:()=>MN,lessEqualImpl:()=>zN,lessImpl:()=>LN,linSpaceImpl:()=>PN,logImpl:()=>BN,maxImpl:()=>WN,maximumImpl:()=>VN,minimumImpl:()=>UN,multiplyImpl:()=>yx,negImpl:()=>GN,notEqualImpl:()=>HN,prodImpl:()=>jN,raggedGatherImpl:()=>qN,raggedRangeImpl:()=>KN,raggedTensorToTensorImpl:()=>XN,rangeImpl:()=>xx,rsqrtImpl:()=>ZN,scatterImpl:()=>Cs,sigmoidImpl:()=>B6,simpleAbsImpl:()=>vN,sliceImpl:()=>Rh,sparseFillEmptyRowsImpl:()=>YN,sparseReshapeImpl:()=>QN,sparseSegmentReductionImpl:()=>vx,sqrtImpl:()=>U6,squaredDifferenceImpl:()=>e2,staticRegexReplaceImpl:()=>t2,stridedSliceImpl:()=>n2,stringNGramsImpl:()=>wx,stringSplitImpl:()=>kx,stringToHashBucketFastImpl:()=>Ix,subImpl:()=>r2,tileImpl:()=>a2,topKImpl:()=>i2,transposeImpl:()=>bx,uniqueImpl:()=>Nx});function vN(e){let t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}var VH=e=>{let{x:t}=e.inputs,n=e.backend;ye(t,"abs");let r=new Float32Array(w.sizeFromShape(t.shape)),a=n.data.get(t.dataId).values;return r=vN(a),n.makeOutput(r,t.shape,t.dtype)},UH={kernelName:pl,backendName:"cpu",kernelFunc:VH};function Tt(e){return(t,n,r,a,s)=>{let i=N.assertAndGetBroadcastShape(t,n),o=i.length,l=w.computeStrides(i),p=w.sizeFromShape(i),u=w.getTypedArrayFromDType(s,p),d=t.length,h=n.length,c=w.computeStrides(t),f=w.computeStrides(n),m=N.getBroadcastDims(t,i),g=N.getBroadcastDims(n,i);if(m.length+g.length===0)for(let y=0;y<u.length;++y)u[y]=e(r[y%r.length],a[y%a.length]);else for(let y=0;y<u.length;++y){let b=w.indexToLoc(y,o,l),x=b.slice(-d);m.forEach(_=>x[_]=0);let v=w.locToIndex(x,d,c),I=b.slice(-h);g.forEach(_=>I[_]=0);let T=w.locToIndex(I,h,f);u[y]=e(r[v],a[T])}return[u,i]}}function zn(e){let{inputs:t,backend:n}=e,{real:r,imag:a}=t,s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,o=n.makeTensorInfo(r.shape,"complex64"),l=n.data.get(o.dataId);return l.complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",s),imag:n.makeTensorInfo(a.shape,"float32",i)},o}var GH={kernelName:Xh,backendName:"cpu",kernelFunc:zn};function Fh(e,t,n="float32"){if(n==="complex64"){let a=Fh(e,t,"float32"),s=Fh(e,t,"float32");return zn({inputs:{real:a,imag:s},backend:e})}let r=w.makeZerosTypedArray(w.sizeFromShape(t),n);return e.makeTensorInfo(t,n,r)}function jr(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var HH={kernelName:_i,backendName:"cpu",kernelFunc:jr};function Hs(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.real,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}var jH={kernelName:oc,backendName:"cpu",kernelFunc:Hs};function wN(e,t,n,r){if(r==="int32"){let a=Int32Array.from(e);return[t,"int32",a]}if(r==="bool"){let a=w.toTypedArray([0],n),[s,i]=Tt((o,l)=>o!==l?1:0)(t,[],e,a,"bool");return[i,"bool",s]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function Ka(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dtype:s}=r;if(s==="complex64"){if(a.dtype==="complex64")return jr({inputs:{x:a},backend:n});let u=Fh(n,a.shape,a.dtype),d=Ka({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),h=zn({inputs:{real:d,imag:u},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),h}if(a.dtype==="complex64"){let u=Hs({inputs:{input:a},backend:n}),d=Ka({inputs:{x:u},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(u),d}if(!w.hasEncodingLoss(a.dtype,s)){let u=jr({inputs:{x:a},backend:n});return{dataId:u.dataId,shape:u.shape,dtype:s}}let i=n.data.get(a.dataId).values,[o,l,p]=wN(i,a.shape,a.dtype,s);return n.makeTensorInfo(o,l,p)}var qH={kernelName:ui,backendName:"cpu",kernelFunc:Ka};function Bt(e,t,n,r){return n==null?({inputs:a,backend:s})=>{let{a:i,b:o}=a,l=s;ye([i,o],e);let p=l.data.get(i.dataId).values,u=l.data.get(o.dataId).values,d=i.dtype==="string"?N.fromUint8ToStringArray(p):p,h=i.dtype==="string"?N.fromUint8ToStringArray(u):u,c=r||i.dtype,[f,m]=t(i.shape,o.shape,d,h,c);return l.makeTensorInfo(m,c,f)}:({inputs:a,backend:s})=>{let{a:i,b:o}=a,l=s;if(i.dtype==="complex64"||o.dtype==="complex64"){let p=Ka({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),u=l.data.get(p.dataId),d=u.complexTensorInfos.real,h=u.complexTensorInfos.imag,c=l.data.get(d.dataId).values,f=l.data.get(h.dataId).values,m=Ka({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),g=l.data.get(m.dataId),y=g.complexTensorInfos.real,b=g.complexTensorInfos.imag,x=l.data.get(y.dataId).values,v=l.data.get(b.dataId).values,[I,T,_]=n(i.shape,o.shape,c,f,x,v),E=l.makeTensorInfo(_,"float32",I),A=l.makeTensorInfo(_,"float32",T),R=zn({inputs:{real:E,imag:A},backend:l});return l.disposeIntermediateTensorInfo(p),l.disposeIntermediateTensorInfo(m),l.disposeIntermediateTensorInfo(E),l.disposeIntermediateTensorInfo(A),R}else{let p=l.data.get(i.dataId).values,u=l.data.get(o.dataId).values,d=r||i.dtype,[h,c]=t(i.shape,o.shape,p,u,d);return l.makeTensorInfo(c,d,h)}}}function fx(e){return(t,n,r,a,s,i)=>{let o=N.assertAndGetBroadcastShape(t,n),l=w.sizeFromShape(o),p=o.length,u=w.computeStrides(o),d=w.getTypedArrayFromDType("float32",l),h=w.getTypedArrayFromDType("float32",l),c=N.getBroadcastDims(t,o),f=N.getBroadcastDims(n,o),m=N.mergeRealAndImagArrays(r,a),g=N.mergeRealAndImagArrays(s,i),y=t.length,b=w.computeStrides(t),x=n.length,v=w.computeStrides(n);if(c.length+f.length===0)for(let I=0;I<d.length;I++){let T=I%m.length,_=I%g.length,E=e(m[T*2],m[T*2+1],g[_*2],g[_*2+1]);d[I]=E.real,h[I]=E.imag}else for(let I=0;I<d.length;I++){let T=w.indexToLoc(I,p,u),_=T.slice(-y);c.forEach(S=>_[S]=0);let E=w.locToIndex(_,y,b),A=T.slice(-x);f.forEach(S=>A[S]=0);let R=w.locToIndex(A,x,v),F=e(m[E*2],m[E*2+1],g[R*2],g[R*2+1]);d[I]=F.real,h[I]=F.imag}return[d,h,o]}}var kN=Tt((e,t)=>e+t),KH=fx((e,t,n,r)=>({real:e+n,imag:t+r})),sl=Bt(Ya,kN,KH),XH={kernelName:Ya,backendName:"cpu",kernelFunc:sl};function mx(e,t,n,r,a){let s=w.sizeFromShape(r),i=w.makeZerosTypedArray(a,n);for(let o=0;o<e.length;o++){let l=e[o];if(l<0)throw new Error("Input x must be non-negative!");l>=a||(s>0?i[l]+=t[o]:i[l]+=1)}return i}function IN(e,t,n,r=!1){let a=e.shape[0],s=e.shape[1],i=ze([a,n],t.dtype);for(let o=0;o<a;o++)for(let l=0;l<s;l++){let p=e.get(o,l);if(p<0)throw new Error("Input x must be non-negative!");p>=n||(r?i.set(1,o,p):t.size>0?i.set(i.get(o,p)+t.get(o,l),o,p):i.set(i.get(o,p)+1,o,p))}return i}var SN=Tt((e,t)=>e&t),ZH=Bt(bl,SN),JH={kernelName:bl,backendName:"cpu",kernelFunc:ZH};function Zr(e){return(t,n,r)=>{let a=w.getArrayFromDType(n,t.length);for(let s=0;s<t.length;++s)a[s]=e(t[s],r);return a}}function nt(e,t,n){let r=Zr(t);return os(e,r,n)}function os(e,t,n){return({inputs:r,attrs:a,backend:s})=>{let{x:i}=r;ye(i,e);let o=s,l=o.data.get(i.dataId).values,p;if(i.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");p=N.fromUint8ToStringArray(l)}else p=l;let u=n||i.dtype,d=t(p,u,a);return o.makeTensorInfo(i.shape,u,d)}}var NN=Zr(e=>Math.ceil(e)),YH=os(pi,NN),QH={kernelName:pi,backendName:"cpu",kernelFunc:YH};function gx(e,t,n,r){let a=w.getArrayFromDType(n,w.sizeFromShape(t));if(r&&n!=="string"){let s=0;e.forEach(i=>{let o=w.sizeFromShape(i.shape);a.set(i.vals,s),s+=o})}else{let s=0;e.forEach(i=>{let o=n==="string"?N.fromUint8ToStringArray(i.vals):i.vals,l=0;for(let p=0;p<i.shape[0];++p){let u=p*t[1]+s;for(let d=0;d<i.shape[1];++d)a[u+d]=o[l++]}s+=i.shape[1]})}return a}var TN=Tt((e,t)=>e===t?1:0),CN=Bt(Tl,TN,null,"bool"),e6={kernelName:Tl,backendName:"cpu",kernelFunc:CN},_N=Zr(e=>Math.exp(e)),EN=os(ki,_N,"float32"),t6={kernelName:ki,backendName:"cpu",kernelFunc:EN},$N=Zr(e=>Math.expm1(e)),n6=os(Ii,$N),r6={kernelName:Ii,backendName:"cpu",kernelFunc:n6},AN=Zr(e=>Math.floor(e)),a6=os(Si,AN),s6={kernelName:Si,backendName:"cpu",kernelFunc:a6},FN=Tt((e,t)=>Math.floor(e/t)),i6=Bt(Ni,FN,null,"int32"),o6={kernelName:Ni,backendName:"cpu",kernelFunc:i6};function RN(e,t,n,r,a,s,i,o,l){let p=ze([r,s],n);for(let u=0;u<r;u++){let d=[],h=0;for(let c=0;c<a;c++){let f=e[u*a+c];h+=f*i[c],d.push(f)}if(h<0||h>=l/s)throw new Error(`Invalid indices: ${d} does not index into ${o}`);for(let c=0;c<s;c++)p.values[u*s+c]=t.get(...t.indexToLoc(h*s+c))}return p}function DN(e,t,n){let r=ze(n,e.dtype);for(let a=0;a<r.size;++a){let s=r.indexToLoc(a).slice(),i=s[0],o=s[2],l=t.locToIndex([i,o]);s[2]=t.values[l];let p=e.locToIndex(s);0<=p&&p<e.values.length&&(r.values[a]=e.values[p])}return r}var MN=Tt((e,t)=>e>t?1:0),l6=Bt(Al,MN,null,"bool"),u6={kernelName:Al,backendName:"cpu",kernelFunc:l6},ON=Tt((e,t)=>e>=t?1:0),p6=Bt(Ci,ON,null,"bool"),d6={kernelName:Ci,backendName:"cpu",kernelFunc:p6},LN=Tt((e,t)=>e<t?1:0),h6=Bt(Fl,LN,null,"bool"),c6={kernelName:Fl,backendName:"cpu",kernelFunc:h6},zN=Tt((e,t)=>e<=t?1:0),f6=Bt(Rl,zN,null,"bool"),m6={kernelName:Rl,backendName:"cpu",kernelFunc:f6};function PN(e,t,n){let r=(t-e)/(n-1),a=w.makeZerosTypedArray(n,"float32");a[0]=e;for(let s=1;s<a.length;s++)a[s]=a[s-1]+r;return a}var BN=Zr(e=>Math.log(e)),g6=os(Ri,BN),y6={kernelName:Ri,backendName:"cpu",kernelFunc:g6};function WN(e,t,n,r){let a=w.getTypedArrayFromDType(r,w.sizeFromShape(n));for(let s=0;s<a.length;++s){let i=s*t,o=e[i];for(let l=0;l<t;++l){let p=e[i+l];(Number.isNaN(p)||p>o)&&(o=p)}a[s]=o}return a}var VN=Tt((e,t)=>Math.max(e,t)),b6=Bt(Li,VN),x6={kernelName:Li,backendName:"cpu",kernelFunc:b6},UN=Tt((e,t)=>Math.min(e,t)),v6=Bt(Wi,UN),w6={kernelName:Wi,backendName:"cpu",kernelFunc:v6},yx=Tt((e,t)=>e*t),k6=fx((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n})),ff=Bt(Gi,yx,k6),I6={kernelName:Gi,backendName:"cpu",kernelFunc:ff};function GN(e,t,n){let r=w.createScalarValue(-1,n);return yx([],t,r,e,n)}function S6(e){let{inputs:t,backend:n}=e,{x:r}=t;ye(r,"neg");let a=n.data.get(r.dataId).values,[s,i]=GN(a,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,s)}var N6={kernelName:Wl,backendName:"cpu",kernelFunc:S6},HN=Tt((e,t)=>e!==t?1:0),T6=Bt(Vl,HN,null,"bool"),C6={kernelName:Vl,backendName:"cpu",kernelFunc:T6};function bx(e,t,n,r,a){let s=t.length,i=w.sizeFromShape(t),o=w.computeStrides(t),l=w.computeStrides(a),p=w.getTypedArrayFromDType(n,w.sizeFromShape(a));for(let u=0;u<i;++u){let d=w.indexToLoc(u,s,o),h=new Array(d.length);for(let f=0;f<h.length;f++)h[f]=d[r[f]];let c=w.locToIndex(h,s,l);p[c]=e[u]}return p}function $n(e){let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{perm:s}=n;ye(a,"transpose");let i=a.shape.length,o=new Array(i);for(let u=0;u<o.length;u++)o[u]=a.shape[s[u]];let l=r.data.get(a.dataId).values,p=bx(l,a.shape,a.dtype,s,o);return{dataId:r.write(p,o,a.dtype),shape:o,dtype:a.dtype}}var _6={kernelName:sa,backendName:"cpu",kernelFunc:$n};function jN(e,t,n,r){let[a,s]=N.computeOutAndReduceShapes(e,r),i=tr(t,"int32"),o=w.makeZerosTypedArray(w.sizeFromShape(a),i),l=w.sizeFromShape(s);for(let p=0;p<o.length;++p){let u=p*l,d=1;for(let h=0;h<l;++h)d*=n[u+h];o[p]=d}return{outVals:o,outShape:a,outDtype:i}}function E6(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;ye(a,"prod");let o=a.shape.length,l=w.parseAxisParam(s,a.shape),p=N.getAxesPermutation(l,o),u=l,d=a,h=[];p!=null&&(d=$n({inputs:{x:a},backend:n,attrs:{perm:p}}),h.push(d),u=N.getInnerMostAxes(u.length,o));let c=n.data.get(d.dataId).values,{outVals:f,outShape:m,outDtype:g}=jN(d.shape,d.dtype,c,u),y=m;return i&&(y=N.expandShapeToKeepDim(m,l)),h.forEach(b=>n.disposeIntermediateTensorInfo(b)),n.makeTensorInfo(y,g,f)}var $6={kernelName:Xi,backendName:"cpu",kernelFunc:E6};function A6(e,t,n){e.forEach((r,a)=>{if(r<0||r>=n){let s=w.indexToLoc(a,t.length,w.computeStrides(t)).join(",");throw new Error(`indices[${s}] = ${r} is not in [0, ${n})`)}})}function F6(e,t){for(let n=0;n<e.length;++n){let r=e[n],a=n===e.length-1?t:e[n+1].length;if(r.length===0)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>a)throw new Error("Ragged splits must not point past values");for(let s=1;s<r.length;++s)if(r[s-1]>r[s])throw new Error("Ragged splits must be sorted in ascending order")}}function R6(e,t,n,r){let a=[],s=0,i=t.length-1+n.length,o=new Array(i).fill(null).map(()=>[0]);F6(n,r);let l=1;for(let p=0;p<t.length-1;++p){l*=t[p];let u=t[p+1];for(let d=1;d<l+1;++d)o[p].push(d*u)}for(let p=0;p<e.length;++p){let u=e[p],d=e[p]+1;for(let h=0;h<n.length;++h){let c=n[h],f=h+t.length-1;if(f>=0){let m=o[f],g=m[m.length-1]-c[u];for(let y=u;y<d;++y)o[f].push(c[y+1]+g)}u=c[u],d=c[d]}d!==u&&(a.push([u,d]),s+=d-u)}return{outSplits:o,valueSlices:a,numValues:s}}function D6(e){let t=[];for(let n=0;n<e.length;++n){let r=e[n].length,a=w.getArrayFromDType("int32",r);t.push(a),e[n].forEach((s,i)=>a[i]=s)}return t}function zw(e,t){let n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function M6(e,t,n,r,a,s){let i=zw(t,2)[1],o=zw(s,2)[1],l=0;for(let p of n)for(let u=p[0];u<p[1];++u){for(let d=0;d<r;++d)a[l*o+d]=e[u*i+d];++l}}function O6(e,t,n,r,a){let s=t.slice();s[0]=a;let i=w.getArrayFromDType(n,w.sizeFromShape(s)),o=e.length,l=o===0?0:o/t[0];return M6(e,t,r,l,i,s),[i,s]}function qN(e,t,n,r,a,s,i,o){if(e.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");let l=t[0][0]-1;if(A6(s,i,l),r.length===0)throw new Error("params.rank must be nonzero");let p=r[0],{outSplits:u,valueSlices:d,numValues:h}=R6(s,i,e,p),c=D6(u),f=O6(n,r,a,d,h);return[c,f[0],f[1]]}var Pw=2147483647;function KN(e,t,n,r,a,s,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(a.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");let o=t.length===0,l=a.length===0,p=i.length===0,u=[];o||u.push(t[0]),l||u.push(a[0]),p||u.push(i[0]);for(let g=1;g<u.length;++g)if(u[g]!==u[g-1])throw new Error("starts, limits, and deltas must have the same shape");let d=u.length===0?1:u[0],h=w.getArrayFromDType("int32",d+1);h[0]=0;for(let g=0;g<d;++g){let y=o?e[0]:e[g],b=l?r[0]:r[g],x=p?s[0]:s[g];if(x===0)throw new Error("Requires delta != 0");let v;if(x>0&&b<y||x<0&&b>y)v=0;else if(v=Math.ceil(Math.abs((b-y)/x)),v>Pw)throw new Error(`Requires ((limit - start) / delta) <= ${Pw}`);h[g+1]=h[g]+v}let c=h[d],f=w.getArrayFromDType(n,c),m=0;for(let g=0;g<d;++g){let y=h[g+1]-h[g],b=o?e[0]:e[g],x=p?s[0]:s[g];for(let v=0;v<y;++v)f[m++]=b,b+=x}return[h,f]}var or=N.RowPartitionType,L6=class Mm{constructor(t,n,r,a,s,i,o,l,p,u){this.shape=t,this.shapeShape=n,this.values=r,this.valuesShape=a,this.valuesDType=s,this.defaultValue=i,this.defaultValueShape=o,this.rowPartitionValues=l,this.rowPartitionValuesShapes=p,this.rowPartitionTypes=N.getRowPartitionTypesHelper(u),this.raggedRank=N.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===or.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===or.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){let n=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case or.VALUE_ROWIDS:return Mm.getMaxWidthValueRowID(n);case or.ROW_SPLITS:return Mm.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${or[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){let n=t.length;if(n===0||n===1)return 0;let r=0;for(let a=0;a<n-1;++a){let s=t[a+1]-t[a];s>r&&(r=s)}return r}static getMaxWidthValueRowID(t){let n=t.length;if(n===0)return 0;let r=0,a=t[0],s=0;for(let i=1;i<n;++i){let o=t[i];o!==a&&(a=o,s=Math.max(i-r,s),r=i)}return Math.max(n-r,s)}tensorShapeFromTensor(t,n,r=!0){if(n.length===0){if(t[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return Ww(t,r)}calculateOutputSize(t){let n=this.valuesShape,r=this.defaultValueShape;N.validateDefaultValueShape(r,n);let a=this.tensorShapeFromTensor(this.shape,this.shapeShape),s=N.combineRaggedTensorToTensorShapes(this.raggedRank,a,n);s[0]<0&&(s[0]=t);for(let i=1;i<=this.raggedRank;++i)s[i]<0&&(s[i]=this.getMaxWidth(i));return s}calculateFirstParentOutputIndex(t,n,r){let a=Math.min(t,r),s=[],i=0;for(let o=0;o<a;++o,i+=n)s.push(i);for(let o=a;o<t;++o)s.push(-1);return w.assert(s.length===t,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(t,n,r,a){let s=t.length,i=[];for(let o=0;o<s-1;++o){let l=t[o+1]-t[o],p=Math.min(a,l),u=n[o];u===-1&&(p=0);for(let d=0;d<p;++d)i.push(u),u+=r;for(let d=0;d<l-p;++d)i.push(-1)}if(s>0&&i.length!==t[s-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(t,n,r,a){let s=t.length,i=[];if(s===0)return[];let o=0,l=t[0];if(l>=n.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${n.length}`);let p=n[l];i.push(p);for(let u=1;u<s;++u){let d=t[u];if(d===l)p>=0&&(++o,o<a?p+=r:p=-1);else{if(o=0,l=d,d>=n.length)throw new Error(`Got nextValueRowId=${d} which is not less than ${n.length}`);p=n[d]}i.push(p)}if(i.length!==t.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(t,n,r,a){let s=this.getRowPartitionTensor(t),i=this.getRowPartitionTypeByDimension(t);switch(i){case or.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,n,r,a);case or.ROW_SPLITS:if(s.length-1>n.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${n.length}`);return this.calculateOutputIndexRowSplit(s,n,r,a);default:throw new Error(`Unsupported partition type: ${or[i]}`)}}getFirstDimensionSize(){let t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");let n=this.rowPartitionTypes[0];switch(n){case or.FIRST_DIM_SIZE:return t[0];case or.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case or.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${or[n]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");let t=this.getFirstDimensionSize(),n=this.calculateOutputSize(t),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let i=r.length-2;i>=0;--i)r[i]=r[i+1]*n[i+1];let a=Ww(n,!1),s=w.getArrayFromDType(this.valuesDType,w.sizeFromShape(a));if(r[0]*n[0]>0){let i=this.calculateFirstParentOutputIndex(t,r[0],n[0]);for(let o=1;o<=this.raggedRank;++o)i=this.calculateOutputIndex(o-1,i,r[o],n[o]);this.setOutput(this.raggedRank,i,s,a)}return[a,s]}setOutput(t,n,r,a){if(r.length===0)return;let s=this.values,i=r,o=a.slice();o=o.slice(t+1);let l=w.sizeFromShape(o),p=n.length,u=this.defaultValue;if(u.length!==l&&u.length!==1){let f=this.defaultValueShape;B(()=>{let m=P(u,f);u=_s(m,o).dataSync()})}let d=0,h=0,c=0;for(let f=0;f<=p;++f){let m=f<p?n[f]:-1;if(m===c){++c;continue}if(h<c){let g=s.subarray(d*l),y=i.subarray(h*l),b=(c-h)*l;Bw(y,g,b)}if(f>=p){let g=r.length;m=Math.floor(g/l)}if(m>c)if(this.defaultValue.length===1)i.subarray(c*l,m*l).fill(this.defaultValue[0]),c=m;else for(;m>c;){let g=i.slice(c*l);Bw(g,u,l),++c}m<0?(d=f+1,h=c):(d=f,h=c,c=h+1)}}};function Bw(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function Ww(e,t){let n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function XN(e,t,n,r,a,s,i,o,l,p){return new L6(e,t,n,r,a,s,i,o,l,p).compute()}function xx(e,t,n,r){let a=e===t,s=e<t&&n<0,i=t<e&&n>1;if(a||s||i)return w.makeZerosTypedArray(0,r);let o=Math.abs(Math.ceil((t-e)/n)),l=w.makeZerosTypedArray(o,r);t<e&&n===1&&(n=-1),l[0]=e;for(let p=1;p<l.length;p++)l[p]=l[p-1]+n;return l}var ZN=Zr(e=>1/Math.sqrt(e)),z6=os(ro,ZN),P6={kernelName:ro,backendName:"cpu",kernelFunc:z6};function Cs(e,t,n,r,a,s,i,o,l,p){let u=[r/a,a],d=e.values,h=t.values;if(r===0)return ze(n,t.dtype);let c=l instanceof $t?l:ze(u,t.dtype);typeof l=="string"||typeof l=="number"?c.values.fill(l):typeof l=="boolean"&&c.values.fill(+l);for(let f=0;f<s;f++){let m=[],g=0;for(let y=0;y<i;y++){let b=d[f*i+y];m.push(b),g+=b*o[y]}if(g<0||g>=r/a)throw new Error(`Invalid indices: ${m} does not index into ${n}`);for(let y=0;y<a;y++)p?c.values[g*a+y]+=h[f*a+y]:c.values[g*a+y]=t.rank===0?h[0]:h[f*a+y]}return c}var B6=Zr(e=>1/(1+Math.exp(-e))),JN=nt(lo,e=>1/(1+Math.exp(-e))),W6={kernelName:lo,backendName:"cpu",kernelFunc:JN};function Rh(e,t,n,r,a){let s=Lt.isSliceContinous(r,t,n),i=w.sizeFromShape(n),o=w.computeStrides(r);if(s){let d=Lt.computeFlatOffset(t,o);return a==="string"?e.slice(d,d+i):e.subarray(d,d+i)}let l=a==="string"?N.fromUint8ToStringArray(e):e,p=ze(r,a,l),u=ze(n,a);for(let d=0;d<u.size;++d){let h=u.indexToLoc(d),c=h.map((f,m)=>f+t[m]);u.set(p.get(...c),...h)}return a==="string"?N.fromStringArrayToUint8(u.values):u.values}function js(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,size:i}=r;ye(a,"slice");let[o,l]=Lt.parseSliceParams(a,s,i);Lt.assertParamsValid(a,o,l);let p=n.data.get(a.dataId).values,u=Rh(p,o,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,u)}var V6={kernelName:tu,backendName:"cpu",kernelFunc:js};function YN(e,t,n,r,a,s,i){let o=t[0],l=s[0],p=new Array(l),u=new Array(o),d=t[1];if(l===0){if(o!==0)throw new Error(N.getSparseFillEmptyRowsIndicesDenseShapeMismatch(o));let g=w.getArrayFromDType(n,0),y=w.getArrayFromDType(a,0);return[g,[0,d],y,p,u]}let h=!0,c=0,f=new Array(l).fill(0);for(let g=0;g<o;++g){let y=e[g*d];if(y<0)throw new Error(N.getSparseFillEmptyRowsNegativeIndexErrorMessage(g,y));if(y>=l)throw new Error(N.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g,y,l));++f[y],h=h&&y>=c,c=y}let m=!0;for(let g=0;g<l;++g){let y=f[g]===0;p[g]=y,m=m&&!y,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&h){let g=e,y=r;for(let b=0;b<o;++b)u[b]=b;return[g,[o,d],y,p,u]}else{let g=f[l-1],y=w.getArrayFromDType(n,g*d),b=w.getArrayFromDType(a,g),x=new Array(l).fill(0);for(let v=0;v<o;++v){let I=e[v*d],T=x[I],_=(I===0?0:f[I-1])+T;x[I]++;for(let E=0;E<d;++E)y[_*d+E]=e[v*d+E];b[_]=r[v],u[v]=_}for(let v=0;v<l;++v)if(x[v]===0){let I=v===0?0:f[v-1];y[I*d+0]=v;for(let T=1;T<d;++T)y[I*d+T]=0;b[I]=i}return[y,[g,d],b,p,u]}}function QN(e,t,n,r,a){let s=w.sizeFromShape(r),i=t[0],o=a.length,l=[],p=1,u=-1;for(let m=0;m<o;++m){let g=a[m];if(g===-1){if(u!==-1)throw new Error(N.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(u,m));u=m,l.push(1)}else{if(g<0)throw new Error(N.getSparseReshapeNegativeOutputDimErrorMessage(m,g));p*=g,l.push(g)}}if(u!==-1){if(p<=0)throw new Error(N.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let m=Math.trunc(s/p);if(p*m!==s)throw new Error(N.getSparseReshapeInputOutputMultipleErrorMessage(r,l));l[u]=m}if(w.sizeFromShape(l)!==s)throw new Error(N.getSparseReshapeInputOutputMismatchErrorMessage(r,l));let d=r.length,h=[];if(d>0){h[d-1]=1;for(let m=d-2;m>=0;--m)h[m]=h[m+1]*r[m+1]}let c=[];if(o>0){c[o-1]=1;for(let m=o-2;m>=0;--m)c[m]=c[m+1]*l[m+1]}let f=w.getArrayFromDType(n,i*o);for(let m=0;m<i;++m){let g=0;for(let y=0;y<d;++y)g+=e[m*d+y]*h[y];for(let y=0;y<o;++y)f[m*o+y]=Math.trunc(g/c[y]),g%=c[y]}return[f,[i,o],l]}function vx(e,t,n,r,a,s=!1,i=0){let o=r.length,l=[t[0],e.length/t[0]],p=l[1],u=o>0?a[o-1]+1:0;if(u<0)throw new Error(N.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let d=t.slice();d[0]=u;let h=d.reduce((b,x)=>b*x,1),c=w.getArrayFromDType(n,h);if(o===0)return u>0&&c.fill(i),[c,d];if(u<=0)throw new Error(N.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let f=0,m=1,g=0,y=a[f];for(;;){let b=0;if(m<o){if(b=a[m],y===b){++m;continue}if(y>=b)throw new Error(N.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(y<0||y>=u)throw new Error(N.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(y,u));y>g&&c.fill(i,g*p,y*p);for(let x=f;x<m;++x){let v=r[x];if(v<0||v>=l[0])throw new Error(N.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(x,r[x],l[0]));for(let I=0;I<p;I++)c[y*p+I]+=e[v*p+I]}if(s)for(let x=0;x<p;x++)c[y*p+x]/=m-f;if(f=m,++m,g=y+1,y=b,m>o)break}return g<u&&c.fill(i,g*p,u*p),[c,d]}var U6=Zr(e=>Math.sqrt(e)),G6=nt(po,e=>Math.sqrt(e)),H6={kernelName:po,backendName:"cpu",kernelFunc:G6},e2=Tt((e,t)=>{let n=e-t;return n*n}),j6=Bt(fo,e2),q6={kernelName:fo,backendName:"cpu",kernelFunc:j6},t2=Zr((e,t)=>{let{pattern:n,replaceGlobal:r,rewrite:a}=t;return e.replace(new RegExp(n,r?"g":""),a)}),K6=os(zp,t2),X6={kernelName:zp,backendName:"cpu",kernelFunc:K6};function n2(e,t,n,r){let a=ze(e,t.dtype);for(let s=0;s<a.size;s++){let i=a.indexToLoc(s),o=new Array(i.length);for(let l=0;l<o.length;l++)o[l]=i[l]*n[l]+r[l];a.set(t.get(...o),...i)}return a}var Z6=class{constructor(e,t,n,r,a,s){this.separator=w.encodeString(e),this.nGramWidths=t,this.leftPad=w.encodeString(n),this.rightPad=w.encodeString(r),this.padWidth=a,this.preserveShort=s}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){let n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,a,s){for(let i=0;i<a;++i){let o=this.getPadWidth(s),l=Math.max(0,o-i),p=Math.max(0,o-(a-(i+1))),u=s-(l+p),d=t+(l>0?0:i-o),h=0;h+=l*this.leftPad.length;for(let y=0;y<u;++y)h+=e[d+y].length;h+=p*this.rightPad.length;let c=l+p+u-1;h+=c*this.separator.length,n[r+i]=new Uint8Array(h);let f=n[r+i],m=0,g=y=>y.forEach(b=>f[m++]=b);for(let y=0;y<l;++y)g(this.leftPad),g(this.separator);for(let y=0;y<u-1;++y)g(e[d+y]),g(this.separator);if(u>0){g(e[d+u-1]);for(let y=0;y<p;++y)g(this.separator),g(this.rightPad)}else{for(let y=0;y<p-1;++y)g(this.rightPad),g(this.separator);g(this.rightPad)}}}compute(e,t){let n=e.length,r=t.length;if(r>0){let o=t[0];if(o!==0)throw new Error(`First split value must be 0, got ${o}`);for(let l=1;l<r;++l){let p=t[l]>=o;if(p=p&&t[l]<=n,!p)throw new Error(`Invalid split value ${t[l]}, must be in [${o}, ${n}]`);o=t[l]}if(o!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${o}`)}let a=r-1,s=w.getArrayFromDType("int32",r);if(n===0||r===0){let o=new Array(n);for(let l=0;l<=a;++l)s[l]=0;return[o,s]}s[0]=0;for(let o=1;o<=a;++o){let l=t[o]-t[o-1],p=0;this.nGramWidths.forEach(u=>{p+=this.getNumNGrams(l,u)}),this.preserveShort&&l>0&&p===0&&(p=1),s[o]=s[o-1]+p}let i=new Array(s[a]);for(let o=0;o<a;++o){let l=t[o],p=s[o];if(this.nGramWidths.forEach(u=>{let d=t[o+1]-t[o],h=this.getNumNGrams(d,u);this.createNGrams(e,l,i,p,h,u),p+=h}),this.preserveShort&&p===s[o]){let u=t[o+1]-t[o];if(u===0)continue;let d=u+2*this.padWidth;this.createNGrams(e,l,i,p,1,d)}}return[i,s]}};function wx(e,t,n,r,a,s,i,o){return new Z6(n,r,a,s,i,o).compute(e,t)}function J6(e,t,n,r){if(!e.length)return;if(t.length===0){for(let s=0;s<e.length;++s)r.push(e.subarray(s,s+1));return}if(t.length===1){let s=t[0],i=e.indexOf(s);for(;i!==-1;){let o=e.subarray(0,i);(!n||o.length!==0)&&r.push(o),e=e.subarray(i+1),i=e.indexOf(s)}(!n||e.length!==0)&&r.push(e);return}let a=0;for(let s=0;s<e.length+1;s++)if(s===e.length||t.indexOf(e[s])!==-1){let i=e.subarray(a,s);(!n||i.length!==0)&&r.push(i),a=s+1}}function kx(e,t,n){let r=e.length,a=[],s=0,i=0,o=new Array(r);for(let h=0;h<r;++h){let c=a.length;J6(e[h],t,n,a);let f=a.length-c;o[h]=f,s+=f,i=Math.max(i,f)}let l=w.getArrayFromDType("int32",s*2),p=new Array(s),u=[r,i],d=0;for(let h=0;h<r;++h)for(let c=0;c<o[h];++c)l[d*2]=h,l[d*2+1]=c,p[d]=a[d],++d;return[l,p,u]}function Ix(e,t){let n=w.getArrayFromDType("int32",e.length);for(let r=0;r<e.length;++r)n[r]=w.fingerPrint64(e[r]).modulo(t).getLowBitsUnsigned();return n}var r2=Tt((e,t)=>e-t),Y6=fx((e,t,n,r)=>({real:e-n,imag:t-r})),Sx=Bt(mo,r2,Y6),Q6={kernelName:mo,backendName:"cpu",kernelFunc:Sx};function a2(e,t){let n=new Array(e.rank);for(let a=0;a<n.length;a++)n[a]=e.shape[a]*t[a];let r=ze(n,e.dtype);for(let a=0;a<r.values.length;++a){let s=r.indexToLoc(a),i=new Array(e.rank);for(let l=0;l<i.length;l++)i[l]=s[l]%e.shape[l];let o=e.locToIndex(i);r.values[a]=e.values[o]}return r}var Hu=(e,t)=>{let n=t.value-e.value;return n===0?e.index-t.index:n};function s2(e,t,n=0,r=e.length-1){for(;r>n;){if(r-n>600){let o=r-n+1,l=t-n+1,p=Math.log(o),u=.5*Math.exp(2*p/3),d=.5*Math.sqrt(p*u*(o-u)/o)*Math.sign(l-o/2),h=Math.max(n,Math.floor(t-l*u/o+d)),c=Math.min(r,Math.floor(t+(o-l)*u/o+d));s2(e,t,h,c)}let a=e[t],s=n,i=r;for(w.swap(e,n,t),Hu(e[r],a)>0&&w.swap(e,n,r);s<i;){for(w.swap(e,s,i),s++,i--;Hu(e[s],a)<0;)s=s+1;for(;Hu(e[i],a)>0;)i=i-1}Hu(e[n],a)===0?w.swap(e,n,i):(i=i+1,w.swap(e,i,r)),i<=t&&(n=i+1),t<=i&&(r=i-1)}}function i2(e,t,n,r,a){let s=t[t.length-1],[i,o]=[e.length/s,s],l=w.getTypedArrayFromDType(n,i*r),p=w.getTypedArrayFromDType("int32",i*r);for(let d=0;d<i;d++){let h=d*o,c=e.subarray(h,h+o),f=new Array(c.length);c.forEach((b,x)=>f[x]={value:b,index:x}),r<f.length&&(s2(f,r),f=f.slice(0,r)),a&&f.sort(Hu);let m=d*r,g=l.subarray(m,m+r),y=p.subarray(m,m+r);for(let b=0;b<r;b++)g[b]=f[b].value,y[b]=f[b].index}let u=t.slice();return u[u.length-1]=r,[ze(u,n,l),ze(u,"int32",p)]}function Nx(e,t,n,r){let a=w.parseAxisParam(t,n)[0],s=[1,n[0],1];for(let f=0;f<a;f++)s[0]*=n[f];s[1]=n[a];for(let f=a+1;f<n.length;f++)s[2]*=n[f];let i=new Map,o=new Int32Array(n[a]),l=new $t(s,r,e),p=[],u=s[0]===1&&s[2]===1;for(let f=0;f<n[a];f++){let m;if(u)m=e[f].toString();else{let y=[];for(let b=0;b<s[0];b++)for(let x=0;x<s[2];x++)y.push(l.get(b,f,x));m=y.join(",")}let g=i.get(m);if(g!=null)o[f]=g;else{let y=i.size;i.set(m,y),o[f]=y,p.push(f)}}let d=s.slice();d[1]=i.size;let h=new $t(d,r);p.forEach((f,m)=>{for(let g=0;g<s[0];g++)for(let y=0;y<s[2];y++)h.set(l.get(g,f,y),g,m,y)});let c=n.slice();return c[a]=d[1],{outputValues:h.values,outputShape:c,indices:o}}var ej="4.22.0";pc("cpu",()=>new hx,1);var o2=nt(vi,e=>e>=0?e:Math.exp(e)-1),tj={kernelName:vi,backendName:"cpu",kernelFunc:o2};function l2(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:s}=r;ye([a],"leakyRelu");let i=w.sizeFromShape(a.shape),o=n.data.get(a.dataId).values,l=w.getTypedArrayFromDType("float32",i);for(let p=0;p<o.length;p++)l[p]=o[p]<0?s*o[p]:o[p];return n.makeTensorInfo(a.shape,"float32",l)}var nj={kernelName:Fi,backendName:"cpu",kernelFunc:l2},rj=Tt((e,t)=>e<0?t*e:e);function u2(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t;ye([r,a],"prelu");let s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,[o,l]=rj(r.shape,a.shape,s,i,"float32");return n.makeTensorInfo(l,"float32",o)}var aj={kernelName:Ki,backendName:"cpu",kernelFunc:u2},p2=nt(Ji,e=>Math.max(0,e)),sj={kernelName:Ji,backendName:"cpu",kernelFunc:p2},d2=nt(eo,e=>Math.min(Math.max(0,e),6)),ij={kernelName:eo,backendName:"cpu",kernelFunc:d2};function Dh(e,t,n,r,a){if(n==="linear")return jr({inputs:{x:t},backend:e});if(n==="relu")return p2({inputs:{x:t},backend:e});if(n==="elu")return o2({inputs:{x:t},backend:e});if(n==="relu6")return d2({inputs:{x:t},backend:e});if(n==="prelu")return u2({inputs:{x:t,alpha:r},backend:e});if(n==="leakyrelu")return l2({inputs:{x:t},backend:e,attrs:{alpha:a}});if(n==="sigmoid")return JN({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function ft(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:s}=r,i=w.sizeFromShape(a.shape),o=w.inferFromImplicitShape(s,i),l=w.sizeFromShape(o);w.assert(i===l,()=>`The new shape (${o}) has ${l} elements and the old shape (${a.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),n.incRef(a.dataId);let p=n.data.get(a.dataId);if(p.complexTensorInfos!=null){let u=p.complexTensorInfos.real,d=p.complexTensorInfos.imag;u.shape=o,d.shape=o}return{dataId:a.dataId,shape:o,dtype:a.dtype}}var oj={kernelName:Kl,backendName:"cpu",kernelFunc:ft};function h2(e){let{inputs:t,backend:n,attrs:r}=e,{a,b:s}=t,{transposeA:i,transposeB:o}=r;ye([a,s],"matMul");let l=a.shape.length,p=s.shape.length,u=i?a.shape[l-2]:a.shape[l-1],d=o?s.shape[p-1]:s.shape[p-2],h=i?a.shape[l-1]:a.shape[l-2],c=o?s.shape[p-2]:s.shape[p-1],f=a.shape.slice(0,-2),m=s.shape.slice(0,-2),g=w.sizeFromShape(f),y=w.sizeFromShape(m),b=hu.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)).concat([h,c]);w.assert(u===d,()=>`Error in matMul: inner shapes (${u}) and (${d}) of Tensors with shapes ${a.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`);let x=i?[g,u,h]:[g,h,u],v=o?[y,c,d]:[y,d,c],I=ft({inputs:{x:a},backend:n,attrs:{shape:x}}),T=ft({inputs:{x:s},backend:n,attrs:{shape:v}}),_=i?I.shape[1]:I.shape[2],E=i?I.shape[2]:I.shape[1],A=o?T.shape[1]:T.shape[2],R=Math.max(g,y),F=n.data.get(I.dataId).values,S=n.data.get(T.dataId).values,M=w.computeStrides(I.shape),W=w.computeStrides(T.shape),[U,H,K]=i?[M[0],1,M[1]]:[M[0],M[1],1],[j,Z,ee]=o?[1,W[1],W[0]]:[W[1],1,W[0]],Y=E*A,re=ze([R,E,A],I.dtype),te=re.values,ae=n.blockSize;for(let ie=0;ie<R;ie++){let ve=ie%g,be=ie%y;for(let he=0;he<E;he+=ae){let Ie=Math.min(he+ae,E);for(let Te=0;Te<A;Te+=ae){let Re=Math.min(Te+ae,A);for(let Pe=0;Pe<_;Pe+=ae){let rt=Math.min(Pe+ae,_);for(let Ge=he;Ge<Ie;Ge++)for(let qe=Te;qe<Re;qe++){let $e=0;for(let Je=Pe;Je<rt;Je++){let pt=F[ve*U+Ge*H+Je*K],Fn=S[Je*j+qe*Z+be*ee];$e+=pt*Fn}te[ie*Y+(Ge*A+qe)]+=$e}}}}}return n.disposeIntermediateTensorInfo(I),n.disposeIntermediateTensorInfo(T),n.makeTensorInfo(b,re.dtype,re.values)}var lj={kernelName:li,backendName:"cpu",kernelFunc:h2};function uj(e){let{inputs:t,backend:n,attrs:r}=e,{a,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:p,activation:u,leakyreluAlpha:d}=r,h,c,f,m=[];h=h2({inputs:{a,b:s},attrs:{transposeA:l,transposeB:p},backend:n}),i&&(c=sl({inputs:{a:h,b:i},backend:n}),m.push(h),h=c),u&&(f=Dh(n,h,u,o,d),m.push(h),h=f);for(let g of m)n.disposeIntermediateTensorInfo(g);return h}var pj={kernelName:Fs,backendName:"cpu",kernelFunc:uj},dj=nt(Qs,e=>Math.acos(e)),hj={kernelName:Qs,backendName:"cpu",kernelFunc:dj},cj=nt(ei,e=>Math.acosh(e)),fj={kernelName:ei,backendName:"cpu",kernelFunc:cj};function mj(e){let{inputs:t,backend:n}=e,r=t;ye(t,"addN");let a=r.map(o=>n.data.get(o.dataId).values),s=ze(r[0].shape,r[0].dtype),i=s.values;for(let o=0;o<r.length;o++){let l=a[o];for(let p=0;p<i.length;p++)i[p]+=l[p]}return n.makeTensorInfo(s.shape,s.dtype,s.values)}var gj={kernelName:ti,backendName:"cpu",kernelFunc:mj};function yj(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;ye(a,"all");let o=w.parseAxisParam(s,a.shape),l=o,p=N.getAxesPermutation(l,a.shape.length),u=a;p!=null&&(u=$n({inputs:{x:a},backend:n,attrs:{perm:p}}),l=N.getInnerMostAxes(l.length,a.shape.length)),N.assertAxesAreInnerMostDims("all",l,u.shape.length);let[d,h]=N.computeOutAndReduceShapes(u.shape,l),c=w.sizeFromShape(h),f=w.makeZerosTypedArray(w.sizeFromShape(d),u.dtype),m=n.data.get(u.dataId).values;for(let y=0;y<f.length;++y){let b=y*c,x=m[b];for(let v=0;v<c;++v){let I=m[b+v];x=x&&I}f[y]=x}p!=null&&n.disposeIntermediateTensorInfo(u);let g=n.makeTensorInfo(d,u.dtype,f);if(i){let y=N.expandShapeToKeepDim(d,o),b=ft({inputs:{x:g},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(g),b}return g}var bj={kernelName:dl,backendName:"cpu",kernelFunc:yj};function xj(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;ye(a,"any");let o=w.parseAxisParam(s,a.shape),l=o,p=N.getAxesPermutation(l,a.shape.length),u=a;p!=null&&(u=$n({inputs:{x:a},backend:n,attrs:{perm:p}}),l=N.getInnerMostAxes(l.length,a.shape.length)),N.assertAxesAreInnerMostDims("any",l,u.shape.length);let[d,h]=N.computeOutAndReduceShapes(u.shape,l),c=w.sizeFromShape(h),f=w.makeZerosTypedArray(w.sizeFromShape(d),u.dtype),m=n.data.get(u.dataId).values;for(let y=0;y<f.length;++y){let b=y*c,x=m[b];for(let v=0;v<c;++v){let I=m[b+v];x=x||I}f[y]=x}p!=null&&n.disposeIntermediateTensorInfo(u);let g=n.makeTensorInfo(d,u.dtype,f);if(i){let y=N.expandShapeToKeepDim(d,o),b=ft({inputs:{x:g},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(g),b}return g}var vj={kernelName:hl,backendName:"cpu",kernelFunc:xj};function wj(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;ye(a,"argMax");let i=w.parseAxisParam(s,a.shape),o=N.getAxesPermutation(i,a.shape.length),l=a,p=[];o!=null&&(l=$n({inputs:{x:a},backend:n,attrs:{perm:o}}),p.push(l),i=N.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],N.assertAxesAreInnerMostDims("argMax",i,l.shape.length);let[u,d]=N.computeOutAndReduceShapes(l.shape,i),h=w.sizeFromShape(u),c=w.makeZerosTypedArray(h,"int32"),f=w.sizeFromShape(d),m=n.data.get(l.dataId).values;for(let g=0;g<c.length;++g){let y=g*f,b=m[y],x=0;for(let v=0;v<f;++v){let I=m[y+v];I>b&&(b=I,x=v)}c[g]=x}return p.forEach(g=>n.disposeIntermediateTensorInfo(g)),n.makeTensorInfo(u,"int32",c)}var kj={kernelName:cl,backendName:"cpu",kernelFunc:wj};function Ij(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;ye(a,"argMin");let i=w.parseAxisParam(s,a.shape),o=N.getAxesPermutation(i,a.shape.length),l=a,p=[];o!=null&&(l=$n({inputs:{x:a},backend:n,attrs:{perm:o}}),p.push(l),i=N.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],N.assertAxesAreInnerMostDims("argMin",i,l.shape.length);let[u,d]=N.computeOutAndReduceShapes(l.shape,i),h=w.sizeFromShape(u),c=w.makeZerosTypedArray(h,"int32"),f=w.sizeFromShape(d),m=n.data.get(l.dataId).values;for(let g=0;g<c.length;++g){let y=g*f,b=m[y],x=0;for(let v=0;v<f;++v){let I=m[y+v];I<b&&(b=I,x=v)}c[g]=x}return p.forEach(g=>n.disposeIntermediateTensorInfo(g)),n.makeTensorInfo(u,"int32",c)}var Sj={kernelName:fl,backendName:"cpu",kernelFunc:Ij},Nj=nt(ni,e=>Math.asin(e)),Tj={kernelName:ni,backendName:"cpu",kernelFunc:Nj},Cj=nt(ri,e=>Math.asinh(e)),_j={kernelName:ri,backendName:"cpu",kernelFunc:Cj},Ej=nt(ai,e=>Math.atan(e)),$j={kernelName:ai,backendName:"cpu",kernelFunc:Ej},Aj=Tt((e,t)=>Math.atan2(e,t)),Fj=Bt(ii,Aj),Rj={kernelName:ii,backendName:"cpu",kernelFunc:Fj},Dj=nt(si,e=>Math.atanh(e)),Mj={kernelName:si,backendName:"cpu",kernelFunc:Dj};function Tx(e,t,n,r,a,s){let i=a.strideHeight,o=a.strideWidth,l=a.dilationHeight,p=a.dilationWidth,u=a.effectiveFilterHeight,d=a.effectiveFilterWidth,h=a.padInfo.top,c=a.padInfo.left,f=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=ze(a.outShape,n),g=m.values,y=a.outShape[1]*a.outShape[2]*a.outShape[3],b=a.outShape[2]*a.outShape[3],x=a.outShape[3];for(let v=0;v<a.batchSize;++v){let I=v*y,T=v*r[0];for(let _=0;_<a.inChannels;++_)for(let E=0;E<a.outHeight;++E){let A=E*i-h,R=Math.max(0,A),F=Math.min(a.inHeight,u+A),S=I+E*b;for(let M=0;M<a.outWidth;++M){let W=M*o-c,U=Math.max(0,W),H=Math.min(a.inWidth,d+W),K=f,j=0,Z=0;for(let Y=R;Y<F;Y+=l){let re=T+Y*r[1];for(let te=U;te<H;te+=p){let ae=re+te*r[2],ie=e[ae+_];s==="max"&&ie>K?K=ie:s==="avg"&&(j+=ie,Z++)}if(isNaN(K))break}let ee=S+M*x+_;g[ee]=s==="avg"?j/Z:K}}}return m}function c2(e,t,n,r,a=!1,s=!1){let i=ze(r.outShape,"int32"),o=r.strideHeight,l=r.strideWidth,p=r.dilationHeight,u=r.dilationWidth,d=r.effectiveFilterHeight,h=r.effectiveFilterWidth,c=r.padInfo.top,f=r.padInfo.left,m=ze(t,n,e);for(let g=0;g<r.batchSize;++g)for(let y=0;y<r.inChannels;++y)for(let b=0;b<r.outHeight;++b){let x=b*o-c,v=x;for(;v<0;)v+=p;let I=Math.min(r.inHeight,d+x);for(let T=0;T<r.outWidth;++T){let _=T*l-f,E=_;for(;E<0;)E+=u;let A=Math.min(r.inWidth,h+_),R=Number.NEGATIVE_INFINITY,F=-1;for(let S=v;S<I;S+=p){let M=S-x;for(let W=E;W<A;W+=u){let U=W-_,H=m.get(g,S,W,y);H>R&&(R=H,a?F=s?((g*r.inHeight+S)*r.inWidth+W)*r.inChannels+y:(S*r.inWidth+W)*r.inChannels+y:F=M*h+U)}}i.set(F,g,b,T,y)}}return i}function f2(e,t,n,r,a,s){let i=a.strideDepth,o=a.strideHeight,l=a.strideWidth,p=a.dilationDepth,u=a.dilationHeight,d=a.dilationWidth,h=a.effectiveFilterDepth,c=a.effectiveFilterHeight,f=a.effectiveFilterWidth,m=a.padInfo.front,g=a.padInfo.top,y=a.padInfo.left,b=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=ze(a.outShape,n),v=x.values,I=a.outShape[1]*a.outShape[2]*a.outShape[3]*a.outShape[4],T=a.outShape[2]*a.outShape[3]*a.outShape[4],_=a.outShape[3]*a.outShape[4],E=a.outShape[4];for(let A=0;A<a.batchSize;++A){let R=A*I,F=A*r[0];for(let S=0;S<a.inChannels;++S)for(let M=0;M<a.outDepth;++M){let W=M*i-m,U=W;for(;U<0;)U+=p;let H=Math.min(a.inDepth,h+W),K=R+M*T;for(let j=0;j<a.outHeight;++j){let Z=j*o-g,ee=Z;for(;ee<0;)ee+=u;let Y=Math.min(a.inHeight,c+Z),re=K+j*_;for(let te=0;te<a.outWidth;++te){let ae=te*l-y,ie=ae;for(;ie<0;)ie+=d;let ve=Math.min(a.inWidth,f+ae),be=re+te*E,he=b,Ie=0,Te=0;for(let Pe=U;Pe<H;Pe+=p){let rt=F+Pe*r[1];for(let Ge=ee;Ge<Y;Ge+=u){let qe=rt+Ge*r[2];for(let $e=ie;$e<ve;$e+=d){let Je=qe+$e*r[3],pt=e[Je+S];if(s==="max"&&pt>he?he=pt:s==="avg"&&(Ie+=pt,Te++),isNaN(he))break}if(isNaN(he))break}if(isNaN(he))break}let Re=be+S;v[Re]=s==="avg"?Ie/Math.max(Te,1):he}}}}return x}function Oj(e,t){let n=ze(t.outShape,"int32"),r=t.strideDepth,a=t.strideHeight,s=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,p=t.effectiveFilterDepth,u=t.effectiveFilterHeight,d=t.effectiveFilterWidth,h=t.padInfo.front,c=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){let b=y*r-h,x=b;for(;x<0;)x+=i;let v=Math.min(t.inDepth,p+b);for(let I=0;I<t.outHeight;++I){let T=I*a-c,_=T;for(;_<0;)_+=o;let E=Math.min(t.inHeight,u+T);for(let A=0;A<t.outWidth;++A){let R=A*s-f,F=R;for(;F<0;)F+=l;let S=Math.min(t.inWidth,d+R),M=Number.NEGATIVE_INFINITY,W=-1;for(let U=x;U<v;U+=i){let H=U-b;for(let K=_;K<E;K+=o){let j=K-T;for(let Z=F;Z<S;Z+=l){let ee=Z-R,Y=e.get(m,U,K,Z,g);Y>=M&&(M=Y,W=H*u*d+j*u+ee)}}}n.set(W,m,y,I,A,g)}}}return n}function Lj(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;ye(a,"avgPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r,p=1;w.assert(N.eitherStridesOrDilationsAreOne(i,p),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${p}'`);let u=N.computePool2DInfo(a.shape,s,i,p,o,l),d;if(u.filterWidth===1&&u.filterHeight===1&&w.arraysEqual(u.inShape,u.outShape))d=jr({inputs:{x:a},backend:n});else{let h=n.data.get(a.dataId).values,c=w.computeStrides(a.shape),f=Tx(h,a.shape,a.dtype,c,u,"avg");d=n.makeTensorInfo(u.outShape,a.dtype,f.values)}return d}var zj={kernelName:oi,backendName:"cpu",kernelFunc:Lj};function Pj(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:p}=r;ye(a,"avgPool3d");let u=N.computePool3DInfo(a.shape,s,i,1,o,l,p),d=n.data.get(a.dataId).values,h=f2(d,a.shape,a.dtype,w.computeStrides(a.shape),u,"avg");return n.makeTensorInfo(h.shape,"float32",h.values)}var Bj={kernelName:ml,backendName:"cpu",kernelFunc:Pj};function Wj(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:p}=r;ye([a,s],"avgPool3DGrad");let u=N.computePool3DInfo(s.shape,i,o,1,l,p),d=u.strideDepth,h=u.strideHeight,c=u.strideWidth,f=u.filterDepth,m=u.filterHeight,g=u.filterWidth,y=u.dilationDepth,b=u.dilationHeight,x=u.dilationWidth,v=u.effectiveFilterDepth,I=u.effectiveFilterHeight,T=u.effectiveFilterWidth,_=v-1-u.padInfo.front,E=T-1-u.padInfo.left,A=I-1-u.padInfo.top,R=ze(s.shape,"float32"),F=1/(f*m*g),S=n.bufferSync(a);for(let M=0;M<u.batchSize;++M)for(let W=0;W<u.inChannels;++W)for(let U=0;U<u.inDepth;++U)for(let H=0;H<u.inHeight;++H)for(let K=0;K<u.inWidth;++K){let j=U-_,Z=H-A,ee=K-E,Y=0;for(let re=0;re<v;re+=y){let te=(j+re)/d;if(!(te<0||te>=u.outDepth||Math.floor(te)!==te))for(let ae=0;ae<I;ae+=b){let ie=(Z+ae)/h;if(!(ie<0||ie>=u.outHeight||Math.floor(ie)!==ie))for(let ve=0;ve<T;ve+=x){let be=(ee+ve)/c;if(be<0||be>=u.outWidth||Math.floor(be)!==be)continue;let he=S.get(M,te,ie,be,W);Y+=he}}}R.set(Y*F,M,U,H,K,W)}return n.makeTensorInfo(R.shape,R.dtype,R.values)}var Vj={kernelName:Sp,backendName:"cpu",kernelFunc:Wj};function Uj(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s;ye([a,s],"avgPoolGrad");let{filterSize:o,strides:l,pad:p}=r,u=N.computePool2DInfo(i.shape,o,l,1,p),d=u.strideHeight,h=u.strideWidth,c=u.filterHeight,f=u.filterWidth,m=u.dilationHeight,g=u.dilationWidth,y=u.effectiveFilterHeight,b=u.effectiveFilterWidth,x=b-1-u.padInfo.left,v=y-1-u.padInfo.top,I=ze(i.shape,"float32"),T=1/(c*f),_=n.data.get(a.dataId).values,E=ze(a.shape,"float32",_);for(let A=0;A<u.batchSize;++A)for(let R=0;R<u.inChannels;++R)for(let F=0;F<u.inHeight;++F)for(let S=0;S<u.inWidth;++S){let M=F-v,W=S-x,U=0;for(let H=0;H<y;H+=m){let K=(M+H)/d;if(!(K<0||K>=u.outHeight||Math.floor(K)!==K))for(let j=0;j<b;j+=g){let Z=(W+j)/h;if(Z<0||Z>=u.outWidth||Math.floor(Z)!==Z)continue;let ee=E.get(A,K,Z,R);U+=ee}}I.set(U*T,A,F,S,R)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}var Gj={kernelName:Ip,backendName:"cpu",kernelFunc:Uj};function Hj(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,scale:s,offset:i,mean:o,variance:l}=t;w.assert(o.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),w.assert(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),w.assert(s==null||o.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),ye([a,o,l,s,i],"batchNorm");let{varianceEpsilon:p}=r;p==null&&(p=.001);let u=n.data.get(a.dataId).values,d=n.data.get(o.dataId).values,h=n.data.get(l.dataId).values,c=s?n.data.get(s.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(u.length),g=f.length,y=c.length,b=h.length,x=d.length,v=0,I=0,T=0,_=0;for(let E=0;E<u.length;++E)m[E]=f[v++]+(u[E]-d[I++])*c[T++]/Math.sqrt(h[_++]+p),v>=g&&(v=0),I>=x&&(I=0),T>=y&&(T=0),_>=b&&(_=0);return n.makeTensorInfo(a.shape,a.dtype,m)}var jj={kernelName:Ti,backendName:"cpu",kernelFunc:Hj};function qj(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r;ye([a],"batchToSpaceND");let o=s.reduce((y,b)=>y*b),l=N.getReshaped(a.shape,s,o),p=N.getPermuted(l.length,s.length),u=N.getReshapedPermuted(a.shape,s,o),d=N.getSliceBeginCoords(i,s.length),h=N.getSliceSize(u,i,s.length),c=ft({inputs:{x:a},backend:n,attrs:{shape:l}}),f=$n({inputs:{x:c},backend:n,attrs:{perm:p}}),m=ft({inputs:{x:f},backend:n,attrs:{shape:u}}),g=js({inputs:{x:m},backend:n,attrs:{begin:d,size:h}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}var Kj={kernelName:gl,backendName:"cpu",kernelFunc:qj};function Xj(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i}=r,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,p=mx(o,l,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,p)}var Zj={kernelName:yl,backendName:"cpu",kernelFunc:Xj};function Jj(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,o=N.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}var Yj={kernelName:Np,backendName:"cpu",kernelFunc:Jj},Qj=nt(Qa,(e,t)=>{let n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e}),eq={kernelName:Qa,backendName:"cpu",kernelFunc:Qj},tq=e=>{let{x:t}=e.inputs,n=e.backend,r=new Float32Array(w.sizeFromShape(t.shape)),a=n.data.get(t.dataId),s=a.complexTensorInfos.real,i=a.complexTensorInfos.imag,o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values;for(let p=0;p<o.length;p++){let u=o[p],d=l[p];r[p]=Math.hypot(u,d)}return n.makeOutput(r,t.shape,"float32")},nq={kernelName:Tp,backendName:"cpu",kernelFunc:tq};function il(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.imag,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}var rq={kernelName:rc,backendName:"cpu",kernelFunc:il};function ol(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,s=w.parseAxisParam(a,t[0].shape)[0],i=t.map(m=>m.shape);N.assertParamsConsistent(i,s);let o=N.computeOutShape(t.map(m=>m.shape),s);if(w.sizeFromShape(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter(m=>w.sizeFromShape(m.shape)>0);if(l.length===1)return jr({inputs:{x:l[0]},backend:n});if(l[0].dtype==="complex64"){let m=l.map(v=>Hs({inputs:{input:v},backend:n})),g=l.map(v=>il({inputs:{input:v},backend:n})),y=ol({inputs:m,backend:n,attrs:{axis:s}}),b=ol({inputs:g,backend:n,attrs:{axis:s}}),x=zn({inputs:{real:y,imag:b},backend:n});return m.forEach(v=>n.disposeIntermediateTensorInfo(v)),g.forEach(v=>n.disposeIntermediateTensorInfo(v)),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(b),x}let p=l.map(m=>{let g=[-1,w.sizeFromShape(m.shape.slice(s))];return ft({inputs:{x:m},backend:n,attrs:{shape:g}})}),u=p.map(m=>({vals:n.data.get(m.dataId).values,shape:m.shape}));o=N.computeOutShape(p.map(m=>m.shape),1);let d=p[0].shape[0]===1,h=gx(u,o,t[0].dtype,d),c=N.computeOutShape(l.map(m=>m.shape),s),f=n.makeTensorInfo(c,t[0].dtype,h);return p.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}var aq={kernelName:xl,backendName:"cpu",kernelFunc:ol};function m2(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dataFormat:l,dilations:p,dimRoundingMode:u}=r;ye([a,s],"conv2d");let d=N.convertConv2DDataFormat(l),h=N.computeConv2DInfo(a.shape,s.shape,i,p,o,u,!1,d),c=h.filterHeight,f=h.filterWidth,m=h.dilationHeight,g=h.dilationWidth,y=h.padInfo.left,b=h.padInfo.top,x=h.dataFormat==="channelsLast",v=new $t(h.outShape,a.dtype),I=w.computeStrides(a.shape),T=w.computeStrides(s.shape),_=I[0],E=x?I[1]:I[2],A=x?I[2]:1,R=x?1:I[1],F=v.strides[0],S=x?v.strides[1]:v.strides[2],M=x?v.strides[2]:1,W=x?1:v.strides[1],U=n.data.get(a.dataId).values,H=n.data.get(s.dataId).values,K=v.values;for(let j=0;j<h.batchSize;++j){let Z=j*_,ee=j*F;for(let Y=0;Y<h.outHeight;++Y){let re=ee+Y*S,te=Y*h.strideHeight-b;for(let ae=0;ae<c;++ae){let ie=te+ae*m;if(ie<0||ie>=h.inHeight)continue;let ve=ae*T[0],be=Z+ie*E;for(let he=0;he<h.outWidth;++he){let Ie=re+he*M,Te=he*h.strideWidth-y;for(let Re=0;Re<f;++Re){let Pe=Te+Re*g;if(Pe<0||Pe>=h.inWidth)continue;let rt=ve+Re*T[1],Ge=be+Pe*A,qe=rt;for(let $e=0;$e<h.inChannels;++$e){let Je=U[Ge+$e*R];for(let pt=0;pt<h.outChannels;++pt)K[Ie+pt*W]+=Je*H[qe+pt];qe+=h.outChannels}}}}}}return n.makeTensorInfo(v.shape,v.dtype,K)}var sq={kernelName:di,backendName:"cpu",kernelFunc:m2};function iq(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:p,filterShape:u}=r;ye([a,s],"conv2dBackpropFilter");let d=N.convertConv2DDataFormat(l),h=N.computeConv2DInfo(a.shape,u,i,1,o,p,!1,d),{strideHeight:c,strideWidth:f,filterHeight:m,filterWidth:g}=h,y=h.dataFormat==="channelsLast",b=new $t(h.filterShape,"float32"),x=h.padInfo.left,v=h.padInfo.top,I=n.data.get(a.dataId).values,T=n.data.get(s.dataId).values,_=new $t(a.shape,a.dtype,I),E=new $t(s.shape,s.dtype,T);for(let A=0;A<m;++A){let R=Math.max(0,Math.ceil((v-A)/c)),F=Math.min(h.outHeight,(h.inHeight+v-A)/c);for(let S=0;S<g;++S){let M=Math.max(0,Math.ceil((x-S)/f)),W=Math.min(h.outWidth,(h.inWidth+x-S)/f);for(let U=0;U<h.inChannels;++U)for(let H=0;H<h.outChannels;++H){let K=0;for(let j=0;j<h.batchSize;++j)for(let Z=R;Z<F;++Z){let ee=A+Z*c-v;for(let Y=M;Y<W;++Y){let re=S+Y*f-x;y?K+=_.get(j,ee,re,U)*E.get(j,Z,Y,H):K+=_.get(j,U,ee,re)*E.get(j,H,Z,Y)}}b.set(K,A,S,U,H)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}var oq={kernelName:Zh,backendName:"cpu",kernelFunc:iq};function lq(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:p,dimRoundingMode:u}=r;ye([a,s],"conv2dBackpropInput");let d=w.computeStrides(s.shape),h=w.computeStrides(a.shape),c=N.convertConv2DDataFormat(p),f=N.computeConv2DInfo(i,s.shape,o,1,l,u,!1,c),m=new $t(f.inShape,"float32"),g=m.values,y=n.data.get(a.dataId).values,b=n.data.get(s.dataId).values,[x,v,I]=d,{batchSize:T,filterHeight:_,filterWidth:E,inChannels:A,inHeight:R,inWidth:F,outChannels:S,outHeight:M,outWidth:W,strideHeight:U,strideWidth:H}=f;c=f.dataFormat;let K=_-1-f.padInfo.top,j=E-1-f.padInfo.left,Z=c==="channelsLast",ee=m.strides[0],Y=Z?m.strides[1]:m.strides[2],re=Z?m.strides[2]:1,te=Z?1:m.strides[1],ae=h[0],ie=Z?h[1]:h[2],ve=Z?h[2]:1,be=Z?1:h[1];for(let he=0;he<T;++he)for(let Ie=0;Ie<A;++Ie)for(let Te=0;Te<R;++Te){let Re=Te-K,Pe=Math.max(0,Math.ceil(Re/U)),rt=Math.min(M,(_+Re)/U);for(let Ge=0;Ge<F;++Ge){let qe=Ge-j,$e=Math.max(0,Math.ceil(qe/H)),Je=Math.min(W,(E+qe)/H),pt=0;for(let It=Pe;It<rt;++It){let wn=It*U-Re;for(let Jt=$e;Jt<Je;++Jt){let kn=Jt*H-qe,sr=ae*he+ie*It+ve*Jt,Rn=x*(_-1-wn)+v*(E-1-kn)+I*Ie;for(let In=0;In<S;++In){let Yt=y[sr+be*In],jn=b[Rn+In];pt+=Yt*jn}}}let Fn=ee*he+Y*Te+re*Ge+te*Ie;g[Fn]=pt}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}var uq={kernelName:hi,backendName:"cpu",kernelFunc:lq};function pq(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r;ye([a,s],"conv3d");let p=N.computeConv3DInfo(a.shape,s.shape,i,l,o),{filterDepth:u,filterHeight:d,filterWidth:h,dilationDepth:c,dilationHeight:f,dilationWidth:m,padInfo:g}=p,y=g.front,b=g.left,x=g.top,v=new $t(p.outShape,a.dtype),I=n.data.get(a.dataId).values,T=n.data.get(s.dataId).values,_=v.values,E=w.computeStrides(a.shape),A=w.computeStrides(s.shape);for(let R=0;R<p.batchSize;++R){let F=R*E[0],S=R*v.strides[0];for(let M=0;M<p.outDepth;++M){let W=S+M*v.strides[1],U=M*p.strideDepth-y;for(let H=0;H<u;++H){let K=U+H*c;if(K<0||K>=p.inDepth)continue;let j=H*A[0],Z=F+K*E[1];for(let ee=0;ee<p.outHeight;++ee){let Y=W+ee*v.strides[2],re=ee*p.strideHeight-x;for(let te=0;te<d;++te){let ae=re+te*f;if(ae<0||ae>=p.inHeight)continue;let ie=j+te*A[1],ve=Z+ae*E[2];for(let be=0;be<p.outWidth;++be){let he=Y+be*p.outChannels,Ie=be*p.strideWidth-b;for(let Te=0;Te<h;++Te){let Re=Ie+Te*m;if(Re<0||Re>=p.inWidth)continue;let Pe=ie+Te*A[2],rt=ve+Re*p.inChannels,Ge=Pe;for(let qe=0;qe<p.inChannels;++qe){let $e=I[rt+qe];for(let Je=0;Je<p.outChannels;++Je)_[he+Je]+=$e*T[Ge+Je];Ge+=p.outChannels}}}}}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}var dq={kernelName:ci,backendName:"cpu",kernelFunc:pq};function hq(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r;ye([a,s],"conv3dBackpropFilterV2");let p=w.computeStrides(a.shape),u=w.computeStrides(s.shape),d=N.computeConv3DInfo(a.shape,l,i,1,o),h=d.strideDepth,c=d.strideHeight,f=d.strideWidth,m=d.filterDepth,g=d.filterHeight,y=d.filterWidth,b=new $t(d.filterShape,"float32"),x=b.values,[v,I,T,_]=b.strides,E=n.data.get(s.dataId).values,[A,R,F,S]=u,M=n.data.get(a.dataId).values,[W,U,H,K]=p,j=d.padInfo.front,Z=d.padInfo.left,ee=d.padInfo.top;for(let Y=0;Y<m;++Y){let re=Math.max(0,Math.ceil((j-Y)/h)),te=Math.min(d.outDepth,(d.inDepth+j-Y)/h),ae=Y*v;for(let ie=0;ie<g;++ie){let ve=Math.max(0,Math.ceil((ee-ie)/c)),be=Math.min(d.outHeight,(d.inHeight+ee-ie)/c),he=ie*I+ae;for(let Ie=0;Ie<y;++Ie){let Te=Math.max(0,Math.ceil((Z-Ie)/f)),Re=Math.min(d.outWidth,(d.inWidth+Z-Ie)/f),Pe=Ie*T+he;for(let rt=0;rt<d.inChannels;++rt){let Ge=rt*_+Pe;for(let qe=0;qe<d.outChannels;++qe){let $e=0;for(let Je=0;Je<d.batchSize;++Je){let pt=Je*W,Fn=Je*A;for(let It=re;It<te;++It){let wn=(Y+It*h-j)*U+pt,Jt=It*R+Fn;for(let kn=ve;kn<be;++kn){let sr=(ie+kn*c-ee)*H+wn,Rn=kn*F+Jt;for(let In=Te;In<Re;++In){let Yt=(Ie+In*f-Z)*K+sr,jn=In*S+Rn;$e+=M[Yt+rt]*E[jn+qe]}}}}x[Ge+qe]=$e}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}var cq={kernelName:vl,backendName:"cpu",kernelFunc:hq};function fq(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r;ye([a],"conv3dBackpropInputV2");let p=w.computeStrides(a.shape),u=w.computeStrides(s.shape),d=N.computeConv3DInfo(l,s.shape,o,1,i),h=new $t(d.inShape,"float32"),c=h.values,[f,m,g,y]=h.strides,b=n.data.get(a.dataId).values,[x,v,I,T]=p,_=n.data.get(s.dataId).values,[E,A,R,F]=u,{batchSize:S,filterDepth:M,filterHeight:W,filterWidth:U,inChannels:H,inDepth:K,inHeight:j,inWidth:Z,outChannels:ee,outDepth:Y,outHeight:re,outWidth:te,strideDepth:ae,strideHeight:ie,strideWidth:ve}=d,be=M-1-d.padInfo.front,he=W-1-d.padInfo.top,Ie=U-1-d.padInfo.left;for(let Te=0;Te<S;++Te)for(let Re=0;Re<H;++Re)for(let Pe=0;Pe<K;++Pe){let rt=Pe-be,Ge=Math.max(0,Math.ceil(rt/ae)),qe=Math.min(Y,(M+rt)/ae);for(let $e=0;$e<j;++$e){let Je=$e-he,pt=Math.max(0,Math.ceil(Je/ie)),Fn=Math.min(re,(W+Je)/ie);for(let It=0;It<Z;++It){let wn=It-Ie,Jt=Math.max(0,Math.ceil(wn/ve)),kn=Math.min(te,(U+wn)/ve),sr=0;for(let Rn=Ge;Rn<qe;++Rn){let In=Rn*ae-rt;for(let Yt=pt;Yt<Fn;++Yt){let jn=Yt*ie-Je;for(let ba=Jt;ba<kn;++ba){let Ru=ba*ve-wn,Jr=x*Te+v*Rn+I*Yt+T*ba,Du=E*(M-1-In)+A*(W-1-jn)+R*(U-1-Ru)+F*Re;for(let $r=0;$r<ee;++$r){let xa=b[Jr+$r],Qt=_[Du+$r];sr+=xa*Qt}}}}c[f*Te+m*Pe+g*$e+y*It+Re]=sr}}}return n.makeTensorInfo(h.shape,h.dtype,h.values)}var mq={kernelName:wl,backendName:"cpu",kernelFunc:fq},gq=nt(fi,e=>Math.cos(e)),yq={kernelName:fi,backendName:"cpu",kernelFunc:gq},bq=nt(mi,e=>Math.cosh(e)),xq={kernelName:mi,backendName:"cpu",kernelFunc:bq};function vq(e){let{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:p}=r,[u,d,h,c]=a.shape,f=s.shape[0],[m,g]=o,y=ze([f,m,g,c],"float32"),b=n.data.get(s.dataId).values,x=n.data.get(i.dataId).values,v=n.data.get(a.dataId).values,I=w.computeStrides(a.shape),T=w.computeStrides(y.shape);for(let _=0;_<f;_++){let E=_*4,A=b[E],R=b[E+1],F=b[E+2],S=b[E+3],M=x[_];if(M>=u)continue;let W=m>1?(F-A)*(d-1)/(m-1):0,U=g>1?(S-R)*(h-1)/(g-1):0;for(let H=0;H<m;H++){let K=m>1?A*(d-1)+H*W:.5*(A+F)*(d-1);if(K<0||K>d-1){for(let j=0;j<g;j++)for(let Z=0;Z<c;Z++){let ee=Z+j*T[2]+H*T[1]+_*T[0];y.values[ee]=p}continue}if(l==="bilinear"){let j=Math.floor(K),Z=Math.ceil(K),ee=K-j;for(let Y=0;Y<g;Y++){let re=g>1?R*(h-1)+Y*U:.5*(R+S)*(h-1);if(re<0||re>h-1){for(let ve=0;ve<c;ve++){let be=ve+Y*T[2]+H*T[1]+_*T[0];y.values[be]=p}continue}let te=Math.floor(re),ae=Math.ceil(re),ie=re-te;for(let ve=0;ve<c;ve++){let be=ve+te*I[2]+j*I[1]+M*I[0],he=v[be];be=ve+ae*I[2]+j*I[1]+M*I[0];let Ie=v[be];be=ve+te*I[2]+Z*I[1]+M*I[0];let Te=v[be];be=ve+ae*I[2]+Z*I[1]+M*I[0];let Re=v[be],Pe=he+(Ie-he)*ie,rt=Te+(Re-Te)*ie;be=ve+Y*T[2]+H*T[1]+_*T[0],y.values[be]=Pe+(rt-Pe)*ee}}}else for(let j=0;j<g;++j){let Z=g>1?R*(h-1)+j*U:.5*(R+S)*(h-1);if(Z<0||Z>h-1){for(let re=0;re<c;re++){let te=re+j*T[2]+H*T[1]+_*T[0];y.values[te]=p}continue}let ee=Math.round(Z),Y=Math.round(K);for(let re=0;re<c;re++){let te=re+ee*I[2]+Y*I[1]+M*I[0],ae=re+j*T[2]+H*T[1]+_*T[0];y.values[ae]=v[te]}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}var wq={kernelName:Il,backendName:"cpu",kernelFunc:vq};function kq(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;ye(a,"cumprod");let l=N.getAxesPermutation([s],a.shape.length),p=a;l!=null&&(p=$n({inputs:{x:a},backend:n,attrs:{perm:l}}));let u=N.getInnerMostAxes(1,a.shape.length)[0];if(u!==p.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${p.shape.length-1} but got axis=${u}`);let d=tr(p.dtype,"int32"),h=w.makeOnesTypedArray(w.sizeFromShape(p.shape),d),c=n.data.get(p.dataId).values,f=p.shape[p.shape.length-1],m=o?(y,b)=>y+f-b-1:(y,b)=>y+b;for(let y=0;y<c.length;y+=f)for(let b=0;b<f;b++){let x=m(y,b);if(b===0)h[x]=i?1:c[x];else{let v=m(y,b-1);h[x]=i?c[v]*h[v]:c[x]*h[v]}}let g=n.makeTensorInfo(p.shape,d,h);if(l!=null){let y=N.getUndoAxesPermutation(l),b=$n({inputs:{x:g},backend:n,attrs:{perm:y}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(p),b}return g}var Iq={kernelName:kl,backendName:"cpu",kernelFunc:kq};function Sq(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;ye(a,"cumsum");let l=N.getAxesPermutation([s],a.shape.length),p=a;l!=null&&(p=$n({inputs:{x:a},backend:n,attrs:{perm:l}}));let u=N.getInnerMostAxes(1,a.shape.length)[0];if(u!==p.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${p.shape.length-1} but got axis=${u}`);let d=tr(p.dtype,"int32"),h=w.makeZerosTypedArray(w.sizeFromShape(p.shape),d),c=n.data.get(p.dataId).values,f=p.shape[p.shape.length-1],m=o?(y,b)=>y+f-b-1:(y,b)=>y+b;for(let y=0;y<c.length;y+=f)for(let b=0;b<f;b++){let x=m(y,b);if(b===0)h[x]=i?0:c[x];else{let v=m(y,b-1);h[x]=i?c[v]+h[v]:c[x]+h[v]}}let g=n.makeTensorInfo(p.shape,d,h);if(l!=null){let y=N.getUndoAxesPermutation(l),b=$n({inputs:{x:g},backend:n,attrs:{perm:y}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(p),b}return g}var Nq={kernelName:gi,backendName:"cpu",kernelFunc:Sq};function Tq(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i,binaryOutput:o}=r;if(a.shape.length===1){let l=n.data.get(a.dataId).values,p=n.data.get(s.dataId).values,u=mx(l,p,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,u)}else if(a.shape.length===2){let l=n.bufferSync(a),p=n.bufferSync(s),u=IN(l,p,i,o);return n.makeTensorInfo(u.shape,s.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}var Cq={kernelName:Cp,backendName:"cpu",kernelFunc:Tq};function _q(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:s,dataFormat:i}=r;w.assert(i==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);let o=a.shape[0],l=a.shape[1],p=a.shape[2],u=a.shape[3],d=l*s,h=p*s,c=u/(s*s),f=n.data.get(a.dataId).values,m=new Float32Array(o*d*h*c),g=0;for(let y=0;y<o;++y)for(let b=0;b<d;++b){let x=Math.floor(b/s),v=b%s;for(let I=0;I<h;++I){let T=Math.floor(I/s),_=I%s,E=(v*s+_)*c;for(let A=0;A<c;++A){let R=A+E+u*(T+p*(x+l*y));m[g++]=f[R]}}}return n.makeTensorInfo([o,d,h,c],a.dtype,m)}var Eq={kernelName:Sl,backendName:"cpu",kernelFunc:_q};function g2(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:p}=r;ye([a,s],"depthwiseConv2DNative");let u=w.computeStrides(a.shape),d=w.computeStrides(s.shape),h=l;h==null&&(h=[1,1]),w.assert(N.eitherStridesOrDilationsAreOne(i,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`);let c=N.computeConv2DInfo(a.shape,s.shape,i,h,o,p,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=c,x=b.left,v=b.top,I=c.outChannels/c.inChannels,T=new $t(c.outShape,a.dtype),_=n.data.get(a.dataId).values,E=n.data.get(s.dataId).values,A=T.values;for(let R=0;R<c.batchSize;++R){let F=R*u[0],S=R*T.strides[0];for(let M=0;M<c.outHeight;++M){let W=S+M*T.strides[1],U=M*c.strideHeight-v;for(let H=0;H<f;++H){let K=U+H*g;if(K<0||K>=c.inHeight)continue;let j=H*d[0],Z=F+K*u[1];for(let ee=0;ee<c.outWidth;++ee){let Y=W+ee*T.strides[2],re=ee*c.strideWidth-x;for(let te=0;te<m;++te){let ae=re+te*y;if(ae<0||ae>=c.inWidth)continue;let ie=j+te*d[1],ve=Z+ae*c.inChannels,be=Y,he=ie;for(let Ie=0;Ie<c.inChannels;++Ie){let Te=_[ve+Ie];for(let Re=0;Re<I;++Re)A[be+Re]+=Te*E[he+Re];be+=I,he+=I}}}}}}return n.makeTensorInfo(T.shape,T.dtype,T.values)}var $q={kernelName:yi,backendName:"cpu",kernelFunc:g2};function Aq(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:p,filterShape:u}=r;ye([a,s],"depthwiseConv2dNativeBackpropFilter");let d=N.computeConv2DInfo(a.shape,u,i,o,l,p,!0),{strideHeight:h,strideWidth:c,filterHeight:f,filterWidth:m}=d,g=new $t(d.filterShape,"float32"),y=d.padInfo.left,b=d.padInfo.top,x=d.outChannels/d.inChannels,v=n.data.get(a.dataId).values,I=new $t(a.shape,a.dtype,v),T=n.data.get(s.dataId).values,_=new $t(s.shape,s.dtype,T);for(let E=0;E<f;++E){let A=Math.max(0,Math.ceil((b-E)/h)),R=Math.min(d.outHeight,(d.inHeight+b-E)/h);for(let F=0;F<m;++F){let S=Math.max(0,Math.ceil((y-F)/c)),M=Math.min(d.outWidth,(d.inWidth+y-F)/c);for(let W=0;W<d.outChannels;++W){let U=Math.trunc(W/x),H=W%x,K=0;for(let j=0;j<d.batchSize;++j)for(let Z=A;Z<R;++Z){let ee=E+Z*h-b;for(let Y=S;Y<M;++Y){let re=F+Y*c-y;K+=I.get(j,ee,re,U)*_.get(j,Z,Y,W)}}g.set(K,E,F,U,H)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}var Fq={kernelName:Jh,backendName:"cpu",kernelFunc:Aq};function Rq(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:p,inputShape:u}=r;ye([a,s],"depthwiseConv2DNativeBackpropInput");let d=w.computeStrides(a.shape),h=w.computeStrides(s.shape),c=N.computeConv2DInfo(u,s.shape,i,o,l,p,!0),f=new $t(c.inShape,"float32"),m=f.values,[g,y,b]=f.strides,x=n.data.get(a.dataId).values,[v,I,T]=d,_=n.data.get(s.dataId).values,[E,A,R]=h,{batchSize:F,filterHeight:S,filterWidth:M,inChannels:W,inHeight:U,inWidth:H,outChannels:K,outHeight:j,outWidth:Z,strideHeight:ee,strideWidth:Y}=c,re=S-1-c.padInfo.top,te=M-1-c.padInfo.left,ae=K/W;for(let ie=0;ie<F;++ie)for(let ve=0;ve<W;++ve)for(let be=0;be<U;++be){let he=be-re,Ie=Math.max(0,Math.ceil(he/ee)),Te=Math.min(j,(S+he)/ee);for(let Re=0;Re<H;++Re){let Pe=Re-te,rt=Math.max(0,Math.ceil(Pe/Y)),Ge=Math.min(Z,(M+Pe)/Y),qe=0;for(let $e=Ie;$e<Te;++$e){let Je=$e*ee-he;for(let pt=rt;pt<Ge;++pt){let Fn=pt*Y-Pe,It=v*ie+I*$e+T*pt,wn=E*(S-1-Je)+A*(M-1-Fn)+R*ve;for(let Jt=0;Jt<ae;++Jt){let kn=ve*ae+Jt,sr=x[It+kn],Rn=_[wn+Jt];qe+=sr*Rn}}}m[g*ie+y*be+b*Re+ve]=qe}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}var Dq={kernelName:Yh,backendName:"cpu",kernelFunc:Rq};function Mq(e){let{inputs:t,backend:n}=e,{x:r}=t,a=w.sizeFromShape(r.shape),s=n.data.get(r.dataId).values,i=ze([a,a],r.dtype),o=i.values;for(let p=0;p<s.length;p++)o[p*a+p]=s[p];let l=[...r.shape,...r.shape];return n.makeTensorInfo(l,i.dtype,i.values)}var Oq={kernelName:_p,backendName:"cpu",kernelFunc:Mq},Lq={kernelName:bi,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:a}=e,{strides:s,pad:i,dilations:o}=n,l=t,p=l.data.get(r.dataId).values,u=r.shape.length,d=l.data.get(a.dataId).values,h=a.shape.length,{batchSize:c,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:x,strideHeight:v,strideWidth:I,filterHeight:T,filterWidth:_,dilationHeight:E,dilationWidth:A,outShape:R}=N.computeDilation2DInfo(r.shape,a.shape,s,i,"NHWC",o),F=w.sizeFromShape(R),S=R.length,M=w.getArrayFromDType(r.dtype,F);for(let W=0;W<c;++W)for(let U=0;U<y;++U){let H=U*v-x.top;for(let K=0;K<b;++K){let j=K*I-x.left;for(let Z=0;Z<g;++Z){let ee=Number.MIN_SAFE_INTEGER;for(let re=0;re<T;++re){let te=H+re*E;if(te>=0&&te<f)for(let ae=0;ae<_;++ae){let ie=j+ae*A;if(ie>=0&&ie<m){let ve=w.locToIndex([W,te,ie,Z],u,w.computeStrides(r.shape)),be=w.locToIndex([re,ae,Z],h,w.computeStrides(a.shape)),he=p[ve]+d[be];he>ee&&(ee=he)}}}let Y=w.locToIndex([W,U,K,Z],S,w.computeStrides(R));M[Y]=ee}}}return{dataId:l.write(w.toTypedArray(M,r.dtype),R,r.dtype),shape:R,dtype:r.dtype}}},zq={kernelName:qo,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:a,dy:s}=e,{strides:i,pad:o,dilations:l}=n,p=t,u=w.toNestedArray(r.shape,p.data.get(r.dataId).values),d=w.toNestedArray(a.shape,p.data.get(a.dataId).values),{batchSize:h,inHeight:c,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:x,strideWidth:v,filterHeight:I,filterWidth:T,dilationHeight:_,dilationWidth:E,outShape:A}=N.computeDilation2DInfo(r.shape,a.shape,i,o,"NHWC",l);w.assert(s.rank===A.length,()=>`Error in ${qo}, dy must have the same rank as output ${A.length}, but got ${s.rank}`);let R=w.toNestedArray(A,p.data.get(s.dataId).values),F=w.makeZerosNestedTypedArray(a.shape,a.dtype);for(let S=0;S<h;++S)for(let M=0;M<g;++M){let W=M*x-b.top;for(let U=0;U<y;++U){let H=U*v-b.left;for(let K=0;K<m;++K){let j=Number.MIN_SAFE_INTEGER,Z=0,ee=0;for(let Y=0;Y<I;++Y){let re=W+Y*_;if(re>=0&&re<c)for(let te=0;te<T;++te){let ae=H+te*E;if(ae>=0&&ae<f){let ie=u[S][re][ae][K]+d[Y][te][K];ie>j&&(j=ie,Z=Y,ee=te)}}}F[Z][ee][K]+=R[S][M][U][K]}}}return{dataId:p.write(w.toTypedArray(F,r.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},Pq={kernelName:jo,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:a,dy:s}=e,{strides:i,pad:o,dilations:l}=n,p=t,u=w.toNestedArray(r.shape,p.data.get(r.dataId).values),d=w.toNestedArray(a.shape,p.data.get(a.dataId).values),{batchSize:h,inHeight:c,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:x,strideWidth:v,filterHeight:I,filterWidth:T,dilationHeight:_,dilationWidth:E,outShape:A}=N.computeDilation2DInfo(r.shape,a.shape,i,o,"NHWC",l);w.assert(s.rank===A.length,()=>`Error in ${jo}, dy must have the same rank as output ${A.length}, but got ${s.rank}`);let R=w.toNestedArray(A,p.data.get(s.dataId).values),F=w.makeZerosNestedTypedArray(r.shape,r.dtype);for(let S=0;S<h;++S)for(let M=0;M<g;++M){let W=M*x-b.top;for(let U=0;U<y;++U){let H=U*v-b.left;for(let K=0;K<m;++K){let j=Number.MIN_SAFE_INTEGER,Z=W<0?0:W,ee=H<0?0:H;for(let Y=0;Y<I;++Y){let re=W+Y*_;if(re>=0&&re<c)for(let te=0;te<T;++te){let ae=H+te*E;if(ae>=0&&ae<f){let ie=u[S][re][ae][K]+d[Y][te][K];ie>j&&(j=ie,Z=re,ee=ae)}}}F[S][Z][ee][K]+=R[S][M][U][K]}}}return{dataId:p.write(w.toTypedArray(F,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function Bq(e){let{inputs:t,backend:n,attrs:r}=e,{image:a}=t,{canvas:s,options:i}=r,{contextOptions:o,imageOptions:l}=i||{},p=(l==null?void 0:l.alpha)||1,u=(o==null?void 0:o.contextType)||"2d";if(u!=="2d")throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);let d=s.getContext(u,(o==null?void 0:o.contextAttributes)||{});if(d==null)throw new Error(`Could not get the context with ${u} type.`);let[h,c]=a.shape.slice(0,2),f=a.shape.length===2?1:a.shape[2],m=n.data.get(a.dataId).values,g=a.dtype==="float32"?255:1,y=new Uint8ClampedArray(c*h*4);for(let x=0;x<h*c;++x){let v=[0,0,0,255*p];for(let T=0;T<f;T++){let _=m[x*f+T];if(a.dtype==="float32"){if(_<0||_>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${_}.`)}else if(a.dtype==="int32"&&(_<0||_>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${_}.`);f===1?(v[0]=_*g,v[1]=_*g,v[2]=_*g):v[T]=_*g}let I=x*4;y[I+0]=Math.round(v[0]),y[I+1]=Math.round(v[1]),y[I+2]=Math.round(v[2]),y[I+3]=Math.round(v[3])}s.width=c,s.height=h;let b=new ImageData(y,c,h);return d.putImageData(b,0,0),a}var Wq={kernelName:Qh,backendName:"cpu",kernelFunc:Bq};function bd(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;ye(a,"sum");let o;a.dtype==="bool"?o=Ka({inputs:{x:a},backend:n,attrs:{dtype:"int32"}}):o=jr({inputs:{x:a},backend:n});let l=o.shape.length,p=w.parseAxisParam(s,o.shape),u=N.getAxesPermutation(p,l),d=p,h=o;u!=null&&(h=$n({inputs:{x:o},backend:n,attrs:{perm:u}}),d=N.getInnerMostAxes(d.length,l)),N.assertAxesAreInnerMostDims("sum",d,h.shape.length);let[c,f]=N.computeOutAndReduceShapes(h.shape,d),m=N.upcastType(h.dtype,"int32"),g=Fh(n,c,m),y=w.sizeFromShape(f),b=n.data.get(g.dataId).values,x=n.data.get(h.dataId).values;for(let v=0;v<b.length;++v){let I=v*y,T=0;for(let _=0;_<y;++_)T+=x[I+_];b[v]=T}if(i){let v=N.expandShapeToKeepDim(g.shape,p),I=g;g=ft({inputs:{x:g},backend:n,attrs:{shape:v}}),n.disposeIntermediateTensorInfo(I)}return n.disposeIntermediateTensorInfo(o),u!=null&&n.disposeIntermediateTensorInfo(h),g}var Vq={kernelName:ho,backendName:"cpu",kernelFunc:bd};function Uq(e){let{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,s=t,{allDims:i,summedDims:o,idDims:l}=N.decodeEinsumEquation(a,s.length);N.checkEinsumDimSizes(i.length,l,s);let{path:p,steps:u}=N.getEinsumComputePath(o,l),d=u.length,h=null,c=i.length,f=[];for(let m=0;m<d;++m){for(let g of u[m]){let{permutationIndices:y,expandDims:b}=N.getEinsumPermutation(c,l[g]),x;N.isIdentityPermutation(y)?x=s[g]:(x=$n({inputs:{x:s[g]},backend:n,attrs:{perm:y}}),f.push(x));let v=x.shape.slice();for(let I=0;I<b.length;++I)v.splice(b[I],0,1);w.arraysEqual(x.shape,v)||(x=ft({inputs:{x},backend:n,attrs:{shape:v}}),f.push(x)),h===null?h=x:(h=ff({inputs:{a:x,b:h},backend:n}),f.push(h))}m<d-1&&(p[m]>=0&&(h=bd({inputs:{x:h},backend:n,attrs:{axis:p[m]-(i.length-c),keepDims:!1}}),f.push(h)),c--)}for(let m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}var Gq={kernelName:ec,backendName:"cpu",kernelFunc:Uq};function Hq(e){let{inputs:t,backend:n}=e,{dy:r,y:a}=t;ye([r,a],"eluGrad");let s=new Float32Array(w.sizeFromShape(a.shape)),i=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values;for(let l=0;l<i.length;++l){let p=i[l];p>=0?s[l]=o[l]:s[l]=o[l]*(p+1)}return n.makeTensorInfo(a.shape,"float32",s)}var jq={kernelName:Nl,backendName:"cpu",kernelFunc:Hq},qq=N.ERF_P,Kq=N.ERF_A1,Xq=N.ERF_A2,Zq=N.ERF_A3,Jq=N.ERF_A4,Yq=N.ERF_A5,Qq=nt(wi,e=>{let t=Math.sign(e),n=Math.abs(e),r=1/(1+qq*n);return t*(1-((((Yq*r+Jq)*r+Zq)*r+Xq)*r+Kq)*r*Math.exp(-n*n))}),e5={kernelName:wi,backendName:"cpu",kernelFunc:Qq};function Mh(e){let{inputs:t,backend:n,attrs:r}=e,{input:a}=t,{dim:s}=r,i=a.shape.length,o=a.shape.slice(),l=s;return s<0&&(w.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),o.splice(l,0,1),ft({inputs:{x:a},backend:n,attrs:{shape:o}})}var t5={kernelName:Cl,backendName:"cpu",kernelFunc:Mh},n5=Tt((e,t)=>e/t),Cx=Bt(xi,n5),Om={kernelName:xi,backendName:"cpu",kernelFunc:Cx};function y2(e,t,n){let r=e.shape,a=r[0],s=r[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,p=[a,s],u=w.sizeFromShape(p),d=w.getTypedArrayFromDType("float32",u),h=w.getTypedArrayFromDType("float32",u);for(let g=0;g<a;g++){let y=js({inputs:{x:o},backend:n,attrs:{begin:[g,0],size:[1,s]}}),b=js({inputs:{x:l},backend:n,attrs:{begin:[g,0],size:[1,s]}}),x=zn({inputs:{real:y,imag:b},backend:n}),{real:v,imag:I}=r5(x,t,n),T=N.mergeRealAndImagArrays(v,I);for(let _=0;_<s;_++){let E=N.getComplexWithIndex(T,_);d[g*s+_]=E.real,h[g*s+_]=E.imag}n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(x)}let c=n.makeTensorInfo(p,"float32",d),f=n.makeTensorInfo(p,"float32",h),m=zn({inputs:{real:c,imag:f},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(f),m}function r5(e,t,n){let r=w.sizeFromShape(e.shape),a=n.data.get(e.dataId),s=n.data.get(a.complexTensorInfos.real.dataId).values,i=n.data.get(a.complexTensorInfos.imag.dataId).values;if(a5(r)){let o=Lm(s,i,r,t,n),l=[e.shape[0],e.shape[1]];if(t){let p=n.makeTensorInfo(l,"float32",o.real),u=n.makeTensorInfo(l,"float32",o.imag),d=n.makeTensorInfo([],"float32",w.createScalarValue(r,"float32")),h=jr({inputs:{x:d},backend:n}),c=Om.kernelFunc({inputs:{a:p,b:d},backend:n}),f=Om.kernelFunc({inputs:{a:u,b:h},backend:n}),m=n.data.get(c.dataId).values,g=n.data.get(f.dataId).values;return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(f),{real:m,imag:g}}return o}else{let o=N.mergeRealAndImagArrays(s,i),l=s5(o,r,t);return N.splitRealAndImagArrays(l)}}function a5(e){return(e&e-1)===0}function Lm(e,t,n,r,a){if(n===1)return{real:e,imag:t};let s=N.mergeRealAndImagArrays(e,t),i=n/2,o=N.complexWithEvenIndex(s),l=o.real,p=o.imag,u=[l.length],d=a.makeTensorInfo(u,"float32",l),h=a.makeTensorInfo(u,"float32",p),c=zn({inputs:{real:d,imag:h},backend:a}),f=N.complexWithOddIndex(s),m=f.real,g=f.imag,y=[m.length],b=a.makeTensorInfo(y,"float32",m),x=a.makeTensorInfo(y,"float32",g),v=zn({inputs:{real:b,imag:x},backend:a}),I=Lm(l,p,i,r,a),T=I.real,_=I.imag,E=[T.length],A=a.makeTensorInfo(E,"float32",T),R=a.makeTensorInfo(E,"float32",_),F=zn({inputs:{real:A,imag:R},backend:a}),S=Lm(m,g,i,r,a),M=S.real,W=S.imag,U=[M.length],H=a.makeTensorInfo(U,"float32",M),K=a.makeTensorInfo(U,"float32",W),j=zn({inputs:{real:H,imag:K},backend:a}),Z=N.exponents(n,r),ee=[Z.real.length],Y=a.makeTensorInfo(ee,"float32",Z.real),re=a.makeTensorInfo(ee,"float32",Z.imag),te=zn({inputs:{real:Y,imag:re},backend:a}),ae=ff({inputs:{a:te,b:j},backend:a}),ie=sl({inputs:{a:F,b:ae},backend:a}),ve=Sx({inputs:{a:F,b:ae},backend:a}),be=Hs({inputs:{input:ie},backend:a}),he=Hs({inputs:{input:ve},backend:a}),Ie=il({inputs:{input:ie},backend:a}),Te=il({inputs:{input:ve},backend:a}),Re=ol({inputs:[be,he],backend:a,attrs:{axis:0}}),Pe=ol({inputs:[Ie,Te],backend:a,attrs:{axis:0}}),rt=a.data.get(Re.dataId).values,Ge=a.data.get(Pe.dataId).values;return a.disposeIntermediateTensorInfo(d),a.disposeIntermediateTensorInfo(h),a.disposeIntermediateTensorInfo(c),a.disposeIntermediateTensorInfo(b),a.disposeIntermediateTensorInfo(x),a.disposeIntermediateTensorInfo(v),a.disposeIntermediateTensorInfo(A),a.disposeIntermediateTensorInfo(R),a.disposeIntermediateTensorInfo(F),a.disposeIntermediateTensorInfo(H),a.disposeIntermediateTensorInfo(K),a.disposeIntermediateTensorInfo(j),a.disposeIntermediateTensorInfo(Y),a.disposeIntermediateTensorInfo(re),a.disposeIntermediateTensorInfo(te),a.disposeIntermediateTensorInfo(ae),a.disposeIntermediateTensorInfo(ie),a.disposeIntermediateTensorInfo(ve),a.disposeIntermediateTensorInfo(be),a.disposeIntermediateTensorInfo(Ie),a.disposeIntermediateTensorInfo(he),a.disposeIntermediateTensorInfo(Te),a.disposeIntermediateTensorInfo(Re),a.disposeIntermediateTensorInfo(Pe),{real:rt,imag:Ge}}function s5(e,t,n){let r=new Float32Array(t*2);for(let a=0;a<t;a++){let s=0,i=0;for(let o=0;o<t;o++){let l=N.exponent(a*o,t,n),p=N.getComplexWithIndex(e,o);s+=p.real*l.real-p.imag*l.imag,i+=p.real*l.imag+p.imag*l.real}n&&(s/=t,i/=t),N.assignToTypedArray(r,s,i,a)}return r}function i5(e){let{inputs:t,backend:n}=e,{input:r}=t,a=w.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=a/s,o=ft({inputs:{x:r},backend:n,attrs:{shape:[i,s]}}),l=y2(o,!1,n),p=ft({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),p}var o5={kernelName:tc,backendName:"cpu",kernelFunc:i5};function _x(e){let{backend:t,attrs:n}=e,{shape:r,value:a,dtype:s}=n,i=s||w.inferDtype(a),o=w.getArrayFromDType(i,w.sizeFromShape(r));return u5(o,a),t.makeTensorInfo(r,i,o)}var l5={kernelName:Ep,backendName:"cpu",kernelFunc:_x};function u5(e,t,n){e.fill(t)}var p5={kernelName:_l,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,a=n,s=w.getTypedArrayFromDType(r.dtype,w.sizeFromShape(r.shape)),[i,o,l,p]=r.shape,u=a.data.get(r.dataId).values;for(let d=0;d<i;d++){let h=d*l*o*p;for(let c=0;c<o;c++){let f=c*(l*p);for(let m=0;m<l;m++){let g=m*p;for(let y=0;y<p;y++){let b=Math.round(l-m-1),x=h+f+g+y,v=u[x];if(b>=0&&b<l){let I=b*p,T=h+f+I+y;v=u[T]}s[x]=v}}}}return{dataId:a.write(s,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function d5(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:p,dataFormat:u,dilations:d,dimRoundingMode:h,activation:c,leakyreluAlpha:f}=r,m=m2({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:p,dataFormat:u,dilations:d,dimRoundingMode:h}});if(i){let g=m;if(u==="NCHW"&&i.shape.length===1&&i.shape[0]!==1){let y=ft({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=sl({inputs:{a:m,b:y},backend:n}),n.disposeIntermediateTensorInfo(y)}else m=sl({inputs:{a:m,b:i},backend:n});n.disposeIntermediateTensorInfo(g)}if(c){let g=m;if(u==="NCHW"&&c==="prelu"&&o.shape.length===1&&o.shape[0]!==1){let y=ft({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=Dh(n,m,c,y,f),n.disposeIntermediateTensorInfo(y)}else m=Dh(n,m,c,o,f);n.disposeIntermediateTensorInfo(g)}return m}var h5={kernelName:Rs,backendName:"cpu",kernelFunc:d5};function c5(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:p,dataFormat:u,dilations:d,dimRoundingMode:h,activation:c,leakyreluAlpha:f}=r,m=g2({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:p,dataFormat:u,dilations:d,dimRoundingMode:h}});if(i){let g=m;m=sl({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(g)}if(c){let g=m;m=Dh(n,m,c,o,f),n.disposeIntermediateTensorInfo(g)}return m}var f5={kernelName:Ds,backendName:"cpu",kernelFunc:c5};function m5(e){let{inputs:t,backend:n}=e,{params:r,indices:a}=t,s=w.sizeFromShape(r.shape),i=a.shape,o=i[i.length-1],[l,p,u,d]=N.prepareAndValidate(r,a);if(p===0)return n.makeTensorInfo(l,r.dtype,[]);let h=n.data.get(a.dataId).values,c=n.bufferSync(r),f=RN(h,c,r.dtype,p,o,u,d,r.shape,s);return n.makeTensorInfo(l,r.dtype,f.values)}var g5={kernelName:$l,backendName:"cpu",kernelFunc:m5};function y5(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,indices:s}=t,{axis:i,batchDims:o}=r;ye([a,s],"gatherV2");let l=w.parseAxisParam(i,a.shape)[0],p=n.data.get(s.dataId).values,u=a.shape[l];for(let v=0;v<p.length;++v){let I=p[v];w.assert(I<=u-1&&I>=0,()=>`GatherV2: the index value ${I} is not in [0, ${u-1}]`)}let d=o;o==null&&(d=0);let h=w.sizeFromShape(s.shape),c=N.segment_util.collectGatherOpShapeInfo(a,s,l,d),f=ft({inputs:{x:a},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),m=ft({inputs:{x:s},backend:n,attrs:{shape:[c.batchSize,h/c.batchSize]}}),g=[c.batchSize,c.outerSize,h/c.batchSize,c.sliceSize],y=n.bufferSync(m),b=n.bufferSync(f),x=DN(b,y,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(c.outputShape,x.dtype,x.values)}var b5={kernelName:El,backendName:"cpu",kernelFunc:y5};function x5(e){let{inputs:t,backend:n}=e,{input:r}=t,a=w.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=a/s,o=ft({inputs:{x:r},backend:n,attrs:{shape:[i,s]}}),l=y2(o,!0,n),p=ft({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),p}var v5={kernelName:nc,backendName:"cpu",kernelFunc:x5},w5=nt(Ei,e=>Number.isFinite(e)?1:0,"bool"),k5={kernelName:Ei,backendName:"cpu",kernelFunc:w5},I5=nt($i,e=>Math.abs(e)===1/0?1:0,"bool"),S5={kernelName:$i,backendName:"cpu",kernelFunc:I5},N5=nt(Ai,e=>Number.isNaN(e)?1:0,"bool"),T5={kernelName:Ai,backendName:"cpu",kernelFunc:N5};function C5(e){let{backend:t,attrs:n}=e,{start:r,stop:a,num:s}=n,i=PN(r,a,s);return t.makeTensorInfo([i.length],"float32",i)}var _5={kernelName:Dl,backendName:"cpu",kernelFunc:C5},E5=nt(Di,e=>Math.log1p(e)),$5={kernelName:Di,backendName:"cpu",kernelFunc:E5},A5=Tt((e,t)=>e&&t),F5=Bt(Ml,A5,null,"bool"),R5={kernelName:Ml,backendName:"cpu",kernelFunc:F5},D5=nt(Ol,e=>e?0:1,"bool"),M5={kernelName:Ol,backendName:"cpu",kernelFunc:D5},O5=Tt((e,t)=>e||t),L5=Bt(Ll,O5,null,"bool"),z5={kernelName:Ll,backendName:"cpu",kernelFunc:L5};function P5(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r;ye(a,"LRN");let p=a.shape[3],u=p-1,d=n.data.get(a.dataId).values,h=w.sizeFromShape(a.shape),c=new Float32Array(h);function f(m){let g=m%p,y=m-g+Math.max(0,g-s),b=m-g+Math.min(g+s,u),x=0;for(;y<=b;y++){let v=d[y];x+=v*v}return x}for(let m=0;m<h;m++){let g=f(m),y=d[m]*Math.pow(i+o*g,-l);c[m]=y}return n.makeTensorInfo(a.shape,a.dtype,c)}var B5={kernelName:Mi,backendName:"cpu",kernelFunc:P5};function W5(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:p,beta:u}=r;ye(i,"LRNGrad");let d=w.sizeFromShape(i.shape),h=i.shape[3],c=n.data.get(i.dataId).values,f=n.data.get(a.dataId).values,m=n.data.get(s.dataId).values,g=new Float32Array(d),y=d;for(let b=0;b<y;b++){let x=b%h,v=b-x+Math.max(0,x-o),I=b-x+Math.min(h,x+o+1),T=0;for(let _=v;_<I;_++)T+=Math.pow(f[_],2);T=p*T+l;for(let _=v;_<I;_++){let E=-2*p*u*f[_]*m[b]/T;b===_&&(E+=Math.pow(T,-u)),E*=c[b],g[_]+=E}}return n.makeTensorInfo(i.shape,a.dtype,g)}var V5={kernelName:zl,backendName:"cpu",kernelFunc:W5};function b2(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:s,keepDims:i}=r,o=n,l=a.shape,p=l.length,u=w.parseAxisParam(s,l),d=u,h=N.getAxesPermutation(d,p),c=o.data.get(a.dataId).values;if(h!=null){let v=new Array(p);for(let I=0;I<v.length;I++)v[I]=l[h[I]];c=bx(c,l,a.dtype,h,v),d=N.getInnerMostAxes(d.length,p),l=v}ye(a,"max"),N.assertAxesAreInnerMostDims("max",d,p);let[f,m]=N.computeOutAndReduceShapes(l,d),g=w.sizeFromShape(m),y=WN(c,g,f,a.dtype),b=o.write(y,f,a.dtype),x=f;return i&&(x=N.expandShapeToKeepDim(f,u)),{dataId:b,shape:x,dtype:a.dtype}}var U5={kernelName:Oi,backendName:"cpu",kernelFunc:b2};function G5(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;ye(a,"maxPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r,p=1;w.assert(N.eitherStridesOrDilationsAreOne(i,p),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${p}'`);let u=N.computePool2DInfo(a.shape,s,i,p,o,l),d;if(u.filterWidth===1&&u.filterHeight===1&&w.arraysEqual(u.inShape,u.outShape))d=jr({inputs:{x:a},backend:n});else{let h=n.data.get(a.dataId).values,c=w.computeStrides(a.shape),f=Tx(h,a.shape,a.dtype,c,u,"max");d=n.makeTensorInfo(u.outShape,a.dtype,f.values)}return d}var H5={kernelName:zi,backendName:"cpu",kernelFunc:G5};function j5(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:p}=r;ye(a,"maxPool3d");let u=N.computePool3DInfo(a.shape,s,i,1,o,l,p),d=n.data.get(a.dataId).values,h=f2(d,a.shape,a.dtype,w.computeStrides(a.shape),u,"max");return n.makeTensorInfo(h.shape,"float32",h.values)}var q5={kernelName:Pl,backendName:"cpu",kernelFunc:j5};function K5(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:p}=r;ye([a,s],"maxPool3DGrad");let u=N.computePool3DInfo(s.shape,i,o,1,l,p),d=n.bufferSync(s),h=Oj(d,u),c=u.strideDepth,f=u.strideHeight,m=u.strideWidth,g=u.dilationDepth,y=u.dilationHeight,b=u.dilationWidth,x=u.effectiveFilterDepth,v=u.effectiveFilterHeight,I=u.effectiveFilterWidth,T=x-1-u.padInfo.front,_=I-1-u.padInfo.left,E=v-1-u.padInfo.top,A=ze(s.shape,"float32"),R=n.bufferSync(a);for(let F=0;F<u.batchSize;++F)for(let S=0;S<u.inChannels;++S)for(let M=0;M<u.inDepth;++M)for(let W=0;W<u.inHeight;++W)for(let U=0;U<u.inWidth;++U){let H=M-T,K=W-E,j=U-_,Z=0;for(let ee=0;ee<x;ee+=g){let Y=(H+ee)/c;if(!(Y<0||Y>=u.outDepth||Math.floor(Y)!==Y))for(let re=0;re<v;re+=y){let te=(K+re)/f;if(!(te<0||te>=u.outHeight||Math.floor(te)!==te))for(let ae=0;ae<I;ae+=b){let ie=(j+ae)/m;if(ie<0||ie>=u.outWidth||Math.floor(ie)!==ie)continue;let ve=x*v*I-1-h.get(F,Y,te,ie,S),be=ee*v*I+re*I+ae,he=ve===be?1:0;if(he===0)continue;let Ie=R.get(F,Y,te,ie,S);Z+=Ie*he}}}A.set(Z,F,M,W,U,S)}return n.makeTensorInfo(A.shape,A.dtype,A.values)}var X5={kernelName:Ap,backendName:"cpu",kernelFunc:K5};function Z5(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s,output:i}=t,o=s;ye([s,i],"maxPoolGrad");let{filterSize:l,strides:p,pad:u,dimRoundingMode:d}=r,h=N.computePool2DInfo(o.shape,l,p,1,u,d),c=n.data.get(o.dataId).values,f=ze(h.outShape,o.dtype,c2(c,o.shape,o.dtype,h).values),m=h.strideHeight,g=h.strideWidth,y=h.dilationHeight,b=h.dilationWidth,x=h.effectiveFilterHeight,v=h.effectiveFilterWidth,I=v-1-h.padInfo.left,T=x-1-h.padInfo.top,_=ze(o.shape,"float32"),E=n.data.get(a.dataId).values,A=ze(a.shape,"float32",E);for(let R=0;R<h.batchSize;++R)for(let F=0;F<h.inChannels;++F)for(let S=0;S<h.inHeight;++S)for(let M=0;M<h.inWidth;++M){let W=S-T,U=M-I,H=0;for(let K=0;K<x;K+=y){let j=(W+K)/m;if(!(j<0||j>=h.outHeight||Math.floor(j)!==j))for(let Z=0;Z<v;Z+=b){let ee=(U+Z)/g;if(ee<0||ee>=h.outWidth||Math.floor(ee)!==ee)continue;let Y=x*v-1-f.get(R,j,ee,F),re=K*v+Z,te=Y===re?1:0;if(te===0)continue;let ae=A.get(R,j,ee,F);H+=ae*te}}_.set(H,R,S,M,F)}return n.makeTensorInfo(_.shape,_.dtype,_.values)}var J5={kernelName:$p,backendName:"cpu",kernelFunc:Z5};function Y5(e,t,n,r,a){let s=w.computeStrides(t),i=Tx(e,t,n,s,a,"max"),o=c2(e,t,n,a,!0,r);return[i.values,o.values]}var Q5={kernelName:Fp,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{filterSize:a,strides:s,pad:i,includeBatchInIndex:o}=t,l=n;ye(r,"MaxPoolWithArgmax");let p=l.data.get(r.dataId).values,u=N.computePool2DInfo(r.shape,a,s,[1,1],i),[d,h]=Y5(p,r.shape,r.dtype,o,u),c=l.write(d,u.outShape,r.dtype),f=l.write(h,u.outShape,r.dtype);return[{dataId:c,shape:u.outShape,dtype:r.dtype},{dataId:f,shape:u.outShape,dtype:"int32"}]}};function eK(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=w.parseAxisParam(s,a.shape),l=N.computeOutAndReduceShapes(a.shape,o)[1],p=w.sizeFromShape(l),u=[],d=n.makeTensorInfo([],"float32",new Float32Array([p]));u.push(d);let h=Ka({inputs:{x:a},backend:n,attrs:{dtype:"float32"}});u.push(h);let c=Cx({inputs:{a:h,b:d},backend:n});u.push(c);let f=bd({inputs:{x:c},backend:n,attrs:{axis:s,keepDims:i}});return u.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}var tK={kernelName:Pi,backendName:"cpu",kernelFunc:eK};function nK(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;ye(a,"min");let o=w.parseAxisParam(s,a.shape),l=o,p=N.getAxesPermutation(l,a.shape.length),u=a;p!=null&&(u=$n({inputs:{x:a},backend:n,attrs:{perm:p}}),l=N.getInnerMostAxes(l.length,a.shape.length)),N.assertAxesAreInnerMostDims("min",l,u.shape.length);let[d,h]=N.computeOutAndReduceShapes(u.shape,l),c=w.sizeFromShape(h),f=w.makeZerosTypedArray(w.sizeFromShape(d),u.dtype),m=n.data.get(u.dataId).values;for(let y=0;y<f.length;++y){let b=y*c,x=m[b];for(let v=0;v<c;++v){let I=m[b+v];(Number.isNaN(I)||I<x)&&(x=I)}f[y]=x}p!=null&&n.disposeIntermediateTensorInfo(u);let g=n.makeTensorInfo(d,u.dtype,f);if(i){let y=N.expandShapeToKeepDim(d,o),b=ft({inputs:{x:g},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(g),b}return g}var rK={kernelName:Bi,backendName:"cpu",kernelFunc:nK};function aK(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,mode:i}=r;ye(a,"mirrorPad");let o=s.map((b,x)=>b[0]+a.shape[x]+b[1]),l=s.map(b=>b[0]),p=s.map((b,x)=>b[0]+a.shape[x]),u=i==="reflect"?0:1,d=n.data.get(a.dataId).values,h=a.shape.length,c=w.computeStrides(a.shape),f=w.sizeFromShape(o),m=o.length,g=w.computeStrides(o),y=w.getTypedArrayFromDType(a.dtype,f);for(let b=0;b<f;b++){let x=w.indexToLoc(b,m,g);for(let I=0;I<m;I++)x[I]<l[I]?x[I]=l[I]*2-x[I]-u:x[I]>=p[I]&&(x[I]=(p[I]-1)*2-x[I]+u);x=x.map((I,T)=>I-l[T]);let v=w.locToIndex(x,h,c);y[b]=d[v]}return{dataId:n.write(y,o,a.dtype),shape:o,dtype:a.dtype}}var sK={kernelName:Vi,backendName:"cpu",kernelFunc:aK},iK=Tt((e,t)=>{let n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t}),oK=Bt(Ui,iK),lK={kernelName:Ui,backendName:"cpu",kernelFunc:oK},uK=Ja(Hh());function x2(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:s}=r,i=a.shape.length,o=s;if(o===-1&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);let l=w.parseAxisParam([o],a.shape),p=b2({inputs:{x:a},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),u=N.expandShapeToKeepDim(p.shape,l),d=ft({inputs:{x:p},backend:n,attrs:{shape:u}}),h=Sx({inputs:{a,b:d},backend:n}),c=EN({inputs:{x:h},backend:n}),f=bd({inputs:{x:c},backend:n,attrs:{axis:l,keepDims:!1}}),m=ft({inputs:{x:f},backend:n,attrs:{shape:u}}),g=Cx({inputs:{a:c,b:m},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}var pK={kernelName:co,backendName:"cpu",kernelFunc:x2};function dK(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r;ye(a,"multinomial");let l=o?a:x2({inputs:{logits:a},backend:n,attrs:{dim:-1}}),p=l.shape[0],u=l.shape[1],d=n.data.get(l.dataId).values,h=[p,s],c=w.makeZerosTypedArray(w.sizeFromShape(h),"int32");for(let f=0;f<p;++f){let m=f*u,g=new Float32Array(u-1);g[0]=d[m];for(let x=1;x<g.length;++x)g[x]=g[x-1]+d[m+x];let y=uK.alea(i.toString()),b=f*s;for(let x=0;x<s;++x){let v=y();c[b+x]=g.length;for(let I=0;I<g.length;I++)if(v<g[I]){c[b+x]=I;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(h,"int32",c)}var hK={kernelName:Bl,backendName:"cpu",kernelFunc:dK},cK=Xr.nonMaxSuppressionV3Impl;function fK(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r;ye(a,"NonMaxSuppression");let p=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,{selectedIndices:d}=cK(p,u,i,o,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}var mK={kernelName:Ul,backendName:"cpu",kernelFunc:fK},gK=Xr.nonMaxSuppressionV4Impl;function yK(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:p}=r;ye(a,"NonMaxSuppressionPadded");let u=n.data.get(a.dataId).values,d=n.data.get(s.dataId).values,{selectedIndices:h,validOutputs:c}=gK(u,d,i,o,l,p);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([c]))]}var bK={kernelName:Gl,backendName:"cpu",kernelFunc:yK},xK=Xr.nonMaxSuppressionV5Impl;function vK(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:p}=r;ye(a,"NonMaxSuppressionWithScore");let u=n.data.get(a.dataId).values,d=n.data.get(s.dataId).values,h=i,c=o,f=l,m=p,{selectedIndices:g,selectedScores:y}=xK(u,d,h,c,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var wK={kernelName:Hl,backendName:"cpu",kernelFunc:vK};function kK(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=r;ye(a,"oneHot");let p=w.sizeFromShape(a.shape),u=new Float32Array(p*i);u.fill(l);let d=n.data.get(a.dataId).values;for(let h=0;h<p;++h)d[h]>=0&&d[h]<i&&(u[h*i+d[h]]=o);return n.makeTensorInfo([...a.shape,i],s,u)}var IK={kernelName:Hi,backendName:"cpu",kernelFunc:kK};function Oh(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(r.dtype==="complex64"){let a=Hs({inputs:{input:r},backend:n}),s=Oh({inputs:{x:a},backend:n}),i=il({inputs:{input:r},backend:n}),o=Oh({inputs:{x:i},backend:n}),l=zn({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return _x({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}var SK={kernelName:pu,backendName:"cpu",kernelFunc:Oh};function v2(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(r.dtype==="complex64"){let a=Hs({inputs:{input:r},backend:n}),s=v2({inputs:{x:a},backend:n}),i=il({inputs:{input:r},backend:n}),o=Oh({inputs:{x:i},backend:n}),l=zn({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return _x({backend:n,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}var NK={kernelName:jl,backendName:"cpu",kernelFunc:v2};function w2(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(t.length===1)return Mh({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let s=t[0].shape,i=t[0].dtype;t.forEach(u=>{w.assertShapesMatch(s,u.shape,"All tensors passed to stack must have matching shapes"),w.assert(i===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],l=t.map(u=>{let d=Mh({inputs:{input:u},backend:n,attrs:{dim:a}});return o.push(d),d}),p=ol({inputs:l,backend:n,attrs:{axis:a}});return o.forEach(u=>n.disposeIntermediateTensorInfo(u)),p}var TK={kernelName:ql,backendName:"cpu",kernelFunc:w2};function CK(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,constantValue:i}=r;ye(a,"pad");let o=s.map((y,b)=>y[0]+a.shape[b]+y[1]),l=s.map(y=>y[0]),p=n.data.get(a.dataId).values,u=w.sizeFromShape(a.shape),d=a.shape.length,h=w.computeStrides(a.shape),c=w.sizeFromShape(o),f=o.length,m=w.computeStrides(o),g=w.getTypedArrayFromDType(a.dtype,c);i!==0&&g.fill(i);for(let y=0;y<u;y++){let b=w.indexToLoc(y,d,h).map((v,I)=>v+l[I]),x=w.locToIndex(b,f,m);g[x]=p[y]}return{dataId:n.write(g,o,a.dtype),shape:o,dtype:a.dtype}}var k2={kernelName:ji,backendName:"cpu",kernelFunc:CK},_K=Tt((e,t)=>Math.pow(e,t)),EK=Bt(qi,_K),$K={kernelName:qi,backendName:"cpu",kernelFunc:EK};function AK(e){let{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:a,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=r,l=a.map(y=>n.data.get(y.dataId).values),p=a.map(y=>y.shape),u=n.data.get(s.dataId).values,d=n.data.get(i.dataId).values,[h,c,f]=qN(l,p,u,s.shape,s.dtype,d,i.shape),m=h.map(y=>n.makeTensorInfo([y.length],"int32",y)),g=n.makeTensorInfo(f,s.dtype,c);return m.concat([g])}var FK={kernelName:ac,backendName:"cpu",kernelFunc:AK};function RK(e){let{inputs:t,backend:n}=e,{starts:r,limits:a,deltas:s}=t,i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[p,u]=KN(i,r.shape,r.dtype,o,a.shape,l,s.shape),d=n.makeTensorInfo([p.length],"int32",p),h=n.makeTensorInfo([u.length],r.dtype,u);return[d,h]}var DK={kernelName:sc,backendName:"cpu",kernelFunc:RK};function MK(e){let{inputs:t,backend:n,attrs:r}=e,{shape:a,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,p=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,d=n.data.get(i.dataId).values,h=o.map(g=>n.data.get(g.dataId).values),c=o.map(g=>g.shape),[f,m]=XN(p,a.shape,u,s.shape,s.dtype,d,i.shape,h,c,l);return n.makeTensorInfo(f,s.dtype,m)}var OK={kernelName:ic,backendName:"cpu",kernelFunc:MK};function LK(e){let{backend:t,attrs:n}=e,{start:r,stop:a,dtype:s,step:i}=n,o=xx(r,a,i,s);return t.makeTensorInfo([o.length],s,o)}var zK={kernelName:Rp,backendName:"cpu",kernelFunc:LK},PK=nt(Zi,e=>1/e),BK={kernelName:Zi,backendName:"cpu",kernelFunc:PK};function WK(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r;ye(a,"resizeBilinear");let l=w.computeStrides(a.shape),[p,u]=o,[d,h,c,f]=a.shape,m=n.data.get(a.dataId).values,g=new Float32Array(w.sizeFromShape([d,p,u,f])),y=[s&&p>1?h-1:h,s&&u>1?c-1:c],b=[s&&p>1?p-1:p,s&&u>1?u-1:u],x=0,v=y[0]/b[0],I=y[1]/b[1];for(let T=0;T<d;T++)for(let _=0;_<p;_++){let E;i?E=v*(_+.5)-.5:E=v*_;let A=Math.max(0,Math.floor(E)),R=E-A,F=Math.min(h-1,Math.ceil(E)),S=T*l[0]+A*l[1],M=T*l[0]+F*l[1];for(let W=0;W<u;W++){let U;i?U=I*(W+.5)-.5:U=I*W;let H=Math.max(0,Math.floor(U)),K=U-H,j=Math.min(c-1,Math.ceil(U)),Z=S+H*l[2],ee=M+H*l[2],Y=S+j*l[2],re=M+j*l[2];for(let te=0;te<f;te++){let ae=m[Z+te],ie=m[ee+te],ve=m[Y+te],be=m[re+te],he=ae+(ve-ae)*K,Ie=ie+(be-ie)*K,Te=he+(Ie-he)*R;g[x++]=Te}}}return n.makeTensorInfo([d,p,u,f],"float32",g)}var VK={kernelName:Qi,backendName:"cpu",kernelFunc:WK};function UK(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r;ye([s,a],"resizeBilinearGrad");let o=w.computeStrides(a.shape),[l,p,u,d]=a.shape,[,h,c]=s.shape,f=new Float32Array(l*p*u*d),m=[i&&h>1?p-1:p,i&&c>1?u-1:u],g=[i&&h>1?h-1:h,i&&c>1?c-1:c],y=m[0]/g[0],b=m[1]/g[1],x=n.data.get(s.dataId).values,v=0;for(let I=0;I<l;I++){let T=I*o[0];for(let _=0;_<h;_++){let E=_*y,A=Math.floor(E),R=Math.min(Math.ceil(E),p-1),F=T+A*o[1],S=T+R*o[1],M=E-A,W=1-M;for(let U=0;U<c;U++){let H=U*b,K=Math.floor(H),j=Math.min(Math.ceil(H),u-1),Z=H-K,ee=1-Z,Y=F+K*o[2],re=F+j*o[2],te=S+K*o[2],ae=S+j*o[2],ie=W*ee,ve=W*Z,be=M*ee,he=M*Z;for(let Ie=0;Ie<d;Ie++){let Te=x[v++];f[Y+Ie]+=Te*ie,f[re+Ie]+=Te*ve,f[te+Ie]+=Te*be,f[ae+Ie]+=Te*he}}}}return n.makeTensorInfo([l,u,p,d],"float32",f)}var GK={kernelName:Zl,backendName:"cpu",kernelFunc:UK};function HK(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r;ye(a,"resizeNearestNeighbor");let l=w.computeStrides(a.shape),[p,u]=o,[d,h,c,f]=a.shape,m=n.data.get(a.dataId).values,g=new Float32Array(d*p*u*f),y=[s&&p>1?h-1:h,s&&u>1?c-1:c],b=[s&&p>1?p-1:p,s&&u>1?u-1:u],x=y[0]/b[0],v=y[1]/b[1],I=0;for(let T=0;T<d;T++){let _=T*l[0];for(let E=0;E<p;E++){let A=i?x*(E+.5):x*E,R=Math.min(h-1,s?Math.round(A):Math.floor(A));i&&(R=Math.max(0,R));let F=_+R*l[1];for(let S=0;S<u;S++){let M=i?v*(S+.5):v*S,W=Math.min(c-1,s?Math.round(M):Math.floor(M));i&&(W=Math.max(0,W));let U=F+W*l[2];for(let H=0;H<f;H++){let K=m[U+H];g[I++]=K}}}}return n.makeTensorInfo([d,p,u,f],a.dtype,g)}var jK={kernelName:Yi,backendName:"cpu",kernelFunc:HK};function qK(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r;ye([s,a],"resizeNearestNeighborGrad");let o=w.computeStrides(a.shape),l=w.computeStrides(s.shape),[p,u,d,h]=a.shape,[,c,f]=s.shape,m=new Float32Array(p*u*d*h),g=n.data.get(s.dataId).values,y=[i&&c>1?u-1:u,i&&f>1?d-1:d],b=[i&&c>1?c-1:c,i&&f>1?f-1:f],x=y[0]/b[0],v=y[1]/b[1],I=1/x,T=1/v,_=Math.ceil(I)*2+2,E=Math.ceil(T)*2+2;for(let A=0;A<p;A++){let R=A*o[0];for(let F=0;F<u;F++){let S=R+F*o[1],M=Math.floor(F*I),W=Math.floor(M-_/2);for(let U=0;U<d;U++){let H=S+U*o[2],K=Math.floor(U*T),j=Math.floor(K-E/2);for(let Z=0;Z<h;Z++){let ee=0;for(let Y=0;Y<_;Y++){let re=Y+W;if(re<0||re>=c)continue;let te=R+re*l[1],ae=re*x,ie=Math.min(u-1,i?Math.round(ae):Math.floor(ae));if(F===ie)for(let ve=0;ve<E;ve++){let be=ve+j;if(be<0||be>=f)continue;let he=te+be*l[2],Ie=be*v,Te=Math.min(d-1,i?Math.round(Ie):Math.floor(Ie));U===Te&&(ee+=g[he+Z])}}m[H+Z]=ee}}}}return n.makeTensorInfo(a.shape,a.dtype,m)}var KK={kernelName:Xl,backendName:"cpu",kernelFunc:qK};function XK(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r;ye(a,"reverse");let i=a.shape.length,o=w.parseAxisParam(s,a.shape);if(i===0)return jr({inputs:{x:a},backend:n});let l=new $t(a.shape,a.dtype),p=n.bufferSync(a);for(let u=0;u<l.size;u++){let d=l.indexToLoc(u),h=d.slice();o.forEach(c=>h[c]=a.shape[c]-1-h[c]),l.set(p.get(...h),...d)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}var ZK={kernelName:to,backendName:"cpu",kernelFunc:XK},JK={kernelName:du,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:a,fillValue:s,center:i}=t,o=n,l=w.getTypedArrayFromDType(r.dtype,w.sizeFromShape(r.shape)),[p,u,d,h]=r.shape,[c,f]=N.getImageCenter(i,u,d),m=255,g=Math.sin(a),y=Math.cos(a),b=o.data.get(r.dataId).values;for(let x=0;x<p;x++){let v=x*d*u*h;for(let I=0;I<u;I++){let T=I*(d*h);for(let _=0;_<d;_++){let E=_*h;for(let A=0;A<h;A++){let R=[p,I,_,A],F=R[2],S=R[1],M=(F-c)*y-(S-f)*g,W=(F-c)*g+(S-f)*y;M=Math.round(M+c),W=Math.round(W+f);let U=s;if(typeof s!="number"&&(A===3?U=m:U=s[A]),M>=0&&M<d&&W>=0&&W<u){let K=W*(d*h),j=M*h,Z=v+K+j+A;U=b[Z]}let H=v+T+E+A;l[H]=U}}}}return{dataId:o.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},YK=nt(no,e=>{let t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1}),QK={kernelName:no,backendName:"cpu",kernelFunc:YK};function e8(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:s}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:p,strides:u,outputSize:d}=N.calculateShapes(s,a,i),h=!0,c=n.bufferSync(a),f=n.bufferSync(s),m=Cs(c,f,i,d,p,l,o,u,0,h);return n.makeTensorInfo(i,m.dtype,m.values)}var t8={kernelName:Jl,backendName:"cpu",kernelFunc:e8};function n8(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<t?n=a+1:r=a;return r}function r8(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<=t?n=a+1:r=a;return r}function a8(e,t,n,r,a,s){let i=w.getArrayFromDType("int32",n*a);for(let o=0;o<n;++o){let l=e.slice(o*r,(o+1)*r),p=o*a;for(let u=0;u<a;++u)i[p+u]=s==="left"?n8(l,t[u+p]):r8(l,t[u+p])}return i}function s8(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,p=a8(o,l,a.shape[0],a.shape[1],s.shape[1],i);return n.makeTensorInfo(s.shape,"int32",p)}var i8={kernelName:Ql,backendName:"cpu",kernelFunc:s8};function o8(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t;ye([r,a,s],"select");let i=r.shape.length,o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,p=n.data.get(s.dataId).values,u=tr(a.dtype,s.dtype),d=w.makeZerosTypedArray(w.sizeFromShape(a.shape),u),h=0,c=i===0||i>1||a.shape.length===1?1:w.sizeFromShape(a.shape.slice(1));for(let f=0;f<o.length;f++)for(let m=0;m<c;m++)o[f]===1?d[h++]=l[f]:d[h++]=p[f];return n.makeTensorInfo(a.shape,u,d)}var l8={kernelName:eu,backendName:"cpu",kernelFunc:o8},u8=N.SELU_SCALEALPHA,p8=N.SELU_SCALE,d8=nt(ao,e=>e>=0?p8*e:u8*(Math.exp(e)-1)),h8={kernelName:ao,backendName:"cpu",kernelFunc:d8},c8=nt(oo,e=>e<0?-1:e>0?1:0),f8={kernelName:oo,backendName:"cpu",kernelFunc:c8},m8=nt(so,e=>Math.sin(e)),g8={kernelName:so,backendName:"cpu",kernelFunc:m8},y8=nt(io,e=>Math.sinh(e)),b8={kernelName:io,backendName:"cpu",kernelFunc:y8},x8=11920928955078125e-23,Vw=Math.log(x8)+2,v8=nt(uo,e=>{let t=e>-Vw,n=e<Vw,r=Math.exp(e),a;return n?a=r:t?a=e:a=Math.log(1+r),a}),w8={kernelName:uo,backendName:"cpu",kernelFunc:v8};function k8(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r;ye([a],"spaceToBatchND");let o=w.sizeFromShape(s),l=[[0,0]];l.push(...i);for(let g=1+s.length;g<a.shape.length;++g)l.push([0,0]);let p=k2.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),u=N.getReshaped(p.shape,s,o,!1),d=N.getPermuted(u.length,s.length,!1),h=N.getReshapedPermuted(p.shape,s,o,!1),c=ft({inputs:{x:p},backend:n,attrs:{shape:u}}),f=$n({inputs:{x:c},backend:n,attrs:{perm:d}}),m=ft({inputs:{x:f},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(f),m}var I8={kernelName:nu,backendName:"cpu",kernelFunc:k8};function S8(e){let{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:s,defaultValue:i}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${s.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${r.shape}`);if(a.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${a.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,p=n.data.get(s.dataId).values,u=n.data.get(i.dataId).values[0],[d,h,c,f,m]=YN(o,r.shape,r.dtype,l,a.dtype,p,u);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],a.dtype,c),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}var N8={kernelName:Dp,backendName:"cpu",kernelFunc:S8};function T8(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:s}=t;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(a.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${a.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(n.data.get(a.dataId).values),o=n.data.get(r.dataId).values,l=Array.from(n.data.get(s.dataId).values),[p,u,d]=QN(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(u,r.dtype,p),n.makeTensorInfo([d.length],s.dtype,new Int32Array(d))]}var C8={kernelName:au,backendName:"cpu",kernelFunc:T8};function _8(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${a.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${s.shape}`);if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[p,u]=vx(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(u,r.dtype,p)}var E8={kernelName:Mp,backendName:"cpu",kernelFunc:_8};function $8(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${a.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${s.shape}`);if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[p,u]=vx(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(u,r.dtype,p)}var A8={kernelName:Op,backendName:"cpu",kernelFunc:$8};function F8(e){let{inputs:t,backend:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:p,sliceSize:u,strides:d,outputSize:h}=N.calculateShapes(s,a,o),c=!1,f=n.bufferSync(a),m;switch(s.dtype){case"bool":{let g=n.bufferSync(s),y=!!n.data.get(i.dataId).values[0];m=Cs(f,g,o,h,u,p,l,d,y,c);break}case"float32":{let g=n.bufferSync(s),y=n.data.get(i.dataId).values[0];m=Cs(f,g,o,h,u,p,l,d,y,c);break}case"int32":{let g=n.bufferSync(s),y=n.data.get(i.dataId).values[0];m=Cs(f,g,o,h,u,p,l,d,y,c);break}case"string":{let g=n.bufferSync(s),y=w.decodeString(n.data.get(i.dataId).values[0]);m=Cs(f,g,o,h,u,p,l,d,y,c);break}default:throw new Error(`Unsupported type ${s.dtype}`)}return n.makeTensorInfo(o,m.dtype,m.values)}var R8={kernelName:su,backendName:"cpu",kernelFunc:F8};function D8(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=r,o=w.parseAxisParam(i,a.shape)[0],l=N.prepareSplitSize(a,s,o),p=new Array(a.shape.length).fill(0),u=a.shape.slice();return l.map(d=>{let h=[...u];h[o]=d;let c=js({inputs:{x:a},backend:n,attrs:{begin:p,size:h}});return p[o]+=d,c})}var M8={kernelName:ru,backendName:"cpu",kernelFunc:D8},O8={kernelName:Lp,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{let{x:n}=e,r=t;ye(n,"square");let a=r.data.get(n.dataId).values,s=new Float32Array(a.length);for(let i=0;i<a.length;++i){let o=a[i];s[i]=o*o}return{dataId:r.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},L8=nt(ts,(e,t)=>{let n=t;return isNaN(e)?NaN:e>0?1:n.alpha}),z8={kernelName:ts,backendName:"cpu",kernelFunc:L8};function P8(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,end:i,strides:o,beginMask:l,endMask:p,ellipsisMask:u,newAxisMask:d,shrinkAxisMask:h}=r;ye(a,"stridedSlice");let{finalShapeSparse:c,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:x,strides:v}=Lt.sliceInfo(a.shape,s,i,o,l,p,u,d,h),I;if(m)I=ft({inputs:{x:a},backend:n,attrs:{shape:f}});else if(g||y){w.assert(a.shape.length>=1,()=>`Input must have rank at least 1, got: ${a.shape.length}`);let T=Lt.computeOutShape(b,x,v),_=js({inputs:{x:a},backend:n,attrs:{begin:b,size:T}});I=ft({inputs:{x:_},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(_)}else{let T=n.bufferSync(a),_=n2(c,T,v,b);I=n.makeTensorInfo(f,_.dtype,_.values)}return I}var B8={kernelName:iu,backendName:"cpu",kernelFunc:P8};function W8(e){let{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:p}=r,{data:u,dataSplits:d}=t,h=n.data.get(u.dataId).values,c=n.data.get(d.dataId).values,[f,m]=wx(h,c,a,s,i,o,l,p);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}var V8={kernelName:Pp,backendName:"cpu",kernelFunc:W8};function U8(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:s,delimiter:i}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values[0],[p,u,d]=kx(o,l,a),h=u.length;return[n.makeTensorInfo([h,2],"int32",p),n.makeTensorInfo([h],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(d))]}var G8={kernelName:Bp,backendName:"cpu",kernelFunc:U8};function H8(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");let i=n.data.get(s.dataId).values,o=Ix(i,a);return n.makeTensorInfo(s.shape,"int32",o)}var j8={kernelName:Wp,backendName:"cpu",kernelFunc:H8},q8=nt(go,e=>Math.tan(e)),K8={kernelName:go,backendName:"cpu",kernelFunc:q8},X8=nt(yo,e=>Math.tanh(e)),Z8={kernelName:yo,backendName:"cpu",kernelFunc:X8};function J8(e){let{inputs:t,backend:n}=e,{tensor:r,indices:a,updates:s}=t,{sliceRank:i,numUpdates:o,sliceSize:l,strides:p,outputSize:u}=N.calculateShapes(s,a,r.shape),d=!1,h=n.bufferSync(a),c=n.bufferSync(s),f=n.bufferSync(r),m=Cs(h,c,r.shape,u,l,o,i,p,f,d);return n.makeTensorInfo(r.shape,m.dtype,m.values)}var Y8={kernelName:Yl,backendName:"cpu",kernelFunc:J8};function Q8(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:s}=r;ye(a,"tile");let i=a2(n.bufferSync(a),s);return n.makeTensorInfo(i.shape,i.dtype,i.values)}var eX={kernelName:es,backendName:"cpu",kernelFunc:Q8};function tX(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:i}=r;ye(a,"topk");let o=n.data.get(a.dataId).values,[l,p]=i2(o,a.shape,a.dtype,s,i);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(p.shape,p.dtype,p.values)]}var nX={kernelName:ou,backendName:"cpu",kernelFunc:tX};function rX(e){let{inputs:t,attrs:n,backend:r}=e,{image:a,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:p}=n,[u,d,h,c]=a.shape,[f,m]=p??[d,h],g=[u,f,m,c],y=w.computeStrides(a.shape),b=y[0],x=y[1],v=y[2],I=w.computeStrides(g),T=I[0],_=I[1],E=I[2],A=w.getTypedArrayFromDType(a.dtype,w.sizeFromShape(g));A.fill(l);let R=r.data.get(a.dataId).values,F=r.data.get(s.dataId).values;for(let S=0;S<u;++S){let M=s.shape[0]===1?F:F.subarray(S*8,S*8+8);for(let W=0;W<f;++W)for(let U=0;U<m;++U)for(let H=0;H<c;++H){let K,j=M[6]*U+M[7]*W+1;if(j===0)continue;let Z=(M[0]*U+M[1]*W+M[2])/j,ee=(M[3]*U+M[4]*W+M[5])/j,Y=Uw(Z,h,o),re=Uw(ee,d,o);switch(i){case"nearest":K=uX(R,d,h,b,x,v,S,re,Y,H,l);break;case"bilinear":K=pX(R,d,h,b,x,v,S,re,Y,H,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}let te=S*T+W*_+U*E+H;A[te]=K}return r.makeTensorInfo(g,a.dtype,A)}return{dataId:r.write(A,g,a.dtype),shape:a.shape,dtype:a.dtype}}var aX={kernelName:lu,backendName:"cpu",kernelFunc:rX};function Uw(e,t,n){switch(n){case"reflect":return sX(e,t);case"wrap":return iX(e,t);case"nearest":return lX(e,t);case"constant":default:return oX(e)}}function sX(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let r=2*t;n<r&&(n=r*Math.trunc(-n/r)+n),n=n<-t?n+r:-n-1}else if(n>t-1)if(t<=1)n=0;else{let r=2*t;n-=r*Math.trunc(n/r),n>=t&&(n=r-n-1)}return w.clamp(0,n,t-1)}function iX(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let r=t-1;n+=t*(Math.trunc(-n/r)+1)}else if(n>t-1)if(t<=1)n=0;else{let r=t-1;n-=t*Math.trunc(n/r)}return w.clamp(0,n,t-1)}function oX(e,t){return e}function lX(e,t){return w.clamp(0,e,t-1)}function ju(e,t,n,r,a,s,i,o,l,p,u){let d=i*r+o*a+l*s+p;return 0<=o&&o<t&&0<=l&&l<n?e[d]:u}function uX(e,t,n,r,a,s,i,o,l,p,u){let d=Math.round(o),h=Math.round(l);return ju(e,t,n,r,a,s,i,d,h,p,u)}function pX(e,t,n,r,a,s,i,o,l,p,u){let d=Math.floor(o),h=Math.floor(l),c=d+1,f=h+1,m=(f-l)*ju(e,t,n,r,a,s,i,d,h,p,u)+(l-h)*ju(e,t,n,r,a,s,i,d,f,p,u),g=(f-l)*ju(e,t,n,r,a,s,i,c,h,p,u)+(l-h)*ju(e,t,n,r,a,s,i,c,f,p,u);return(c-o)*m+(o-d)*g}function dX(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t;ye(s,"unique");let i=r.data.get(s.dataId).values,{outputValues:o,outputShape:l,indices:p}=Nx(i,a,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,o),r.makeTensorInfo([p.length],"int32",p)]}var hX={kernelName:Vp,backendName:"cpu",kernelFunc:dX};function cX(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:s}=r;s<0&&(s+=a.shape.length);let i=a.shape.length,o=a.shape[s],l=new Array(i-1),p=0;for(let c=0;c<i;c++)c!==s&&(l[p++]=a.shape[c]);let u=new Array(i).fill(0),d=a.shape.slice();d[s]=1;let h=new Array(o);for(let c=0;c<h.length;c++){u[s]=c;let f=js({inputs:{x:a},backend:n,attrs:{begin:u,size:d}});h[c]=ft({inputs:{x:f},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(f)}return h}var fX={kernelName:uu,backendName:"cpu",kernelFunc:cX};function mX(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:s}=t,{numSegments:i}=r;ye(a,"unsortedSegmentSum");let o=a.shape.length,l=s.shape.length,p=[],u=[],d=o-l,h=s;for(let f=0;f<d;++f){let m=Mh({inputs:{input:h},backend:n,attrs:{dim:f+1}});h=m,u.push(m)}for(let f=0;f<i;++f){let m=w.createScalarValue(f,"int32"),g=n.makeTensorInfo([],"int32",m),y=CN({inputs:{a:g,b:h},backend:n}),b=Ka({inputs:{x:y},backend:n,attrs:{dtype:"float32"}}),x=ff({inputs:{a:b,b:a},backend:n}),v=bd({inputs:{x},backend:n,attrs:{axis:0,keepDims:!1}});p.push(v),u.push(g),u.push(y),u.push(b),u.push(x),u.push(v)}let c=w2({inputs:p,backend:n,attrs:{axis:0}});return u.forEach(f=>n.disposeIntermediateTensorInfo(f)),c}var gX={kernelName:Up,backendName:"cpu",kernelFunc:mX},yX=[pj,UH,hj,fj,XH,gj,bj,vj,kj,Sj,Tj,_j,$j,Rj,Mj,zj,Bj,Vj,Gj,lj,jj,Kj,Zj,JH,Yj,qH,QH,eq,GH,nq,aq,sq,oq,uq,dq,cq,mq,yq,xq,wq,Iq,Nq,Cq,Eq,$q,Fq,Dq,Oq,Lq,zq,Pq,Wq,Gq,tj,jq,e6,e5,t6,t5,r6,o5,l5,p5,s6,o6,h5,f5,g5,b5,u6,d6,HH,v5,rq,k5,S5,T5,nj,c6,m6,_5,y6,$5,R5,M5,z5,B5,V5,U5,x6,H5,q5,X5,J5,Q5,tK,rK,w6,sK,lK,hK,I6,N6,mK,bK,wK,C6,IK,NK,TK,k2,$K,aj,$6,FK,DK,OK,zK,jH,Om,BK,sj,ij,oj,VK,GK,jK,KK,ZK,JK,QK,P6,t8,i8,l8,h8,W6,f8,g8,b8,V6,pK,w8,I8,N8,C8,E8,A8,R8,M8,H6,O8,q6,X6,z8,B8,V8,G8,j8,Q6,Vq,K8,Z8,Y8,eX,nX,aX,_6,hX,fX,gX,SK];for(let e of yX)Gp(e);var I2={};Ee(I2,{assertNotComplex:()=>Su,bindCanvasToFramebuffer:()=>_X,bindColorTextureToFramebuffer:()=>lh,bindTextureToProgramUniformSampler:()=>P2,bindTextureUnit:()=>O2,bindVertexBufferToProgramAttribute:()=>zm,callAndCheck:()=>pe,canBeRepresented:()=>N2,createFragmentShader:()=>_2,createFramebuffer:()=>M2,createProgram:()=>E2,createStaticIndexBuffer:()=>F2,createStaticVertexBuffer:()=>A2,createTexture:()=>R2,createVertexShader:()=>C2,getBatchDim:()=>qs,getExtensionOrThrow:()=>qu,getFramebufferErrorMessage:()=>B2,getMaxTexturesInShader:()=>G2,getNumChannels:()=>TX,getProgramUniformLocation:()=>z2,getProgramUniformLocationOrThrow:()=>L2,getRowsCols:()=>Ks,getShapeAs3D:()=>Xu,getTextureShapeFromLogicalShape:()=>V2,getWebGLDisjointQueryTimerVersion:()=>H2,getWebGLErrorMessage:()=>T2,getWebGLMaxTextureSize:()=>U2,hasExtension:()=>Yn,isCapableOfRenderingToFloatTexture:()=>j2,isDownloadFloatTextureEnabled:()=>q2,isReshapeFree:()=>gp,isWebGLFenceEnabled:()=>K2,isWebGLVersionEnabled:()=>Bm,linkProgram:()=>$2,logShaderSourceAndInfoLog:()=>$x,resetMaxTextureSize:()=>EX,resetMaxTexturesInShader:()=>$X,unbindColorTextureFromFramebuffer:()=>Pm,unbindTextureUnit:()=>CX,validateFramebuffer:()=>Ku,validateProgram:()=>oh,validateTextureSize:()=>D2});var Ns={},Jd={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function S2(e,t){Ns[e]=t}function Tr(e,t){if(!(e in Ns)||t!=null){let r=xX(e,t);if(r!==null)Ns[e]=r;else return console.log("Could not get context for WebGL version",e),null}let n=Ns[e];return n==null||n.isContextLost()?(delete Ns[e],Tr(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),Ns[e])}function bX(e){if(!G().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&e===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function xX(e,t){if(e!==1&&e!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let n=t??bX(e);return n.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete Ns[e]},!1),G().getBool("SOFTWARE_WEBGL_ENABLED")&&(Jd.failIfMajorPerformanceCaveat=!1),e===1?n.getContext("webgl",Jd)||n.getContext("experimental-webgl",Jd):n.getContext("webgl2",Jd)}var mp;(function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"})(mp||(mp={}));var Jn;(function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"})(Jn||(Jn={}));var tn;(function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(tn||(tn={}));function xd(e,t){return[t,e]}function vX(e,t){return e*t}function Yd(e){let t=w.sizeFromShape(e),n=Math.ceil(t/4);return w.sizeToSquarishShape(n)}function Iu(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function wX(e,t){let[n,r]=Iu(e,t);return n*r*4}function Ex(e,t){let n=e,r,a,s,i,o,l,p,u,d,h;return G().getNumber("WEBGL_VERSION")===2?(r=n.R32F,a=n.R16F,s=n.RGBA16F,i=n.RGBA32F,o=n.RED,p=4,u=1,d=n.HALF_FLOAT,h=n.FLOAT,l=n.RGBA8):(r=e.RGBA,a=e.RGBA,s=e.RGBA,i=n.RGBA,o=e.RGBA,p=4,u=4,d=t!=null?t.HALF_FLOAT_OES:null,h=e.FLOAT,l=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:a,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:p,defaultNumChannels:u,textureTypeHalfFloat:d,textureTypeFloat:h}}function pe(e,t){let n=t();return G().getBool("DEBUG")&&kX(e),n}function kX(e){let t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+T2(e,t))}var IX=596e-10,SX=65504;function N2(e){return!!(G().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||e===0||IX<Math.abs(e)&&Math.abs(e)<SX)}function T2(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function qu(e,t){return ya(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function C2(e,t){let n=ya(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(pe(e,()=>e.shaderSource(n,t)),pe(e,()=>e.compileShader(n)),e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function _2(e,t){let n=ya(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(pe(e,()=>e.shaderSource(n,t)),pe(e,()=>e.compileShader(n)),G().get("ENGINE_COMPILE_ONLY"))return n;if(e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw $x(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}var NX=/ERROR: [0-9]+:([0-9]+):/g;function $x(e,t){let n=NX.exec(t);if(n==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(e);return}let r=+n[1],a=e.split(`
`),s=a.length.toString().length+2,i=a.map((d,h)=>w.rightPad((h+1).toString(),s)+d),o=0;for(let d=0;d<i.length;d++)o=Math.max(i[d].length,o);let l=i.slice(0,r-1),p=i.slice(r-1,r),u=i.slice(r);console.log(l.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${w.rightPad(p[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join(`
`))}function E2(e){return ya(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}function $2(e,t){if(pe(e,()=>e.linkProgram(t)),!G().get("ENGINE_COMPILE_ONLY")&&e.getProgramParameter(t,e.LINK_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function oh(e,t){if(pe(e,()=>e.validateProgram(t)),e.getProgramParameter(t,e.VALIDATE_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function A2(e,t){let n=ya(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return pe(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),pe(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function F2(e,t){let n=ya(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return pe(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),pe(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function TX(){return G().getNumber("WEBGL_VERSION")===2?1:4}function R2(e){return ya(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}function D2(e,t){let n=G().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){let r=`[${e}x${t}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(e>n||t>n){let r=`[${e}x${t}]`,a=`[${n}x${n}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+a+".")}}function M2(e){return ya(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function zm(e,t,n,r,a,s,i){let o=e.getAttribLocation(t,n);return o===-1?!1:(pe(e,()=>e.bindBuffer(e.ARRAY_BUFFER,r)),pe(e,()=>e.vertexAttribPointer(o,a,e.FLOAT,!1,s,i)),pe(e,()=>e.enableVertexAttribArray(o)),!0)}function O2(e,t,n){W2(e,n),pe(e,()=>e.activeTexture(e.TEXTURE0+n)),pe(e,()=>e.bindTexture(e.TEXTURE_2D,t))}function CX(e,t){W2(e,t),pe(e,()=>e.activeTexture(e.TEXTURE0+t)),pe(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function L2(e,t,n){return ya(e,()=>e.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}function z2(e,t,n){return e.getUniformLocation(t,n)}function P2(e,t,n,r){pe(e,()=>O2(e,t,r)),pe(e,()=>e.uniform1i(n,r))}function _X(e){pe(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),pe(e,()=>e.viewport(0,0,e.canvas.width,e.canvas.height)),pe(e,()=>e.scissor(0,0,e.canvas.width,e.canvas.height))}function lh(e,t,n){pe(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),pe(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function Pm(e,t){pe(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),pe(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function Ku(e){let t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+B2(e,t))}function B2(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function ya(e,t,n){let r=pe(e,()=>t());if(r==null)throw new Error(n);return r}function W2(e,t){let n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){let a=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${a}.`)}}function qs(e,t=2){return w.sizeFromShape(e.slice(0,e.length-t))}function Ks(e){if(e.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function Xu(e){let t=[1,1,1];return e.length===0||e.length===1&&e[0]===1||(t=[qs(e),...Ks(e)]),t}function V2(e,t=!1){let n=G().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=G().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&G().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n=n*2,r=r*2,e=e.map((o,l)=>l>=e.length-2?w.nearestLargerEven(e[l]):e[l]),e.length===1&&(e=[2,e[0]])),e.length!==2&&(e=w.squeezeShape(e).newShape);let a=w.sizeFromShape(e),s=null;e.length<=1&&a<=n?s=[1,a]:e.length===2&&e[0]<=n&&e[1]<=n?s=e:e.length===3&&e[0]*e[1]<=n&&e[2]<=n?s=[e[0]*e[1],e[2]]:e.length===3&&e[0]<=n&&e[1]*e[2]<=n?s=[e[0],e[1]*e[2]]:e.length===4&&e[0]*e[1]*e[2]<=n&&e[3]<=n?s=[e[0]*e[1]*e[2],e[3]]:e.length===4&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(s=[e[0],e[1]*e[2]*e[3]]);let i=s!=null&&Math.max(...s)>r&&Math.min(...s)<=(t?2:1)&&Math.min(...s)>0;if(s==null||i)if(t){let o=qs(e),l=2,p=2;e.length&&([l,p]=Ks(e)),a=o*(l/2)*(p/2),s=w.sizeToSquarishShape(a).map(u=>u*2)}else s=w.sizeToSquarishShape(a);return s}function Qd(e){return e%2===0}function gp(e,t){if(e=e.slice(-2),t=t.slice(-2),w.arraysEqual(e,t)||!e.length||!t.length||e[0]===0||e[1]===0||t[0]===0||t[1]===0)return!0;if(e.length!==t.length){let n=e[e.length-1],r=t[t.length-1];if(n===r||Qd(n)&&Qd(r)&&(e[0]===1||t[0]===1))return!0}return e[1]===t[1]&&Qd(e[0])&&Qd(t[0])}var uh,ph;function U2(e){if(uh==null){let t=Tr(e);uh=t.getParameter(t.MAX_TEXTURE_SIZE)}return uh}function EX(){uh=null}function $X(){ph=null}function G2(e){if(ph==null){let t=Tr(e);ph=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,ph)}function H2(e){if(e===0)return 0;let t,n=Tr(e);return Yn(n,"EXT_disjoint_timer_query_webgl2")&&e===2?t=2:Yn(n,"EXT_disjoint_timer_query")?t=1:t=0,t}function Yn(e,t){return e.getExtension(t)!=null}function Bm(e){try{if(Tr(e)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function j2(e){if(e===0)return!1;let t=Tr(e);if(e===1){if(!Yn(t,"OES_texture_float"))return!1}else if(!Yn(t,"EXT_color_buffer_float"))return!1;return Wm(t)}function q2(e){if(e===0)return!1;let t=Tr(e);if(e===1){if(!Yn(t,"OES_texture_float")||!Yn(t,"WEBGL_color_buffer_float"))return!1}else{if(Yn(t,"EXT_color_buffer_float"))return Wm(t);let n="EXT_color_buffer_half_float";if(Yn(t,n)){let r=t.getExtension(n);return AX(t,r)}return!1}return Wm(t)}function Wm(e){let t=Ex(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);let r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);let a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),a}function AX(e,t){let n=Ex(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);let a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);let s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(a),s}function K2(e){return e!==2?!1:Tr(e).fenceSync!=null}function Su(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&w.assert(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}var xe=G();xe.registerFlag("HAS_WEBGL",()=>xe.getNumber("WEBGL_VERSION")>0);xe.registerFlag("WEBGL_VERSION",()=>Bm(2)?2:Bm(1)?1:0);xe.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);xe.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>xe.get("WEBGL_VERSION")===2);xe.registerFlag("WEBGL_CPU_FORWARD",()=>!0);xe.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);xe.registerFlag("WEBGL_PACK",()=>xe.getBool("HAS_WEBGL"));xe.registerFlag("WEBGL_PACK_NORMALIZATION",()=>xe.getBool("WEBGL_PACK"));xe.registerFlag("WEBGL_PACK_CLIP",()=>xe.getBool("WEBGL_PACK"));xe.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>xe.getBool("WEBGL_PACK"));xe.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>xe.getBool("WEBGL_PACK"));xe.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>xe.getBool("WEBGL_PACK"));xe.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>xe.getBool("WEBGL_PACK"));xe.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>xe.getBool("WEBGL_PACK"));xe.registerFlag("WEBGL_PACK_REDUCE",()=>xe.getBool("WEBGL_PACK"));xe.registerFlag("WEBGL_LAZILY_UNPACK",()=>xe.getBool("WEBGL_PACK"));xe.registerFlag("WEBGL_CONV_IM2COL",()=>xe.getBool("WEBGL_PACK"));xe.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>xe.getBool("WEBGL_PACK"));xe.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>U2(xe.getNumber("WEBGL_VERSION")));xe.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>G2(xe.getNumber("WEBGL_VERSION")));xe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let e=xe.getNumber("WEBGL_VERSION");return e===0?0:H2(e)});xe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>xe.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!qp.isMobile());xe.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>j2(xe.getNumber("WEBGL_VERSION")));xe.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>xe.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:xe.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));xe.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>q2(xe.getNumber("WEBGL_VERSION")));xe.registerFlag("WEBGL_FENCE_API_ENABLED",()=>K2(xe.getNumber("WEBGL_VERSION")));xe.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>xe.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);xe.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if(typeof e!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&e!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)});xe.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>qp.isMobile()?1:-1,e=>{if(typeof e!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&e!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)});xe.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);xe.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);xe.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);xe.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);xe.registerFlag("WEBGL_EXP_CONV",()=>!1);xe.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>xe.getBool("IS_TEST"));xe.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);xe.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);xe.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);xe.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function vn(){let e,t,n,r,a,s,i,o,l,p;return G().getNumber("WEBGL_VERSION")===2?(e="#version 300 es",t="in",n="out",r="in",a="texture",s="outputColor",i="out vec4 outputColor;",o=G().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",p=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(e="",t="attribute",n="varying",r="varying",a="texture2D",s="gl_FragColor",i="",o=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,p=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:a,output:s,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:l,defineRound:p}}function No(e,t,n="index"){let r=w.computeStrides(t);return r.map((a,s)=>{let i=`int ${e[s]} = ${n} / ${a}`,o=s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * ${a}`:`index -= ${e[s]} * ${a}`;return`${i}; ${o};`}).join("")}function mf(e,t,n="index"){let r=w.computeStrides(t);return r.map((a,s)=>{let i=`int ${e[s]} = ${n} / outShapeStrides[${s}]`,o=s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * outShapeStrides[${s}]`:`index -= ${e[s]} * outShapeStrides[${s}]`;return`${i}; ${o};`}).join("")}function FX(e,t){let n=e.length,r=e.map(s=>`${t}[${s}]`),a=new Array(n-1);a[n-2]=r[n-1];for(let s=n-3;s>=0;--s)a[s]=`(${a[s+1]} * ${r[s+1]})`;return a}function RX(e,t,n="index"){let r=e.map((s,i)=>i),a=FX(r,t);return a.map((s,i)=>{let o=`int ${e[i]} = ${n} / ${a[i]}`,l=i===a.length-1?`int ${e[i+1]} = ${n} - ${e[i]} * ${a[i]}`:`index -= ${e[i]} * ${a[i]}`;return`${o}; ${l};`}).join("")}function Ax(e){let t=w.computeStrides(e).map(n=>n.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function Fx(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}var X2=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`,{getBroadcastDims:Z2}=N;function DX(e,t,n){let r=[];if(e.forEach(h=>{let c=w.sizeFromShape(h.shapeInfo.logicalShape);if(h.shapeInfo.isUniform?r.push(`uniform float ${h.name}${c>1?`[${c}]`:""};`):(r.push(`uniform sampler2D ${h.name};`),r.push(`uniform int offset${h.name};`)),n.enableShapeUniforms){let{uniformShape:f}=Rx(n.packedInputs,h.shapeInfo.logicalShape,h.shapeInfo.texShape);switch(f.length){case 1:r.push(`uniform int ${h.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${h.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${h.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${h.name}Shape;`);break}r.push(`uniform ivec2 ${h.name}TexShape;`)}}),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(h=>{r.push(`uniform ${h.type} ${h.name}${h.arrayIndex?`[${h.arrayIndex}]`:""};`)});let a=r.join(`
`),s=e.map(h=>MX(h,t,n.packedInputs,n.enableShapeUniforms)).join(`
`),i=t.texShape,o=vn(),l=zX(o),p,u,d=WX(o);return t.isPacked?(p=OX(t.logicalShape,i,n.enableShapeUniforms),u=BX(o)):(p=LX(t.logicalShape,i,n.enableShapeUniforms),u=PX(o)),n.packedInputs&&(d+=HX),[d,l,u,a,p,s,n.userCode].join(`
`)}function Nu(e,t=!1){let n=e.shapeInfo.logicalShape;switch(n.length){case 0:return r7(e,t);case 1:return s7(e,t);case 2:return o7(e,t);case 3:return u7(e,t);case 4:return d7(e,t);case 5:return h7(e);case 6:return c7(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function J2(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return n7(e);case 1:return a7(e,t);case 2:return i7(e,t);case 3:return l7(e,t);default:return p7(e,t)}}function MX(e,t,n=!1,r){let a="";n?a+=J2(e,r):a+=Nu(e,r);let s=e.shapeInfo.logicalShape,i=t.logicalShape;return s.length<=i.length&&(n?a+=f7(e,t):a+=m7(e,t)),a}function OX(e,t,n){switch(e.length){case 0:return Y2();case 1:return jX(e,t,n);case 2:return e7(e,t,n);case 3:return KX(e,t,n);default:return ZX(e,t,n)}}function LX(e,t,n){switch(e.length){case 0:return Y2();case 1:return qX(e,t,n);case 2:return t7(e,t,n);case 3:return XX(e,t,n);case 4:return JX(e,t,n);case 5:return YX(e,t);case 6:return QX(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}function zX(e){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${e.texture2D}(textureSampler, uv).r;
    }
  `}function PX(e){return`
    void setOutput(float val) {
      ${e.output} = vec4(val, 0, 0, 0);
    }
  `}function BX(e){return`
    void setOutput(vec4 val) {
      ${e.output} = val;
    }
  `}function WX(e){return`${e.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e.varyingFs} vec2 resultUV;
    ${e.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${e.defineSpecialNaN}
    ${e.defineSpecialInf}
    ${e.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${VX}
    ${UX}
    ${GX}
  `}var VX=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,UX=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,GX=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,HX=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function Y2(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function jX(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return r[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function qX(e,t,n){return t[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function KX(e,t,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[2]/2),s=a*Math.ceil(e[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${a});
      int c = imod(index, ${a}) * 2;

      return ivec3(b, r, c);
    }
  `}function XX(e,t,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${mf(["r","c","d"],e)}
    return ivec3(r, c, d);
  }
`;let r=No(["r","c","d"],e);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function ZX(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[e.length-1]/2),s=a*Math.ceil(e[e.length-2]/2),i=s,o="",l="b, r, c";for(let p=2;p<e.length-1;p++)i*=e[e.length-p-1],o=`
      int b${p} = index / ${i};
      index -= b${p} * ${i};
    `+o,l=`b${p}, `+l;return`
    ivec${e.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${o}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${a});
      int c = imod(index, ${a}) * 2;

      return ivec${e.length}(${l});
    }
  `}function JX(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${mf(["r","c","d","d2"],e)}
      return ivec4(r, c, d, d2);
    }
  `;let r=No(["r","c","d","d2"],e);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function YX(e,t){let n=No(["r","c","d","d2","d3"],e);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function QX(e,t){let n=No(["r","c","d","d2","d3","d4"],e);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function e7(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(w.arraysEqual(e,t))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;let a=Math.ceil(e[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${a});
      int c = imod(index, ${a}) * 2;

      return ivec2(r, c);
    }
  `}function t7(e,t,n){return w.arraysEqual(e,t)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:e[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:e[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${e[1]};
      int c = index - r * ${e[1]};
      return ivec2(r, c);
    }
  `}function To(e){return`offset${e}`}function n7(e){let t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=vn();return`
    vec4 ${n}() {
      return ${r.texture2D}(${t}, halfCR);
    }
  `}function r7(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;let[a,s]=e.shapeInfo.texShape;if(a===1&&s===1)return`
      float ${r}() {
        return sampleTexture(${n}, halfCR);
      }
    `;let i=To(n);if(t)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});
      return sampleTexture(${n}, uv);
    }
  `;let[o,l]=e.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${o}, ${l}, ${i});
      return sampleTexture(${n}, uv);
    }
  `}function a7(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=e.shapeInfo.texShape,s=vn();if(t)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${s.texture2D}(${n}, uv);
    }
  `;let i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${s.texture2D}(${n}, uv);
    }
  `}function s7(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${Tu(e)}
      }
    `;let a=e.shapeInfo.texShape,s=a[0],i=a[1];if(i===1&&s===1)return`
      float ${r}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;let o=To(n);return i===1?t?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${s}.0);
        return sampleTexture(${n}, uv);
      }
    `:s===1?t?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:t?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${s}, ${i}, index + ${o});
      return sampleTexture(${n}, uv);
    }
  `}function i7(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,i=s[0],o=s[1],l=vn();if(s!=null&&w.arraysEqual(n,s))return t?`
      vec4 ${a}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${l.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${a}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);

        return ${l.texture2D}(${r}, uv);
      }
    `;if(t)return`
    vec4 ${a}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `;let p=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],u=Math.ceil(n[1]/2);return`
    vec4 ${a}(int row, int col) {
      vec2 uv = packedUVfrom2D(${u}, ${p[0]}, ${p[1]}, row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `}function o7(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape;if(s!=null&&w.arraysEqual(n,s)){if(t)return`
      float ${a}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;let h=s[0],c=s[1];return`
    float ${a}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${c}.0, ${h}.0);
      return sampleTexture(${r}, uv);
    }
  `}let{newShape:i,keptDims:o}=w.squeezeShape(n),l=i;if(l.length<n.length){let h=Cu(e,l),c=["row","col"];return`
      ${Nu(h,t)}
      float ${a}(int row, int col) {
        return ${a}(${_u(c,o)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${a}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${Tu(e)}
      }
    `;let p=s[0],u=s[1],d=To(r);return u===1?t?`
      float ${a}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${a}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${p}.0);
      return sampleTexture(${r}, uv);
    }
  `:p===1?t?`
      float ${a}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${a}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:t?`
      float ${a}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${d};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${a}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${d};
    vec2 uv = uvFromFlat(${p}, ${u}, index);
    return sampleTexture(${r}, uv);
  }
`}function l7(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(n[0]===1){let h=n.slice(1),c=[1,2],f=Cu(e,h),m=["b","row","col"];return`
        ${J2(f,t)}
        vec4 ${a}(int b, int row, int col) {
          return ${a}(${_u(m,c)});
        }
      `}let o=vn();if(t)return`
    vec4 ${a}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${o.texture2D}(${r}, uv);
    }
  `;let l=i[0],p=i[1],u=Math.ceil(n[2]/2),d=u*Math.ceil(n[1]/2);return`
    vec4 ${a}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${p}, ${d}, ${u}, b, row, col);
      return ${o.texture2D}(${r}, uv);
    }
  `}function u7(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[1]*n[2],i=n[2],{newShape:o,keptDims:l}=w.squeezeShape(n),p=o;if(p.length<n.length){let m=Cu(e,p),g=["row","col","depth"];return`
        ${Nu(m,t)}
        float ${a}(int row, int col, int depth) {
          return ${a}(${_u(g,l)});
        }
      `}if(e.shapeInfo.isUniform)return`
      float ${a}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${s}, ${i}, 1)));
        ${Tu(e)}
      }
    `;let u=e.shapeInfo.texShape,d=u[0],h=u[1],c=e.shapeInfo.flatOffset;if(h===s&&c==null)return t?`
      float ${a}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${a}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${h}.0, ${d}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(h===i&&c==null)return t?`
      float ${a}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${a}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${d}.0);
      return sampleTexture(${r}, uv);
    }
  `;let f=To(r);return t?`
    float ${a}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${f};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${a}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s} + col * ${i} + depth + ${f};
        vec2 uv = uvFromFlat(${d}, ${h}, index);
        return sampleTexture(${r}, uv);
      }
  `}function p7(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=vn();if(t)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${a.texture2D}(${n}, uv);
    }
  `;let s=e.shapeInfo.logicalShape,i=s.length,o=e.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],p=l[0],u=l[1],d=Math.ceil(s[i-1]/2),h=d*Math.ceil(s[i-2]/2),c="int b, int row, int col",f=`b * ${h} + (row / 2) * ${d} + (col / 2)`;for(let m=2;m<i-1;m++)c=`int b${m}, `+c,h*=s[i-m-1],f=`b${m} * ${h} + `+f;return`
    vec4 ${r}(${c}) {
      int index = ${f};
      int texR = index / ${u};
      int texC = index - texR * ${u};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${p});
      return ${a.texture2D}(${n}, uv);
    }
  `}function d7(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[3],i=n[2]*s,o=n[1]*i,{newShape:l,keptDims:p}=w.squeezeShape(n);if(l.length<n.length){let b=Cu(e,l),x=["row","col","depth","depth2"];return`
      ${Nu(b,t)}
      float ${a}(int row, int col, int depth, int depth2) {
        return ${a}(${_u(x,p)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${a}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${o}, ${i}, ${s}, 1)));
        ${Tu(e)}
      }
    `;let u=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],c=d[1],f=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(c===o&&u==null)return t?`
      float ${a}(int row, int col, int depth, int depth2) {
        ${f}
        ${m}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${a}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${c}.0, ${h}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(c===s&&u==null)return t?`
      float ${a}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${a}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${c}.0, ${h}.0);
        return sampleTexture(${r}, uv);
      }
    `;let y=To(r);return t?`
    float ${a}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f}
      ${m}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${a}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} +
          depth * ${s} + depth2;
      vec2 uv = uvFromFlat(${h}, ${c}, index + ${y});
      return sampleTexture(${r}, uv);
    }
  `}function h7(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=t[4],s=t[3]*a,i=t[2]*s,o=t[1]*i,{newShape:l,keptDims:p}=w.squeezeShape(t);if(l.length<t.length){let m=Cu(e,l),g=["row","col","depth","depth2","depth3"];return`
      ${Nu(m)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${_u(g,p)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${o}, ${i}, ${s}, ${a})) +
          depth3;
        ${Tu(e)}
      }
    `;let u=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],c=d[1];if(c===o&&u==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${s}, ${a}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${c}.0, ${h}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(c===a&&u==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${c}.0, ${h}.0);
        return sampleTexture(${n}, uv);
      }
    `;let f=To(n);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} + depth * ${s} +
          depth2 * ${a} + depth3 + ${f};
      vec2 uv = uvFromFlat(${h}, ${c}, index);
      return sampleTexture(${n}, uv);
    }
  `}function c7(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:a,keptDims:s}=w.squeezeShape(t);if(a.length<t.length){let g=Cu(e,a),y=["row","col","depth","depth2","depth3","depth4"];return`
      ${Nu(g)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${_u(y,s)});
      }
    `}let i=t[5],o=t[4]*i,l=t[3]*o,p=t[2]*l,u=t[1]*p;if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${u}, ${p}, ${l}, ${o})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${Tu(e)}
      }
    `;let d=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,c=h[0],f=h[1];if(f===u&&d==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${p}, ${l}, ${o}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${c}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(f===i&&d==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${c}.0);
        return sampleTexture(${n}, uv);
      }
    `;let m=To(n);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${u} + col * ${p} + depth * ${l} +
          depth2 * ${o} + depth3 * ${i} + depth4 + ${m};
      vec2 uv = uvFromFlat(${c}, ${f}, index);
      return sampleTexture(${n}, uv);
    }
  `}function Tu(e){let t=e.name,n=w.sizeFromShape(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function f7(e,t){let n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",s=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,o=Z2(e.shapeInfo.logicalShape,t.logicalShape),l=lt(i),p=i-s,u,d=["x","y","z","w","u","v"];s===0?u="":i<2&&o.length>=1?u="coords = 0;":u=o.map(g=>`coords.${d[g+p]} = 0;`).join(`
`);let h="";i<2&&s>0?h="coords":h=e.shapeInfo.logicalShape.map((g,y)=>`coords.${d[y+p]}`).join(", ");let c="return outputValue;",f=w.sizeFromShape(e.shapeInfo.logicalShape)===1,m=w.sizeFromShape(t.logicalShape)===1;if(s===1&&!f&&!m)c=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(f&&!m)i===1?c=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:c=`
        return vec4(outputValue.x);
      `;else if(o.length){let g=s-2,y=s-1;o.indexOf(g)>-1&&o.indexOf(y)>-1?c="return vec4(outputValue.x);":o.indexOf(g)>-1?c="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(y)>-1&&(c="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${a}() {
      ${l} coords = getOutputCoords();
      ${u}
      vec4 outputValue = get${r}(${h});
      ${c}
    }
  `}function m7(e,t){let n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",s=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===l&&e.shapeInfo.flatOffset==null&&w.arraysEqual(i,s))return`
      float ${a}() {
        return sampleTexture(${n}, resultUV);
      }
    `;let p=lt(l),u=Z2(e.shapeInfo.logicalShape,t.logicalShape),d=l-o,h,c=["x","y","z","w","u","v"];o===0?h="":l<2&&u.length>=1?h="coords = 0;":h=u.map(m=>`coords.${c[m+d]} = 0;`).join(`
`);let f="";return l<2&&o>0?f="coords":f=e.shapeInfo.logicalShape.map((m,g)=>`coords.${c[g+d]}`).join(", "),`
    float ${a}() {
      ${p} coords = getOutputCoords();
      ${h}
      return get${r}(${f});
    }
  `}function lt(e){if(e<=1)return"int";if(e===2)return"ivec2";if(e===3)return"ivec3";if(e===4)return"ivec4";if(e===5)return"ivec5";if(e===6)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function Rx(e,t,n){let{newShape:r,keptDims:a}=w.squeezeShape(t),s=t.length,i=e&&s===3&&t[0]===1,o=i?t.slice(1):r,l=!e&&s>1&&!w.arraysEqual(t,n)&&r.length<s||i;return{useSqueezeShape:l,uniformShape:l?o:t,keptDims:a}}function Cu(e,t){let n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function _u(e,t){return t.map(n=>e[n]).join(", ")}function g7(e,t,n,r){let a=n.map((u,d)=>{let h={logicalShape:u.shape,texShape:u.isUniform?null:u.texData.texShape,isUniform:u.isUniform,isPacked:u.isUniform?!1:u.texData.isPacked,flatOffset:null};return u.texData!=null&&u.texData.slice!=null&&u.texData.slice.flatOffset>0&&(h.flatOffset=u.texData.slice.flatOffset),{name:t.variableNames[d],shapeInfo:h}}),s=a.map(u=>u.shapeInfo),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},o=DX(a,i,t),l=_2(e.gl,o),p=e.createProgram(l);return G().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:o,webGLProgram:p,inShapeInfos:s,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(p),Object.assign({program:t,fragmentShader:l,source:o,webGLProgram:p,inShapeInfos:s,outShapeInfo:i},Q2(e,t,p)))}function Q2(e,t,n){let r=[],a=[],s,i,o,l=null,p=null;p=e.getUniformLocation(n,"NAN",!1),G().getNumber("WEBGL_VERSION")===1&&(l=e.getUniformLocation(n,"INFINITY",!1));let u=!1;for(let d of t.variableNames){let h={name:d,uniform:e.getUniformLocation(n,d,u),offset:e.getUniformLocation(n,`offset${d}`,u)};t.enableShapeUniforms&&(h.shape=e.getUniformLocation(n,`${d}Shape`,u),h.texShape=e.getUniformLocation(n,`${d}TexShape`,u)),r.push(h)}if(t.enableShapeUniforms&&(s=e.getUniformLocation(n,"outShape",u),o=e.getUniformLocation(n,"outShapeStrides",u),i=e.getUniformLocation(n,"outTexShape",u)),t.customUniforms)for(let d of t.customUniforms)a.push(e.getUniformLocation(n,d.name,u));return{variablesLocations:r,customUniformLocations:a,infLoc:l,nanLoc:p,outShapeLocation:s,outShapeStridesLocation:o,outTexShapeLocation:i}}function Gw(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((n,r)=>{let a=n.logicalShape,s=t[r],i=s.shape;if(!w.arraysEqual(a,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${a} and ${i} must match`);if(n.isUniform&&s.isUniform)return;let o=n.texShape,l=s.isUniform?null:s.texData.texShape;if(!w.arraysEqual(o,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${l} must match`)})}function y7(e,t,n,r,a){t.program.enableShapeUniforms||(Gw(t.inShapeInfos,n),Gw([t.outShapeInfo],[r]));let s=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(s.texture,i[0],i[1]):e.setOutputMatrixTexture(s.texture,i[0],i[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),G().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&e.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&e.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<n.length;++l){let p=n[l],{uniform:u,offset:d,shape:h,texShape:c}=t.variablesLocations[l];if(h){let{uniformShape:f}=Rx(t.program.packedInputs,p.shape,p.texData.texShape);switch(f.length){case 1:e.gl.uniform1iv(h,new Int32Array(f));break;case 2:e.gl.uniform2iv(h,new Int32Array(f));break;case 3:e.gl.uniform3iv(h,new Int32Array(f));break;case 4:e.gl.uniform4iv(h,new Int32Array(f));break}}if(c&&e.gl.uniform2i(c,p.texData.texShape[0],p.texData.texShape[1]),u!=null){if(p.isUniform){if(w.sizeFromShape(p.shape)<2)e.gl.uniform1f(u,p.uniformValues[0]);else{let f=p.uniformValues;f instanceof Float32Array||(f=new Float32Array(f)),e.gl.uniform1fv(u,f)}continue}p.texData.slice!=null&&d!=null&&e.gl.uniform1i(d,p.texData.slice.flatOffset),e.setInputMatrixTexture(p.texData.texture.texture,u,l)}}let o=t.outShapeLocation;if(o)switch(r.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(r.shape));break}if(t.outShapeStridesLocation){let l=w.computeStrides(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(l));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(l));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(l));break}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&a)for(let l=0;l<t.program.customUniforms.length;++l){let p=t.program.customUniforms[l],u=t.customUniformLocations[l],d=a[l];if(p.type==="float")e.gl.uniform1fv(u,d);else if(p.type==="vec2")e.gl.uniform2fv(u,d);else if(p.type==="vec3")e.gl.uniform3fv(u,d);else if(p.type==="vec4")e.gl.uniform4fv(u,d);else if(p.type==="int")e.gl.uniform1iv(u,d);else if(p.type==="ivec2")e.gl.uniform2iv(u,d);else if(p.type==="ivec3")e.gl.uniform3iv(u,d);else if(p.type==="ivec4")e.gl.uniform4iv(u,d);else throw Error(`uniform type ${p.type} is not supported yet.`)}e.executeProgram()}function b7(e,t,n){let r="";t.concat(n).forEach(i=>{let o=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!i.isUniform){let l=i.texData.texShape,{useSqueezeShape:p,uniformShape:u,keptDims:d}=Rx(e.packedInputs,i.shape,l),h="",c="",f="";if(u.length===1&&e.packedInputs){let I=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];h=`${I[0]>1}_${I[1]>1}`}else if(u.length===2&&!e.packedInputs)c=`${u[0]>1}_${u[1]>1}`;else if(u.length>2&&!e.packedInputs){let I=w.computeStrides(u);f=`${I[0]===l[1]}_${I[I.length-1]===l[1]}`}let m=i.shape.length,g=u.length===2&&w.arraysEqual(i.shape,l),y=w.sizeFromShape(i.shape)===1,b=N.getBroadcastDims(i.shape,n.shape),x=!e.packedInputs&&m===n.shape.length&&w.arraysEqual(l,n.texData.texShape),v=e.packedInputs||u.length>2?"":`${l[0]>1}_${l[1]>1}`;r+=`${m}_${x}_${p?d:""}_${u.length}_${y}_${b}_${g}_${h}_${c}_${f}_${v}_${o}`}else{let l=i.isUniform?"uniform":i.texData.texShape;r+=`${i.shape}_${l}_${o}`}});let a=e.userCode,s=e.constructor.name;return s+="_"+r+"_"+a+`${G().getNumber("WEBGL_VERSION")}`,s}function ln(e){return G().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}var x7=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=mp.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=vn();this.outputShape=e,this.enableShapeUniforms=ln(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?mf(["r","c","d"],e):No(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}},v7=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=mp.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=vn();this.outputShape=e,this.enableShapeUniforms=ln(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?mf(["r","c","d"],e):No(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}},w7=class{constructor(e){this.variableNames=["A"],this.outTexUsage=Jn.DOWNLOAD;let t=vn();this.outputShape=e,this.userCode=`
      ${X2}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}},k7=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Jn.DOWNLOAD;let t=vn();this.outputShape=e,this.userCode=`
      ${X2}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}},I7={R:0,G:1,B:2,A:3},Hw=class{constructor(e,t=!1,n="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let r=vn();this.outputShape=e,this.enableShapeUniforms=ln(this.outputShape.length);let a="result";t&&(a="floor(result * 255. + 0.5)");let s="";for(let i=0;i<n.length;i++){let o=n[i];s+=`
          if(offset == ${i}) {
            result = values[${I7[o]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?Fx():Ax(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${n.length});

        flatIndex = idiv(flatIndex, ${n.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${s}
        }
        ${r.output} = vec4(${a}, 0., 0., 0.);
      }
    `}},S7=class{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=vn();this.outputShape=e,this.enableShapeUniforms=ln(this.outputShape.length);let r="",a="result";t&&(a="floor(result * 255. + 0.5)");for(let s=0;s<=1;s++)for(let i=0;i<=1;i++){let o=s*2+i;r+=`
          localCoords = coords;
          if(localCoords[2] + ${i} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${i};
          if (localCoords[1] + ${s} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${s};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${n.texture2D}(A, uv);

            if (offset == 0) {
              result[${o}] = values[0];
            } else if (offset == 1) {
              result[${o}] = values[1];
            } else if (offset == 2) {
              result[${o}] = values[2];
            } else {
              result[${o}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?Fx():Ax(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${n.output} = ${a};
        }
    `}},eT={};Ee(eT,{bindVertexProgramAttributeStreams:()=>uT,createBufferFromOutputTexture:()=>hT,createFloat16MatrixTexture:()=>sT,createFloat16PackedMatrixTexture:()=>lT,createFloat32MatrixTexture:()=>aT,createIndexBuffer:()=>rT,createPackedMatrixTexture:()=>oT,createUnsignedBytesMatrixTexture:()=>iT,createVertexBuffer:()=>nT,createVertexShader:()=>tT,downloadByteEncodedFloatMatrixFromOutputTexture:()=>fT,downloadFloat32MatrixFromBuffer:()=>cT,downloadMatrixFromPackedOutputTexture:()=>gT,downloadPackedMatrixFromBuffer:()=>mT,getInternalFormatForFloat16MatrixTexture:()=>Mx,getInternalFormatForFloat16PackedMatrixTexture:()=>zx,getInternalFormatForFloat32MatrixTexture:()=>Dx,getInternalFormatForPackedMatrixTexture:()=>Lx,getInternalFormatForUnsignedBytesMatrixTexture:()=>Ox,uploadDenseMatrixToTexture:()=>pT,uploadPixelDataToTexture:()=>dT});function tT(e){let t=vn(),n=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return C2(e,n)}function nT(e){let t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return A2(e,t)}function rT(e){let t=new Uint16Array([0,1,2,2,1,3]);return F2(e,t)}function vd(e,t,n,r,a,s){D2(t,n);let i=R2(e),o=e.TEXTURE_2D;return pe(e,()=>e.bindTexture(o,i)),pe(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),pe(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),pe(e,()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST)),pe(e,()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST)),G().getNumber("WEBGL_VERSION")===1?pe(e,()=>e.texImage2D(o,0,r,t,n,0,a,s,null)):pe(e,()=>e.texStorage2D(o,1,r,t,n)),pe(e,()=>e.bindTexture(e.TEXTURE_2D,null)),{texture:i,texShape:[n,t]}}function Dx(e){return e.internalFormatFloat}function aT(e,t,n,r){let[a,s]=xd(t,n);return vd(e,a,s,Dx(r),r.textureFormatFloat,e.FLOAT)}function Mx(e){return e.internalFormatHalfFloat}function sT(e,t,n,r){let[a,s]=xd(t,n);return vd(e,a,s,Mx(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function Ox(e){return e.downloadTextureFormat}function iT(e,t,n,r){let[a,s]=xd(t,n);return vd(e,a,s,Ox(r),e.RGBA,e.UNSIGNED_BYTE)}function Lx(e){return e.internalFormatPackedFloat}function oT(e,t,n,r){let[a,s]=Iu(t,n);return vd(e,a,s,Lx(r),e.RGBA,e.FLOAT)}function zx(e){return e.internalFormatPackedHalfFloat}function lT(e,t,n,r){let[a,s]=Iu(t,n);return vd(e,a,s,zx(r),e.RGBA,r.textureTypeHalfFloat)}function uT(e,t,n){return pe(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),zm(e,t,"clipSpacePos",n,3,20,0)&&zm(e,t,"uv",n,2,20,12)}function pT(e,t,n,r,a,s){pe(e,()=>e.bindTexture(e.TEXTURE_2D,t));let i,o,l;a instanceof Uint8Array?(i=new Uint8Array(n*r*4),o=e.UNSIGNED_BYTE,l=e.RGBA):(i=new Float32Array(n*r*4),o=e.FLOAT,l=s.internalFormatPackedFloat),i.set(a),G().getNumber("WEBGL_VERSION")===2?pe(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,o,i)):pe(e,()=>e.texImage2D(e.TEXTURE_2D,0,l,n,r,0,e.RGBA,o,i)),pe(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function dT(e,t,n){pe(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?G().getNumber("WEBGL_VERSION")===2?pe(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data)):pe(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):G().getNumber("WEBGL_VERSION")===2?pe(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n)):pe(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),pe(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function hT(e,t,n,r){let a=e.createBuffer();pe(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,a));let s=4*4*t*n;return pe(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,s,e.STREAM_READ)),pe(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),pe(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),a}function cT(e,t,n){let r=e,a=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,a),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),a}function fT(e,t,n,r){let[a,s]=xd(t,n),i=4,o=new Uint8Array(vX(t*n,i));return pe(e,()=>e.readPixels(0,0,a,s,r.downloadTextureFormat,e.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}function mT(e,t,n,r,a,s,i,o){let l=e,p=new Float32Array(wX(s,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,p),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),p}function gT(e,t,n){let r=new Float32Array(t*n*4);return pe(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r)),r}var dh=class{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];let t=G().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,S2(t,e)):this.gl=Tr(t),e=this.gl,G().getNumber("WEBGL_VERSION")===2){let a=e;this.createVertexArray=()=>pe(a,()=>a.createVertexArray()),this.bindVertexArray=s=>pe(a,()=>a.bindVertexArray(s)),this.deleteVertexArray=s=>pe(a,()=>a.deleteVertexArray(s)),this.getVertexArray=()=>pe(a,()=>a.getParameter(a.VERTEX_ARRAY_BINDING))}else if(e!=null){let a=e.getExtension("OES_vertex_array_object");if(a==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>pe(e,()=>a.createVertexArrayOES()),this.bindVertexArray=s=>pe(e,()=>a.bindVertexArrayOES(s)),this.deleteVertexArray=s=>pe(e,()=>a.deleteVertexArrayOES(s)),this.getVertexArray=()=>pe(e,()=>e.getParameter(a.VERTEX_ARRAY_BINDING_OES))}let n="WEBGL_color_buffer_float",r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),G().getNumber("WEBGL_VERSION")===1){let a="OES_texture_float",s="OES_texture_half_float";if(this.textureFloatExtension=qu(this.gl,a),Yn(this.gl,s))this.textureHalfFloatExtension=qu(this.gl,s);else if(G().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),Yn(this.gl,r))this.colorBufferHalfFloatExtension=qu(this.gl,r);else if(G().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",Yn(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else if(Yn(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=nT(this.gl),this.indexBuffer=rT(this.gl),this.framebuffer=M2(this.gl),this.textureConfig=Ex(this.gl,this.textureHalfFloatExtension)}get debug(){return G().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let e=this.gl;pe(e,()=>e.finish()),pe(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),pe(e,()=>e.deleteFramebuffer(this.framebuffer)),pe(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),pe(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),pe(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),aT(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),sT(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),iT(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),dT(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),pT(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),lT(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),oT(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(Pm(this.gl,this.framebuffer),this.outputTexture=null),pe(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>fT(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,r,a,s){return mT(this.gl,e,t,n,r,a,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return cT(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);let r=hT(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(G().getBool("WEBGL_FENCE_API_ENABLED")){let r=e,a=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{let s=r.clientWaitSync(a,0,0);return s===r.ALREADY_SIGNALED||s===r.CONDITION_SATISFIED},t=a}else G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>gT(this.gl,t,n))}createProgram(e){this.throwIfDisposed();let t=this.gl;this.vertexShader==null&&(this.vertexShader=tT(t));let n=E2(t);pe(t,()=>t.attachShader(n,this.vertexShader)),pe(t,()=>t.attachShader(n,e)),$2(t,n);let r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&oh(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);let t=this.gl;pe(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),uT(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(pe(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&oh(this.gl,this.program),pe(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?L2(this.gl,e,t):z2(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),pe(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),P2(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();let[r,a]=Iu(t,n);this.setOutputMatrixTextureDriver(e,r,a)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&oh(this.gl,this.program),Ku(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;if(this.debug){let t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}pe(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),pe(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=qu(this.gl,G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let n=this.gl,r=this.getQueryTimerExtensionWebGL2(),a=n.createQuery();return n.beginQuery(r.TIME_ELAPSED_EXT,a),a}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let t=this.gl,n=this.getQueryTimerExtensionWebGL2();t.endQuery(n.TIME_ELAPSED_EXT);return}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await w.repeatedTry(()=>this.disposed||this.isQueryAvailable(e,G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){let n=this.gl;return n.getQueryParameter(e,n.QUERY_RESULT)/1e6}else{let n=this.getQueryTimerExtensionWebGL1();return n.getQueryObjectEXT(e,n.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){let n=this.gl,r=this.getQueryTimerExtensionWebGL2(),a=n.getQueryParameter(e,n.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),a&&!this.disjoint}else{let n=this.getQueryTimerExtensionWebGL1(),r=n.getQueryObjectEXT(e,n.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){let e=N7(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){let{resolveFn:n}=this.itemsToPoll[t];n()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in G().platform&&(n=G().platform.setTimeoutCustom.bind(G().platform)),w.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),lh(this.gl,e,this.framebuffer),this.debug&&Ku(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(lh(this.gl,this.outputTexture,this.framebuffer),this.debug&&Ku(this.gl)):Pm(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();let r=this.gl;lh(r,e,this.framebuffer),this.debug&&Ku(r),this.outputTexture=e,pe(r,()=>r.viewport(0,0,t,n)),pe(r,()=>r.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),pe(this.gl,()=>this.gl.scissor(e,t,n,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function N7(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}var{addImpl:T7,bincountImpl:yT,bincountReduceImpl:C7,bitwiseAndImpl:_7,castImpl:E7,ceilImpl:$7,concatImpl:A7,equalImpl:F7,expImpl:R7,expm1Impl:D7,floorImpl:M7,gatherNdImpl:O7,gatherV2Impl:L7,greaterImpl:z7,greaterEqualImpl:P7,lessImpl:B7,lessEqualImpl:W7,linSpaceImpl:V7,logImpl:U7,maxImpl:G7,maximumImpl:H7,minimumImpl:j7,multiplyImpl:q7,negImpl:K7,notEqualImpl:X7,prodImpl:Z7,raggedGatherImpl:J7,raggedRangeImpl:Y7,raggedTensorToTensorImpl:Q7,rangeImpl:eZ,rsqrtImpl:tZ,scatterImpl:nZ,sigmoidImpl:rZ,simpleAbsImpl:bT,sliceImpl:aZ,sparseFillEmptyRowsImpl:sZ,sparseReshapeImpl:iZ,sparseSegmentReductionImpl:xT,sqrtImpl:oZ,staticRegexReplaceImpl:lZ,stridedSliceImpl:uZ,stringNGramsImpl:pZ,stringSplitImpl:dZ,stringToHashBucketFastImpl:hZ,subImpl:cZ,tileImpl:fZ,topKImpl:mZ,transposeImpl:Px,uniqueImpl:gZ}=cx;function vT(e,t){return["x","y","z","w","u","v"].slice(0,t).map(n=>`${e}.${n}`)}function hn(e,t){return t===1?[e]:vT(e,t)}function yZ(e,t){if(e===1)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}var bZ=class{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=ln(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let t=hn("rc",this.rank),n=lt(this.rank),r=this.getOutOfBoundsCondition(t),a=this.getSetup(t),s=this.getOutput(t);this.userCode=`
        void main() {
          ${n} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${a}

            setOutput(vec4(${s}));
          }
        }
      `}}getSourceCoordsArr(e){let t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let a=`${n===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let s=2;s<this.rank;s++)a=`${e[e.length-1-s]},`+a;t.push(a)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";let t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${n};
      bool rEdge = rp1 >= ${r};
    `}getOutput(e){let t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}},wT=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=ln(this.outputShape.length);let n="";for(let r=0;r<4;r++){let a="thisRC = rc;";r%2===1&&(a+="thisRC.z += 1;"),r>1&&(a+="thisRC.y += 1;"),n+=`
        ${a}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${xZ(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?Fx():Ax(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${n}

        setOutput(result);
      }
    `}};function xZ(e,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?RX(["r","c","d"],"inputShape"):No(["r","c","d"],e)}
      return ivec3(r, c, d);
    }
  `}var vZ=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){let r=qw(t,n),a=Kw(e,r,n);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);let s=jw(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=s,this.log();let o=this.freeTextures[a].pop();return this.usedTextures[a].push(o),o}let i;return r===tn.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===tn.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===tn.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===tn.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===tn.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[a].push(i),this.numUsedTextures++,this._numBytesAllocated+=s,this.log(),i}releaseTexture(e,t,n,r){if(this.freeTextures==null)return;let a=qw(n,r),s=Kw(t,a,r);s in this.freeTextures||(this.freeTextures[s]=[]);let i=jw(t,a,this.gpgpu.gl,this.gpgpu.textureConfig,r),o=G().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");o!==-1&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[s].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;let l=this.usedTextures[s],p=l&&l.indexOf(e);if(p==null||p<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[p]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(let e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function wZ(e,t){let n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F||t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function jw(e,t,n,r,a){let s=kZ(t,r),i;if(a){let[l,p]=Iu(e[0],e[1]);i=l*p}else{let[l,p]=xd(e[0],e[1]);i=l*p}let o=wZ(n,s);return i*o}function kZ(e,t){switch(e){case tn.PACKED_2X2_FLOAT32:return Lx(t);case tn.PACKED_2X2_FLOAT16:return zx(t);case tn.UNPACKED_FLOAT32:return Dx(t);case tn.UNPACKED_FLOAT16:return Mx(t);case tn.PACKED_4X1_UNSIGNED_BYTE:return Ox(t);default:throw new Error(`Unknown physical texture type ${e}`)}}function IZ(e){return G().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?tn.PACKED_2X2_FLOAT32:tn.UNPACKED_FLOAT32:e?tn.PACKED_2X2_FLOAT16:tn.UNPACKED_FLOAT16}function qw(e,t){if(e===Jn.UPLOAD)return tn.PACKED_2X2_FLOAT32;if(e===Jn.RENDER||e==null)return IZ(t);if(e===Jn.DOWNLOAD||e===Jn.PIXELS)return tn.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function Kw(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}var Pr=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=ln(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},fr="if (isnan(x)) return x;",SZ="return x;",Xw="return abs(x);",NZ="return (x >= 0.0) ? x : (exp(x) - 1.0);",TZ=fr+`
  return (x < 0.0) ? 0.0 : x;
`,CZ=fr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Ca="return x;",_Z="return 1.0 / (1.0 + exp(-1.0 * x));",EZ="return x;",$Z=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,AZ=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,FZ=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,RZ="return 1.0 / (1.0 + exp(-1.0 * x));",Fa=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=ln(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}},DZ=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=ln(this.outputShape.length);let t=e.length,n=hn("rc",t),r=lt(t),a=yZ(t,n),s=n.slice(-2),i=t<=1?"rc":`vec2(${s.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${a});

        setOutput(getChannel(packedInput, ${i}));
      }
    `}},MZ=Xr.whereImpl,OZ=1e-7,LZ=1e-4,Vf={};function zZ(e){return e in Vf||(Vf[e]={}),Vf[e]}var PZ=G().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),BZ=600;function WZ(){return G().global.screen==null?1024:G().global.screen.height*G().global.screen.width*window.devicePixelRatio*BZ/1024/1024}var Bx=class kT extends wp{nextDataId(){return kT.nextDataId++}constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!G().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let n;if(t!=null){if(t instanceof dh)n=t;else{let r=Tr(G().getNumber("WEBGL_VERSION"),t);n=new dh(r)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let r=Tr(G().getNumber("WEBGL_VERSION"));n=new dh(r),this.binaryCache=zZ(G().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new vZ(this.gpgpu),this.numMBBeforeWarning=WZ(),this.texData=new jh(this,lr())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,n,r,a,s,i){let o=this.makeTensorInfo(n,r),l=this.texData.get(o.dataId);l.isPacked=!1,l.texture={texture:t,texShape:[a,s]},l.texShape=[a,s];let p=Xu(n),u=new Hw(p,!1,i),d=this.runWebGLProgram(u,[o],r,[[a,s]]);return d.shape=n,l.texture=null,this.disposeIntermediateTensorInfo(o),d.dataId}write(t,n,r){if((G().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||G().getBool("DEBUG"))&&this.checkNumericalProblems(t),r==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let a={id:this.nextDataId()};return this.texData.set(a,{shape:n,dtype:r,values:t,usage:Jn.UPLOAD,refCount:1}),a}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){let n=this.texData.get(t);n.refCount++}decRef(t){if(this.texData.has(t)){let n=this.texData.get(t);n.refCount--}}move(t,n,r,a,s){if(G().getBool("DEBUG")&&this.checkNumericalProblems(n),a==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:r,dtype:a,values:n,usage:Jn.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){let n=this.texData.get(t),{values:r,dtype:a,complexTensorInfos:s,slice:i,shape:o,isPacked:l}=n;if(i!=null){let h;l?h=new Fa(o,Ca):h=new Pr(o,Ca);let c=this.runWebGLProgram(h,[{dataId:t,shape:o,dtype:a}],a),f=this.readSync(c.dataId);return this.disposeIntermediateTensorInfo(c),f}if(r!=null)return this.convertAndCacheOnCPU(t);if(a==="string")return r;let p=this.activeTimers!=null,u;p&&(u=w.now());let d;if(a==="complex64"){let h=this.readSync(s.real.dataId),c=this.readSync(s.imag.dataId);d=N.mergeRealAndImagArrays(h,c)}else d=this.getValuesFromTexture(t);return p&&(this.downloadWaitMs+=w.now()-u),this.convertAndCacheOnCPU(t,d)}async read(t){if(this.pendingRead.has(t)){let f=this.pendingRead.get(t);return new Promise(m=>f.push(m))}let n=this.texData.get(t),{values:r,shape:a,slice:s,dtype:i,complexTensorInfos:o,isPacked:l}=n;if(s!=null){let f;l?f=new Fa(a,Ca):f=new Pr(a,Ca);let m=this.runWebGLProgram(f,[{dataId:t,shape:a,dtype:i}],i),g=this.read(m.dataId);return this.disposeIntermediateTensorInfo(m),g}if(r!=null)return this.convertAndCacheOnCPU(t);if(G().getBool("DEBUG")&&!G().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&G().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let p=null,u;if(i!=="complex64"&&G().get("WEBGL_BUFFER_SUPPORTED")){u=this.decode(t);let f=this.texData.get(u.dataId);p=this.gpgpu.createBufferFromTexture(f.texture.texture,...Yd(a))}this.pendingRead.set(t,[]),i!=="complex64"&&await this.gpgpu.createAndWaitForFence();let d;if(i==="complex64"){let f=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),m=f[0],g=f[1];d=N.mergeRealAndImagArrays(m,g)}else if(p==null)d=this.getValuesFromTexture(t);else{let f=w.sizeFromShape(a);d=this.gpgpu.downloadFloat32MatrixFromBuffer(p,f)}if(u!=null&&this.disposeIntermediateTensorInfo(u),p!=null){let f=this.gpgpu.gl;pe(f,()=>f.deleteBuffer(p))}let h=this.convertAndCacheOnCPU(t,d),c=this.pendingRead.get(t);return this.pendingRead.delete(t),c.forEach(f=>f(h)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&lr().removeDataId(t,this),this.pendingDeletes--),h}readToGPU(t,n={}){let r=this.texData.get(t),{values:a,shape:s,slice:i,dtype:o,isPacked:l,texture:p}=r;if(o==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(i!=null){let c;l?c=new Fa(s,Ca):c=new Pr(s,Ca);let f=this.runWebGLProgram(c,[{dataId:t,shape:s,dtype:o}],o),m=this.readToGPU(f,n);return this.disposeIntermediateTensorInfo(f),m}if(p==null)throw a!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let u=this.decode(t,n.customTexShape),d=lr().makeTensorFromTensorInfo(u),h=this.texData.get(u.dataId);return Object.assign({tensorRef:d},h.texture)}bufferSync(t){let n=this.readSync(t.dataId);if(t.dtype==="string")try{let r=n.map(a=>w.decodeString(a));return ze(t.shape,t.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return ze(t.shape,t.dtype,n)}checkNumericalProblems(t){if(t!=null)for(let n=0;n<t.length;n++){let r=t[n];if(!N2(r))throw G().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${r} cannot be represented on this device.`)}}getValuesFromTexture(t){let{shape:n,dtype:r,isPacked:a}=this.texData.get(t),s=w.sizeFromShape(n);if(G().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let h=this.decode(t),c=this.texData.get(h.dataId),f=this.gpgpu.downloadMatrixFromPackedTexture(c.texture.texture,...Yd(n)).subarray(0,s);return this.disposeIntermediateTensorInfo(h),f}let i=G().getBool("WEBGL_PACK")&&a===!0,o=i?Xu(n):n,l=i?new k7(o):new w7(o),p=this.runWebGLProgram(l,[{shape:o,dtype:r,dataId:t}],"float32"),u=this.texData.get(p.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(p),d}timerAvailable(){return G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){let n=this.activeTimers,r=[],a=!1;this.programTimersStack==null?(this.programTimersStack=r,a=!0):this.activeTimers.push(r),this.activeTimers=r,t();let s=w.flatten(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),i=w.flatten(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=n,a&&(this.programTimersStack=null);let o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let l=await Promise.all(s);o.kernelMs=w.sum(l),o.getExtraProfileInfo=()=>l.map((p,u)=>({name:i[u],ms:p})).map(p=>`${p.name}: ${p.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:w.now(),endMs:null}}endTimer(t){return G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=w.now(),t)}async getQueryTime(t){if(G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);let n=t;return n.endMs-n.startMs}disposeData(t,n=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(n?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!n&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);let{complexTensorInfos:r}=this.texData.get(t);return r!=null&&(this.disposeData(r.real.dataId,n),this.disposeData(r.imag.dataId,n)),this.texData.delete(t),!0}releaseGPUData(t){let{texture:n,dtype:r,texShape:a,usage:s,isPacked:i,slice:o}=this.texData.get(t),l=o&&o.origDataId||t,p=this.dataRefCount.get(l);p>1?this.dataRefCount.set(l,p-1):(this.dataRefCount.delete(l),n!=null&&(this.numBytesInGPU-=this.computeBytes(a,r),this.textureManager.releaseTexture(n,a,s,i)));let u=this.texData.get(t);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,n=PZ){return G().getBool("WEBGL_CPU_FORWARD")&&t.every(r=>this.texData.get(r.dataId).texture==null&&w.sizeFromShape(r.shape)<n)}getGPGPUContext(){return this.gpgpu}where(t){N.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let n=t.dataSync();return MZ(t.shape,n)}packedUnaryOp(t,n,r){let a=new Fa(t.shape,n),s=this.compileAndRun(a,[t],r);return lr().makeTensorFromTensorInfo(s)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){let a=bT(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,a)}if(G().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,Xw,t.dtype);let n=new Pr(t.shape,Xw),r=this.compileAndRun(n,[t]);return lr().makeTensorFromTensorInfo(r)}makeTensorInfo(t,n,r){let a;if(n==="string"&&r!=null&&r.length>0&&w.isString(r[0])){let s=r.map(i=>w.encodeString(i));a=this.write(s,t,n)}else a=this.write(r,t,n);return this.texData.get(a).usage=null,{dataId:a,shape:t,dtype:n}}makeOutput(t,n,r){return lr().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,r),this)}unpackTensor(t){let n=new DZ(t.shape);return this.runWebGLProgram(n,[t],t.dtype)}packTensor(t){let n=new bZ(t.shape);return this.runWebGLProgram(n,[t],t.dtype,null,!0)}packedReshape(t,n){let r=[qs(t.shape),...Ks(t.shape)],a={dtype:t.dtype,shape:r,dataId:t.dataId},s=[qs(n),...Ks(n)],i=new wT(s,r),o=!0,l=[r],p=this.runWebGLProgram(i,[a],t.dtype,l,o);return{dataId:p.dataId,shape:n,dtype:p.dtype}}decode(t,n){let r=this.texData.get(t),{isPacked:a,shape:s,dtype:i}=r;if(n!=null){let h=w.sizeFromShape(s),c=n[0]*n[1]*4;w.assert(h<=c,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}let o=Xu(s),l;a?l=new v7(o):l=new x7(o);let p=!0,u=[n??Yd(o)],d=this.runWebGLProgram(l,[{shape:o,dtype:i,dataId:t}],i,u,p,n);return{dtype:i,shape:s,dataId:d.dataId}}runWebGLProgram(t,n,r,a,s=!1,i){let o=this.makeTensorInfo(t.outputShape,r),l=this.texData.get(o.dataId);if(t.packedOutput&&(l.isPacked=!0),t.outPackingScheme===mp.DENSE){let y=i??Yd(t.outputShape);l.texShape=y.map(b=>b*2)}if(t.outTexUsage!=null&&(l.usage=t.outTexUsage),w.sizeFromShape(o.shape)===0)return l.values=w.getTypedArrayFromDType(o.dtype,0),o;let p=[],u=n.map(y=>{if(y.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let b=this.texData.get(y.dataId);if(b.texture==null){if(!t.packedInputs&&w.sizeFromShape(y.shape)<=G().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:y.shape,texData:null,isUniform:!0,uniformValues:b.values};t.packedInputs&&(b.isPacked=!0,b.shape=y.shape)}if(this.uploadToGPU(y.dataId),!!b.isPacked!=!!t.packedInputs)y=b.isPacked?this.unpackTensor(y):this.packTensor(y),p.push(y),b=this.texData.get(y.dataId);else if(b.isPacked&&!gp(b.shape,y.shape)){let x=y,v=y.shape;y.shape=b.shape,y=this.packedReshape(y,v),p.push(y),b=this.texData.get(y.dataId),x.shape=v}return{shape:y.shape,texData:b,isUniform:!1}});this.uploadToGPU(o.dataId);let d={shape:o.shape,texData:l,isUniform:!1},h=b7(t,u,d),c=this.getAndSaveBinary(h,()=>g7(this.gpgpu,t,u,d)),f=this.activeTimers!=null,m;f&&(m=this.startTimer()),G().get("ENGINE_COMPILE_ONLY")||y7(this.gpgpu,c,u,d,a),p.forEach(y=>this.disposeIntermediateTensorInfo(y)),f&&(m=this.endTimer(m),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(m)}));let g=G().getNumber("WEBGL_FLUSH_THRESHOLD");if(g>0){let y=w.now();y-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=y)}if(!G().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&s===!1){let y=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),y}return o}compileAndRun(t,n,r,a,s=!1){return r=r||n[0].dtype,this.runWebGLProgram(t,n,r,a,s)}getAndSaveBinary(t,n){return t in this.binaryCache||(this.binaryCache[t]=n()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(G().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=B(()=>{if(!G().get("WEBGL_RENDER_FLOAT32_ENABLED")){let t=G().getBool("DEBUG");G().set("DEBUG",!1);let n=this.abs(we(1e-8)).dataSync()[0];if(G().set("DEBUG",t),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?OZ:LZ}uploadToGPU(t){let n=this.texData.get(t),{shape:r,dtype:a,values:s,texture:i,usage:o,isPacked:l}=n;if(i!=null)return;let p=this.activeTimers!=null,u;p&&(u=w.now());let d=n.texShape;if(d==null&&(d=V2(r,l),n.texShape=d),s!=null){let h=Xu(r),c,f=d[1],m=d[0],g=s instanceof Uint8Array||s instanceof Uint8ClampedArray;(l||!g)&&([f,m]=Iu(d[0],d[1])),l?c=new S7(h,g):c=new Hw(h,g);let y=g?[m,f]:d,b=this.makeTensorInfo(y,a),x=this.texData.get(b.dataId);g?x.usage=Jn.PIXELS:x.usage=Jn.UPLOAD,x.texShape=y,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(b.dataId),f,m,s);let v=[[m,f]],I=this.runWebGLProgram(c,[b],a,v,!0),T=this.texData.get(I.dataId);n.texShape=T.texShape,n.isPacked=T.isPacked,n.usage=T.usage,G().get("ENGINE_COMPILE_ONLY")?this.disposeData(I.dataId):(n.texture=T.texture,n.values=null,this.texData.delete(I.dataId)),this.disposeIntermediateTensorInfo(b),p&&(this.uploadWaitMs+=w.now()-u)}else{let h=this.acquireTexture(d,o,a,l);n.texture=h}}convertAndCacheOnCPU(t,n){let r=this.texData.get(t),{dtype:a}=r;return n!=null&&(r.values=VZ(n,a)),r.values}acquireTexture(t,n,r,a){if(this.numBytesInGPU+=this.computeBytes(t,r),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let s=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${s} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,n,a)}computeBytes(t,n){return t[0]*t[1]*w.bytesPerElement(n)}checkCompileCompletion(){for(let[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){let t=[];if(this.gpgpu.parallelCompilationExtension){for(let[,n]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(n));return Promise.all(t)}else{for(let[,n]of Object.entries(this.binaryCache)){let r=new Promise(a=>{try{this.checkCompletion_(n),a(!0)}catch(s){throw s}});t.push(r)}return Promise.all(t)}}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await Ey(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?($x(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let t of Object.values(this.binaryCache)){this.gpgpu.buildVao(t.webGLProgram);let{variablesLocations:n,customUniformLocations:r,infLoc:a,nanLoc:s,outShapeLocation:i,outShapeStridesLocation:o,outTexShapeLocation:l}=Q2(this.gpgpu,t.program,t.webGLProgram);t.variablesLocations=n,t.customUniformLocations=r,t.infLoc=a,t.nanLoc=s,t.outShapeLocation=i,t.outShapeStridesLocation=o,t.outTexShapeLocation=l}}createTensorFromGPUData(t,n,r){t.channels=t.channels||"RGBA";let{texture:a,height:s,width:i,channels:o}=t,l=lr().backend;if(!l.gpgpu.gl.isTexture(a))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let p=l.writeTexture(a,n,r,s,i,o);return lr().makeTensorFromDataId(p,n,r,l)}};Bx.nextDataId=0;function VZ(e,t){if(t==="float32"||t==="complex64")return e;if(t==="int32"||t==="bool"){let n=t==="int32"?new Int32Array(e.length):new Uint8Array(e.length);for(let r=0;r<n.length;++r)n[r]=Math.round(e[r]);return n}else throw new Error(`Unknown dtype ${t}`)}var UZ="4.22.0";function IT(){G().set("WEBGL_FORCE_F16_TEXTURES",!0)}qp.isBrowser()&&pc("webgl",()=>new Bx,2);var GZ={forceHalfFloat:IT},Wx=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,Xs=class{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=N.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=ln(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}},Co=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`,Eu=class{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=N.assertAndGetBroadcastShape(t,n);let a=this.outputShape.length;this.enableShapeUniforms=ln(a);let s="";if(r)if(a===0||w.sizeFromShape(this.outputShape)===1)s=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(s=`
          ${lt(a)} coords = getOutputCoords();
        `,a===1)this.enableShapeUniforms?s+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:s+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let i=hn("coords",a);this.enableShapeUniforms?s+=`
            bool nextRowOutOfBounds =
              (${i[a-2]} + 1) >= outShape[${a} - 2];
            bool nextColOutOfBounds =
              (${i[a-1]} + 1) >= outShape[${a} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:s+=`
            bool nextRowOutOfBounds =
              (${i[a-2]} + 1) >= ${this.outputShape[a-2]};
            bool nextColOutOfBounds =
              (${i[a-1]} + 1) >= ${this.outputShape[a-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${s}

        setOutput(result);
      }
    `}};function Gn(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var HZ={kernelName:_i,backendName:"webgl",kernelFunc:Gn};function ls(e){let{inputs:t,backend:n}=e,{real:r,imag:a}=t,s=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(s.dataId),o=Gn({inputs:{x:r},backend:n}),l=Gn({inputs:{x:a},backend:n});return i.complexTensorInfos={real:o,imag:l},s}var jZ={kernelName:Xh,backendName:"webgl",kernelFunc:ls},ST="return (a < 0.) ? b * a : a;",NT=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function qZ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:s}=r,i=n.makeTensorInfo([],"float32",w.createScalarValue(s,"float32")),o=G().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Eu(NT,a.shape,i.shape):new Xs(ST,a.shape,i.shape),l=n.runWebGLProgram(o,[a,i],"float32");return n.disposeIntermediateTensorInfo(i),l}var KZ={kernelName:Fi,backendName:"webgl",kernelFunc:qZ},TT="return (a < 0.) ? b * a : a;",CT=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function XZ(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t,s=G().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Eu(CT,r.shape,a.shape):new Xs(TT,r.shape,a.shape);return n.runWebGLProgram(s,[r,a],"float32")}var ZZ={kernelName:Ki,backendName:"webgl",kernelFunc:XZ},$u="if (isnan(x)) return x;";function Ke({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:a,backend:s})=>{let{x:i}=a,o=s,l=r||i.dtype;if(o.shouldExecuteOnCPU([i])&&n!=null){let d=o.texData.get(i.dataId),h=n(d.values,l);return o.makeTensorInfo(i.shape,l,h)}let p=G().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null,u;return p?u=new Fa(i.shape,t):u=new Pr(i.shape,e),o.runWebGLProgram(u,[i],l)}}function rn({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:a,dtype:s}){return({inputs:i,backend:o})=>{let{a:l,b:p}=i,u=o;if(r&&l.dtype==="complex64"){let f=u.texData.get(l.dataId),m=u.texData.get(p.dataId),[g,y]=[[f.complexTensorInfos.real,m.complexTensorInfos.real],[f.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(x=>{let[v,I]=x,T={dataId:v.dataId,dtype:v.dtype,shape:l.shape},_={dataId:I.dataId,dtype:I.dtype,shape:p.shape},E=new Xs(e,l.shape,p.shape);return u.runWebGLProgram(E,[T,_],tr(v.dtype,I.dtype))}),b=ls({inputs:{real:g,imag:y},backend:u});return u.disposeIntermediateTensorInfo(g),u.disposeIntermediateTensorInfo(y),b}let d=s||tr(l.dtype,p.dtype);if((l.dtype==="string"||p.dtype==="string"||u.shouldExecuteOnCPU([l,p]))&&a!=null){let f=u.texData.get(l.dataId).values,m=u.texData.get(p.dataId).values,g=l.dtype==="string"?N.fromUint8ToStringArray(f):f,y=l.dtype==="string"?N.fromUint8ToStringArray(m):m,[b,x]=a(l.shape,p.shape,g,y,d),v=u.makeTensorInfo(x,d),I=u.texData.get(v.dataId);return I.values=b,v}let h=G().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null,c;return h?c=new Eu(t,l.shape,p.shape,n):c=new Xs(e,l.shape,p.shape),u.runWebGLProgram(c,[l,p],d)}}function yp(e,t=!1){if(e==="linear")return t?EZ:SZ;if(e==="relu")return t?AZ:TZ;if(e==="elu")return t?$Z:NZ;if(e==="relu6")return t?FZ:CZ;if(e==="prelu")return t?CT:TT;if(e==="leakyrelu")return t?NT:ST;if(e==="sigmoid")return t?RZ:_Z;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}var _T=class{constructor(e,t,n,r=!1,a=!1,s=!1,i=null,o=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=ln(this.outputShape.length);let p=r?e[1]:e[2],u=Math.ceil(p/2),d=r?"i * 2, rc.y":"rc.y, i * 2",h=a?"rc.z, i * 2":"i * 2, rc.z",c=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],m="",g="";i&&(o?m=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${i}
        }`:l?m=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${i}
        }`:m=`vec4 activation(vec4 x) {
          ${i}
        }`,g="result = activation(result);");let y=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let b="rc.x",x="rc.x";e[0]<t[0]?b=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(x=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${m}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${u}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${b};
        int batchB = ${x};
        for (int i = 0; i < ${u}; i++) {
          vec4 a = getMatrixA(batchA, ${d});
          vec4 b = getMatrixB(batchB, ${h});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${c[0]} * ${f[0]});
          result += (${c[1]} * ${f[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${y}

        ${g}

        setOutput(result);
      }
    `}},Zw={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},Jw=class{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=N.assertAndGetBroadcastShape(t,n),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}},Yw="return a * b;";function Vx(e){let{inputs:t,backend:n}=e,{a:r,b:a}=t,s=N.upcastType(r.dtype,a.dtype);if(r.dtype==="complex64"){let o=n.texData.get(r.dataId),l=n.texData.get(a.dataId),p=new Jw(Zw.REAL,r.shape,a.shape),u=new Jw(Zw.IMAG,r.shape,a.shape),d=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:r.shape},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:a.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:a.shape}],h=n.runWebGLProgram(p,d,"float32"),c=n.runWebGLProgram(u,d,"float32"),f=ls({inputs:{real:h,imag:c},backend:n});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(c),f}if(n.shouldExecuteOnCPU([r,a])){let o=n.texData.get(r.dataId),l=n.texData.get(a.dataId),[p,u]=q7(r.shape,a.shape,o.values,l.values,s),d=n.makeTensorInfo(u,s),h=n.texData.get(d.dataId);return h.values=p,d}let i;return G().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new Eu(Yw,r.shape,a.shape):i=new Xs(Yw,r.shape,a.shape),n.runWebGLProgram(i,[r,a],s)}var JZ={kernelName:Gi,backendName:"webgl",kernelFunc:Vx};function YZ(e,t,n){let r=[qs(e.shape),...Ks(e.shape)],a={dtype:e.dtype,shape:r,dataId:e.dataId},s=[qs(t),...Ks(t)],i=new wT(s,r),o=!0,l=[r],p=n.runWebGLProgram(i,[a],e.dtype,l,o);return{dataId:p.dataId,shape:t,dtype:p.dtype}}function ue(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:s}=r,i=n,o=w.sizeFromShape(a.shape),l=w.inferFromImplicitShape(s,o),p=w.sizeFromShape(l);w.assert(o===p,()=>`The new shape (${l}) has ${p} elements and the old shape (${a.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);let u=i.texData.get(a.dataId);return u.isPacked&&!gp(a.shape,l)&&!(u.texture!==null&&gp(u.shape,l))?YZ(a,l,i):(i.incRef(a.dataId),{dataId:a.dataId,shape:l,dtype:a.dtype})}var QZ={kernelName:Kl,backendName:"webgl",kernelFunc:ue},Qw=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];let i=Math.floor(n/4)*4,o=n%4,l="sumValue += dot(values, ones);";if(t!=null){let u=1/t;l=`sumValue += dot(values * ${w.isInt(u)?u.toPrecision(2):u}, ones);`}let p="";a%n>0&&(p=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        float sumValue = 0.0;

        for (int i = 0; i < ${i}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${i};
        if (${o===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l}
        } else if (${o===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l}
        } else if (${o===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l}
        }
        setOutput(sumValue);
      }
    `}},eJ=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];let i="0.0",o="";t==="prod"?i="1.0":t==="min"?(i="1.0 / 1e-20",o="min"):t==="max"&&(i="-1.0 / 1e-20",o="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?l="sumValue":t==="prod"?l="prodValue":t==="all"?l="allValue":t==="any"&&(l="anyValue");let p=Math.floor(n/4)*4,u=n%4,d=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${o}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${o}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,h="vec4";t==="all"?(i="1.0",d=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,h="bvec4"):t==="any"&&(i="0.0",d=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,h="bvec4");let c="";a%n>0&&(c=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${i};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        vec4 minMaxValue = vec4(${i});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${p}; i += 4) {
          int inIdx = inOffset + i;
          ${h} values = ${h}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${d}
        }

        int inIdx = inOffset + ${p};
        if (${u===1}) {
          ${h} values = ${h}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${u===2}) {
          ${h} values = ${h}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${u===3}) {
          ${h} values = ${h}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${d}
        }
        setOutput(${l});
      }
    `}};function tJ(e){let t=[];for(;t.length===0||t[t.length-1].outSize!==1;){let n=t.length?t[t.length-1].outSize:e[1],r=N.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}function _o(e,t,n,r){let a=tJ(e.shape),s=e;for(let i=0;i<a.length;i++){let{inSize:o,windowSize:l,outSize:p}=a[i],u,d;n==="mean"?u=i===0?new Qw({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:p},o):new Qw({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:p}):u=new eJ({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:p},n),d=s,s=r.runWebGLProgram(u,[s],t),d.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(d)}return s}var nJ=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[t[s]];this.outputShape=n,this.rank=n.length;let r=lt(this.rank),a=rJ(t);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${a}));
    }
    `}};function rJ(e){let t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let a=0;a<e.length;a++)r[e[a]]=n[a];return r.join()}var aJ=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let n=new Array(e.length);for(let p=0;p<n.length;p++)n[p]=e[t[p]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let r=lt(this.rank),a=vT("rc",this.rank),s=new Array(this.rank);for(let p=0;p<t.length;p++)s[t[p]]=a[p];let i=`vec2(${s.slice(-2).join()})`,o=`++${a[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${s.join()}), ${i})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${l};
      if(${o}) {
        result[1] = ${l};
      }
      --${a[this.rank-1]};
      if(++${a[this.rank-2]} < ${n[this.rank-2]}) {
        result[2] = ${l};
        if(${o}) {
          result[3] = ${l};
        }
      }
      setOutput(result);
    }
    `}};function gf(e,t,n){let r=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new aJ(e.shape,t):new nJ(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function sJ(e,t,n,r){let a=t,s=e.shape.length,i=w.parseAxisParam(a,e.shape),o=i,l=N.getAxesPermutation(o,s),p=l!=null,u=e;p&&(u=gf(e,l,r),o=N.getInnerMostAxes(o.length,s)),N.assertAxesAreInnerMostDims("sum",o,s);let[d,h]=N.computeOutAndReduceShapes(u.shape,o),c=d;n&&(c=N.expandShapeToKeepDim(d,i));let f=w.sizeFromShape(h),m=w.sizeFromShape(e.shape)/f,g=ue({inputs:{x:u},attrs:{shape:[m,f]},backend:r}),y=uc(e.dtype),b=_o(g,y,"sum",r),x=ue({inputs:{x:b},attrs:{shape:c},backend:r});return r.disposeIntermediateTensorInfo(g),r.disposeIntermediateTensorInfo(b),p&&r.disposeIntermediateTensorInfo(u),x}function yf(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;return sJ(a,s,i,n)}var iJ={kernelName:ho,backendName:"webgl",kernelFunc:yf};function mn(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{perm:s}=r,i=n,o=a.shape.length,l=new Array(o);for(let u=0;u<l.length;u++)l[u]=a.shape[s[u]];let p;if(i.shouldExecuteOnCPU([a])){let u=i.texData.get(a.dataId).values,d=Px(u,a.shape,a.dtype,s,l);p=i.makeTensorInfo(l,a.dtype);let h=i.texData.get(p.dataId);h.values=d}else p=gf(a,s,i);return p}var oJ={kernelName:sa,backendName:"webgl",kernelFunc:mn},ET=1e3;function Lh({a:e,b:t,transposeA:n,transposeB:r,backend:a,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){let p=e.shape.length,u=t.shape.length,d=n?e.shape[p-2]:e.shape[p-1],h=r?t.shape[u-1]:t.shape[u-2],c=n?e.shape[p-1]:e.shape[p-2],f=r?t.shape[u-2]:t.shape[u-1],m=e.shape.slice(0,-2),g=t.shape.slice(0,-2),y=w.sizeFromShape(m),b=w.sizeFromShape(g),x=hu.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([c,f]);w.assert(d===h,()=>`Error in matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`);let v=n?[y,d,c]:[y,c,d],I=r?[b,f,h]:[b,h,f],T=ue({inputs:{x:e},backend:a,attrs:{shape:v}}),_=ue({inputs:{x:t},backend:a,attrs:{shape:I}}),E=[T,_],A=Math.max(y,b),R=n?T.shape[1]:T.shape[2],F=s!=null,S=i!=null,M=l==="leakyrelu",W=l!=null?yp(l,!0):null,U=F||S||M||W!=null,H;if((c===1||f===1)&&R>ET&&U===!1){let j=T,Z=_;n&&(j=mn({inputs:{x:T},backend:a,attrs:{perm:[0,2,1]}}),E.push(j)),r&&(Z=mn({inputs:{x:_},backend:a,attrs:{perm:[0,2,1]}}),E.push(Z));let ee=f!==1,Y=f===1,re=j;ee&&(re=ue({inputs:{x:j},backend:a,attrs:{shape:[A,R,1]}}),E.push(re));let te=f===1?2:1,ae=Z;Y&&(ae=ue({inputs:{x:Z},backend:a,attrs:{shape:[A,1,R]}}),E.push(ae));let ie=Vx({inputs:{a:re,b:ae},backend:a});H=yf({inputs:{x:ie},backend:a,attrs:{axis:te,keepDims:!0}}),E.push(ie)}else{let j=tr(e.dtype,t.dtype),Z=new _T(v,I,[A,c,f],n,r,F,W,S,M),ee=[T,_];if(s!=null&&ee.push(s),S&&ee.push(i),M){let Y=a.makeTensorInfo([],"float32",w.createScalarValue(o,"float32"));ee.push(Y),E.push(Y)}H=a.runWebGLProgram(Z,ee,j)}let K=ue({inputs:{x:H},backend:a,attrs:{shape:x}});E.push(H);for(let j of E)a.disposeIntermediateTensorInfo(j);return K}function lJ(e){let{inputs:t,backend:n,attrs:r}=e,{a,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:p,activation:u,leakyreluAlpha:d}=r;return Lh({a,b:s,transposeA:l,transposeB:p,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:d,activation:u})}var uJ={kernelName:Fs,backendName:"webgl",kernelFunc:lJ},e0="return abs(x);";function pJ(e){let{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){let s=n.texData.get(r.dataId),i=bT(s.values);return n.makeTensorInfo(r.shape,r.dtype,i)}let a;return G().getBool("WEBGL_PACK_UNARY_OPERATIONS")?a=new Fa(r.shape,e0):a=new Pr(r.shape,e0),n.runWebGLProgram(a,[r],r.dtype)}var dJ={kernelName:pl,backendName:"webgl",kernelFunc:pJ},hJ=fr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,cJ=Ke({opSnippet:hJ}),fJ={kernelName:Qs,backendName:"webgl",kernelFunc:cJ},mJ=fr+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,gJ=Ke({opSnippet:mJ}),yJ={kernelName:ei,backendName:"webgl",kernelFunc:gJ},t0="return a + b;",bJ=rn({opSnippet:t0,packedOpSnippet:t0,supportsComplex:!0,cpuKernelImpl:T7}),xJ={kernelName:Ya,backendName:"webgl",kernelFunc:bJ},vJ=class{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((a,s)=>`T${s}`);let n=[];this.variableNames.forEach(a=>{n.push(`float v${a} = get${a}AtOutCoords();`)});let r=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}},wJ=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((a,s)=>`T${s}`);let n=[];this.variableNames.forEach(a=>{n.push(`vec4 v${a} = get${a}AtOutCoords();`)});let r=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}};function hh(e){let{inputs:t,backend:n}=e,r=t;if(r.length===1)return Gn({inputs:{x:r[0]},backend:n});if(r.length>G().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let o=Math.floor(r.length/2),l=hh({inputs:r.slice(0,o),backend:n}),p=hh({inputs:r.slice(o),backend:n});return hh({inputs:[l,p],backend:n})}let a=r.map(o=>o.dtype).reduce((o,l)=>tr(o,l)),s=r.map(o=>o.shape),i=G().getBool("WEBGL_PACK")?new wJ(r[0].shape,s):new vJ(r[0].shape,s);return n.runWebGLProgram(i,r,a)}var kJ={kernelName:ti,backendName:"webgl",kernelFunc:hh};function IJ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=w.parseAxisParam(s,a.shape),p=l,u=N.getAxesPermutation(p,o),d=a;u!=null&&(d=mn({inputs:{x:a},backend:n,attrs:{perm:u}}),p=N.getInnerMostAxes(p.length,o)),N.assertAxesAreInnerMostDims("all",p,o);let[h,c]=N.computeOutAndReduceShapes(d.shape,p),f=w.sizeFromShape(c),m=ue({inputs:{x:d},backend:n,attrs:{shape:[-1,f]}}),g=_o(m,m.dtype,"all",n),y;if(i){let b=N.expandShapeToKeepDim(h,l);y=ue({inputs:{x:g},backend:n,attrs:{shape:b}})}else y=ue({inputs:{x:g},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),u!=null&&n.disposeIntermediateTensorInfo(d),y}var SJ={kernelName:dl,backendName:"webgl",kernelFunc:IJ};function NJ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=w.parseAxisParam(s,a.shape),p=l,u=N.getAxesPermutation(p,o),d=a;u!=null&&(d=mn({inputs:{x:a},backend:n,attrs:{perm:u}}),p=N.getInnerMostAxes(p.length,o)),N.assertAxesAreInnerMostDims("any",p,o);let[h,c]=N.computeOutAndReduceShapes(d.shape,p),f=w.sizeFromShape(c),m=ue({inputs:{x:d},backend:n,attrs:{shape:[-1,f]}}),g=_o(m,m.dtype,"any",n),y;if(i){let b=N.expandShapeToKeepDim(h,l);y=ue({inputs:{x:g},backend:n,attrs:{shape:b}})}else y=ue({inputs:{x:g},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),u!=null&&n.disposeIntermediateTensorInfo(d),y}var TJ={kernelName:hl,backendName:"webgl",kernelFunc:NJ},CJ=class{constructor(e,t,n){this.variableNames=["A"];let{windowSize:r,batchSize:a,outSize:s}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[a,s];let i=t==="max"?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${o};
          float candidate = getA(batch, inIdx);
          if (candidate ${i} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}},_J=class{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,w.assert(e.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);let a=e[e.length-1],s=Math.ceil(a/t);this.outputShape=e.slice(0,-1),s>1&&this.outputShape.push(s),r||this.variableNames.push("bestIndicesA");let i=this.outputShape,o=i.length,l=lt(o),p=hn("coords",o),u,d;if(s===1){d=o+1;let _=lt(d);u=`
        ${_} sourceLocR = ${_}(${p.join()}, 0);
        ++${p[o-1]};
        ${_} sourceLocG = ${_}(${p.join()}, 0);
        ++${p[o-2]};
        ${_} sourceLocA = ${_}(${p.join()}, 0);
        --${p[o-1]};
        ${_} sourceLocB = ${_}(${p.join()}, 0);
        --${p[o-2]};`}else d=o,u=`
        ${l} sourceLocR = coords;
        ++${p[o-1]};
        ${l} sourceLocG = coords;
        ++${p[o-2]};
        ${l} sourceLocA = coords;
        --${p[o-1]};
        ${l} sourceLocB = coords;
        --${p[o-2]};`;let h=["x","y","z","w","u","v"].slice(0,d),c="."+h[d-1],f=h.map(_=>"int "+_),m=hn("sourceLocR",d-1).concat("inIdx.r"),g=hn("sourceLocG",d-1).concat("inIdx.g"),y=hn("sourceLocB",d-1).concat("inIdx.b"),b=hn("sourceLocA",d-1).concat("inIdx.a"),x=n==="max"?"greaterThan":"lessThan",v=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),
                             getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${b.join()})));`,I=`vec4(
            getAChannel(${m.join()}),
            hasNextCol ? getAChannel(${g.join()}) : 0.,
            hasNextRow ? getAChannel(${y.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,T=r?"":`
      float getBestIndicesAChannel(${f.join()}) {
        return getChannel(getBestIndicesA(${h.join()}),
                                          vec2(${h.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${f.join()}) {
        return getChannel(getA(${h.join()}),
                               vec2(${h.slice(-2).join()}));
      }
      ${T}
      void main() {
        ${l} coords = getOutputCoords();
        bool hasNextCol = ${p[o-1]} < ${i[o-1]-1};
        bool hasNextRow = ${p[o-2]} < ${i[o-2]-1};
        ${u}
        ivec4 srcIdx = ivec4(sourceLocR${c}, sourceLocG${c},
          sourceLocB${c}, sourceLocA${c}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${I};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${v}
          vec4 candidate = ${I};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${x}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function $T(e,t,n,r=null){let a=t.shape[0],s=t.shape[1];r!=null&&(a=r.shape[0],s=r.shape[1]);let i=N.computeOptimalWindowSize(s),o={windowSize:i,inSize:s,batchSize:a,outSize:Math.ceil(s/i)},l=new CJ(o,n,r==null),p=[t];r!=null&&p.push(r);let u=e.runWebGLProgram(l,p,"int32");if(u.shape[1]===1)return u;let d=$T(e,t,n,u);return e.disposeIntermediateTensorInfo(u),d}function AT(e,t,n,r=null){let a=r!=null?r.shape:t.shape,s=a[a.length-1],i=N.computeOptimalWindowSize(s),o=new _J(a,i,n,r==null),l=r==null?[t]:[t,r],p=e.runWebGLProgram(o,l,"int32");if(p.shape.length===t.shape.length){let u=AT(e,t,n,p);return e.disposeIntermediateTensorInfo(p),u}return p}function FT(e,t,n,r){let a=[n];if(N.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),a,t.shape.length),!G().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let s=[],i=e.texData.get(t.dataId),o=i!==null&&i.isPacked,l=t;o&&(l=e.unpackTensor(t),s.push(l));let[p,u]=N.computeOutAndReduceShapes(l.shape,a),d=w.sizeFromShape(u),h=ue({inputs:{x:l},backend:e,attrs:{shape:[-1,d]}});s.push(h);let c=$T(e,h,r);s.push(c);let f=ue({inputs:{x:c},backend:e,attrs:{shape:p}});return s.forEach(m=>e.disposeIntermediateTensorInfo(m)),f}return AT(e,t,r)}function EJ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r,i=w.parseAxisParam(s,a.shape),o=N.getAxesPermutation(i,a.shape.length),l=a,p=[];o!=null&&(l=mn({inputs:{x:a},backend:n,attrs:{perm:o}}),p.push(l),i=N.getInnerMostAxes(i.length,l.shape.length)),N.assertAxesAreInnerMostDims("argMax",[i[0]],l.shape.length);let u=FT(n,l,i[0],"max");return p.forEach(d=>n.disposeIntermediateTensorInfo(d)),u}var $J={kernelName:cl,backendName:"webgl",kernelFunc:EJ};function AJ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r,i=w.parseAxisParam(s,a.shape),o=N.getAxesPermutation(i,a.shape.length),l=a,p=[];o!=null&&(l=mn({inputs:{x:a},backend:n,attrs:{perm:o}}),p.push(l),i=N.getInnerMostAxes(i.length,l.shape.length)),N.assertAxesAreInnerMostDims("argMin",[i[0]],l.shape.length);let u=FT(n,l,i[0],"min");return p.forEach(d=>n.disposeIntermediateTensorInfo(d)),u}var FJ={kernelName:fl,backendName:"webgl",kernelFunc:AJ},RJ=fr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,DJ=Ke({opSnippet:RJ}),MJ={kernelName:ni,backendName:"webgl",kernelFunc:DJ},OJ=fr+"return log(x + sqrt(x * x + 1.0));",LJ=Ke({opSnippet:OJ}),zJ={kernelName:ri,backendName:"webgl",kernelFunc:LJ},PJ=fr+`
  return atan(x);
`,BJ=Ke({opSnippet:PJ}),WJ={kernelName:ai,backendName:"webgl",kernelFunc:BJ},VJ=Wx+`
  return atan(a, b);
`,UJ=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Co+`
  return result;
`,GJ=rn({opSnippet:VJ,packedOpSnippet:UJ}),HJ={kernelName:ii,backendName:"webgl",kernelFunc:GJ},jJ=fr+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,qJ=Ke({opSnippet:jJ}),KJ={kernelName:si,backendName:"webgl",kernelFunc:qJ},bp=class{constructor(e,t,n,r=!1,a=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let s=e.filterWidth,i=e.strideHeight,o=e.strideWidth,l=e.dilationHeight,p=e.dilationWidth,u=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=e.padInfo.top,c=e.padInfo.left;this.outputShape=e.outShape;let f=t==="avg",m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`,y="0.0";if(f||(y="-1.0 / 1e-20"),n){let _=">=";this.userCode=`
        const ivec2 strides = ivec2(${i}, ${o});
        const ivec2 pads = ivec2(${h}, ${c});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${u};
              wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d};
                wC += ${p}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${_} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?a?m:g:`wR * ${d} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let b="max",x=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(x="avgValue / max(count, 1.0)");let v=Math.floor(s/4)*4,I=s%4,T=`
      if (${f}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${b}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${o});
      const ivec2 pads = ivec2(${h}, ${c});
      const float initializationValue = ${y};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${y});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${u};
            wR += ${l}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${v}; wC += 4) {
            int xC = xCCorner + wC * ${p};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${p}, d),
              getValue(batch, xR, xC + 2 * ${p}, d),
              getValue(batch, xR, xC + 3 * ${p}, d)
            );

            ${T}
          }

          int xC = xCCorner + ${v};
          if (${I===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${T}
          } else if (${I===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${p}, d),
              initializationValue,
              initializationValue
            );

            ${T}
          } else if (${I===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${p}, d),
              getValue(batch, xR, xC + 2 * ${p}, d),
              initializationValue
            );

            ${T}
          }
        }
        setOutput(${x});
      }
    `}},Ux=class{constructor(e,t,n,r=!1,a=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let s=e.filterWidth,i=e.strideDepth,o=e.strideHeight,l=e.strideWidth,p=e.dilationDepth,u=e.dilationHeight,d=e.dilationWidth,h=e.effectiveFilterDepth,c=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;let b=t==="avg",x="0.0";if(b||(x="-1.0 / 1e-20"),n){let A=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${i}, ${o}, ${l});
        const ivec3 pads = ivec3(${m}, ${g}, ${y});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${h};
              wD += ${p}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${c};
                wR += ${u}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${f};
                  wC += ${d}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${A} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?a?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${c} * ${f} +
                      wR * ${f} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let v="max",I=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(I="avgValue / max(count, 1.0)");let T=Math.floor(s/4)*4,_=s%4,E=`
      if (${b}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${v}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${i}, ${o}, ${l});
      const ivec3 pads = ivec3(${m}, ${g}, ${y});
      const float initializationValue = ${x};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${x});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${p}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${c};
            wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${T}; wC += 4) {
              int xC = xCCorner + wC * ${d};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                getValue(batch, xD, xR, xC + 3 * ${d}, ch)
              );

              ${E}
            }

            int xC = xCCorner + ${T};
            if (${_===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${E}
            } else if (${_===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                initializationValue,
                initializationValue
              );

              ${E}
            } else if (${_===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                initializationValue
              );

              ${E}
            }
          }
        }
        setOutput(${I});
      }
    `}};function XJ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;Su(a,"avgPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r,p=1;w.assert(N.eitherStridesOrDilationsAreOne(i,p),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${p}'`);let u=N.computePool2DInfo(a.shape,s,i,p,o,l);if(u.filterWidth===1&&u.filterHeight===1&&w.arraysEqual(u.inShape,u.outShape))return Gn({inputs:{x:a},backend:n});let d=new bp(u,"avg",!1);return n.runWebGLProgram(d,[a],"float32")}var ZJ={kernelName:oi,backendName:"webgl",kernelFunc:XJ};function JJ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:p}=r,u=[1,1,1],d=N.computePool3DInfo(a.shape,s,i,u,o,l,p),h=new Ux(d,"avg",!1);return n.runWebGLProgram(h,[a],"float32")}var YJ={kernelName:ml,backendName:"webgl",kernelFunc:JJ},QJ=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,l=e.effectiveFilterWidth,p=o-1-e.padInfo.top,u=l-1-e.padInfo.left,d=1/(t*n);this.userCode=`
      const ivec2 pads = ivec2(${p}, ${u});
      const float avgMultiplier = float(${d});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o};
            wR += ${s}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l};
            wC+= ${i}) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},e9=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,p=e.dilationWidth,u=e.effectiveFilterDepth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,c=u-1-e.padInfo.front,f=d-1-e.padInfo.top,m=h-1-e.padInfo.left,g=1/(t*n*r);this.userCode=`
      const ivec3 pads = ivec3(${c}, ${f}, ${m});
      const float avgMultiplier = float(${g});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${u};
            wD += ${o}) {
          float dyD = float(dyDCorner + wD) / ${a}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${d};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${h};
                wC += ${p}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function t9(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s,{filterSize:o,strides:l,pad:p,dimRoundingMode:u}=r,d=[1,1,1],h=N.computePool3DInfo(i.shape,o,l,d,p,u),c=new e9(h);return n.runWebGLProgram(c,[a],i.dtype)}var n9={kernelName:Sp,backendName:"webgl",kernelFunc:t9};function r9(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s;Su([a,s],"avgPoolGrad");let{filterSize:o,strides:l,pad:p}=r,u=N.computePool2DInfo(i.shape,o,l,1,p),d=new QJ(u);return n.runWebGLProgram(d,[a],i.dtype)}var a9={kernelName:Ip,backendName:"webgl",kernelFunc:r9};function s9(e){let{inputs:t,backend:n,attrs:r}=e,{a,b:s}=t,{transposeA:i,transposeB:o}=r;return Lh({a,b:s,transposeA:i,transposeB:o,backend:n})}var i9={kernelName:li,backendName:"webgl",kernelFunc:s9},o9=class{constructor(e,t,n,r,a,s){this.outputShape=[],this.variableNames=["x","mean","variance"],N.assertAndGetBroadcastShape(e,t),N.assertAndGetBroadcastShape(e,n);let i="0.0";r!=null&&(N.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="1.0";a!=null&&(N.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${i};
        float scale = ${o};
        float inv = scale * inversesqrt(variance + float(${s}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}},l9=class{constructor(e,t,n,r,a,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],N.assertAndGetBroadcastShape(e,t),N.assertAndGetBroadcastShape(e,n);let i="vec4(0.0)";r!=null&&(N.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="vec4(1.0)";a!=null&&(N.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${i};
        vec4 scale = ${o};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${s}));

        setOutput((x - mean) * inv + offset);
      }
    `}},u9=({inputs:e,backend:t,attrs:n})=>{let{x:r,mean:a,variance:s,offset:i,scale:o}=e;w.assert(a.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),w.assert(i==null||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),w.assert(o==null||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=n;l==null&&(l=.001);let p=[r,a,s],u=null;i!=null&&(u=i.shape,p.push(i));let d=null;o!=null&&(d=o.shape,p.push(o));let h=G().getBool("WEBGL_PACK_NORMALIZATION")?new l9(r.shape,a.shape,s.shape,u,d,l):new o9(r.shape,a.shape,s.shape,u,d,l);return t.runWebGLProgram(h,p,p[0].dtype)},p9={kernelName:Ti,backendName:"webgl",kernelFunc:u9},d9=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;let t=lt(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n=h9(this.rank),r,a=e.map((s,i)=>`sourceLoc.${Vm[i]} = start[${i}] + coords.${Vm[i]};`);r=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${a.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${n}));
      }
    `}},Vm=["x","y","z","w","u","v"];function h9(e){if(e===1)return"sourceLoc";if(e<=6)return Vm.slice(0,e).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}var c9=class{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let t=lt(this.rank),n=hn("coords",this.rank),r=hn("sourceLoc",this.rank),a=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,s=`getChannel(getSource(${r.join()}), ${a})`,i=`
      result.x = ${s};
      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${s};
        --${r[this.rank-1]};
      }
    `,o=this.rank===1?"":`
      --${n[this.rank-1]};
      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${s};
        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${s};
        }
      }
    `,l=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((p,u)=>`start[${u}]`).join()});`:e.map((p,u)=>`${r[u]} = ${n[u]} + start[${u}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${l}
        vec4 result = vec4(0.);
        ${i}
        ${o}
        setOutput(result);
      }
    `}};function f9(e,t,n,r){let a=r.texData.get(e.dataId),s=r.makeTensorInfo(n,e.dtype),i=r.texData.get(s.dataId);Object.assign(i,a),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=Lt.computeFlatOffset(t,w.computeStrides(e.shape));a.slice&&(o+=a.slice.flatOffset),i.slice={flatOffset:o,origDataId:a.slice&&a.slice.origDataId||e.dataId};let l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),s}function Au(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,size:i}=r,[o,l]=Lt.parseSliceParams(a,s,i);if(Lt.assertParamsValid(a,o,l),w.sizeFromShape(l)===0)return n.makeTensorInfo(l,a.dtype,[]);if(n.shouldExecuteOnCPU([a])||a.dtype==="string"){let d=n.texData.get(a.dataId),h=aZ(d.values,o,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,h)}let{isPacked:p}=n.texData.get(a.dataId),u=Lt.isSliceContinous(a.shape,o,l);if(p||!u){let d=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new c9(l):new d9(l),h=[o];return n.runWebGLProgram(d,[a],a.dtype,h)}return n.uploadToGPU(a.dataId),f9(a,o,l,n)}var m9={kernelName:tu,backendName:"webgl",kernelFunc:Au},g9=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r;w.assert(a.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let o=s.reduce((b,x)=>b*x),l=N.getReshaped(a.shape,s,o),p=N.getPermuted(l.length,s.length),u=N.getReshapedPermuted(a.shape,s,o),d=N.getSliceBeginCoords(i,s.length),h=N.getSliceSize(u,i,s.length),c=[],f=ue({inputs:{x:a},backend:n,attrs:{shape:l}}),m=mn({inputs:{x:f},backend:n,attrs:{perm:p}}),g=ue({inputs:{x:m},backend:n,attrs:{shape:u}}),y=Au({inputs:{x:g},backend:n,attrs:{begin:d,size:h}});return c.push(f),c.push(m),c.push(g),c.forEach(b=>n.disposeIntermediateTensorInfo(b)),y},y9={kernelName:gl,backendName:"webgl",kernelFunc:g9};function b9(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i}=r,o=n.readSync(a.dataId),l=n.readSync(s.dataId),p=yT(o,l,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,p)}var x9={kernelName:yl,backendName:"webgl",kernelFunc:b9},v9=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,w9=`
  return float(int(a.r) & int(b.r));
`;function k9(e){let{inputs:t,backend:n}=e,{a:r,b:a}=t,s=G().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=G().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([r,a])||i===1){let l=n.texData.get(r.dataId).values,p=n.texData.get(a.dataId).values,[u,d]=_7(r.shape,a.shape,l,p,r.dtype),h=n.makeTensorInfo(d,r.dtype),c=n.texData.get(h.dataId);return c.values=u,h}let o;return s?o=new Eu(v9,r.shape,a.shape,!1):o=new Xs(w9,r.shape,a.shape),n.runWebGLProgram(o,[r,a],r.dtype)}var I9={kernelName:bl,backendName:"webgl",kernelFunc:k9};function S9(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.readSync(r.dataId),i=n.readSync(a.dataId),o=N.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}var N9={kernelName:Np,backendName:"webgl",kernelFunc:S9},T9="return float(a != b);",RT=rn({opSnippet:T9,cpuKernelImpl:X7,dtype:"bool"}),C9={kernelName:Vl,backendName:"webgl",kernelFunc:RT};function wd(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.texData.get(r.dataId);return Gn({inputs:{x:a.complexTensorInfos.real},backend:n})}var _9={kernelName:oc,backendName:"webgl",kernelFunc:wd},E9="return float(int(x));";function $9(e,t){let n=new Pr(e.shape,E9),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}function Um(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dtype:s}=r;if(s==="complex64"){if(a.dtype==="complex64")return Gn({inputs:{x:a},backend:n});let i=vt(a.shape),o=Um({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),l=ls({inputs:{real:o,imag:i},backend:n});return i.dispose(),n.disposeIntermediateTensorInfo(o),l}if(a.dtype==="complex64"){let i=wd({inputs:{input:a},backend:n}),o=Um({inputs:{x:i},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(i),o}if(!w.hasEncodingLoss(a.dtype,s)){let i=Gn({inputs:{x:a},backend:n});return{dataId:i.dataId,shape:i.shape,dtype:s}}if(n.shouldExecuteOnCPU([a])){let i=n.texData.get(a.dataId).values,[o,l,p]=E7(i,a.shape,a.dtype,s);return n.makeTensorInfo(o,l,p)}if(s==="int32")return $9(a,n);if(s==="bool"){let i=n.makeTensorInfo([],"bool",w.getTypedArrayFromDType("bool",1)),o=RT({inputs:{a,b:i},backend:n});return n.disposeIntermediateTensorInfo(i),o}throw new Error(`Error in Cast: failed to cast ${a.dtype} to ${s}`)}var A9={kernelName:ui,backendName:"webgl",kernelFunc:Um},n0="return ceil(x);",F9=Ke({opSnippet:n0,packedOpSnippet:n0,cpuKernelImpl:$7}),R9={kernelName:pi,backendName:"webgl",kernelFunc:F9},D9=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}},M9=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};function O9(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{clipValueMin:s,clipValueMax:i}=r,o;G().getBool("WEBGL_PACK_CLIP")?o=new M9(a.shape):o=new D9(a.shape);let l=[[s],[i]];return n.runWebGLProgram(o,[a],a.dtype,l)}var L9={kernelName:Qa,backendName:"webgl",kernelFunc:O9},z9=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function r0(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}function P9(e){let{inputs:t,backend:n}=e,{x:r}=t,a=n.texData.get(r.dataId),s=new z9(r.shape),i=[r0(r,a.complexTensorInfos.real),r0(r,a.complexTensorInfos.imag)];return n.runWebGLProgram(s,i,i[0].dtype)}var B9={kernelName:Tp,backendName:"webgl",kernelFunc:P9},W9=class{constructor(e){this.outputShape=[],this.outputShape=N.computeOutShape(e,1),this.variableNames=e.map((s,i)=>`T${i}`);let t=new Array(e.length-1);t[0]=e[0][1];for(let s=1;s<t.length;s++)t[s]=t[s-1]+e[s][1];let n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let s=1;s<t.length;s++){let i=t[s-1];n.push(`else if (yC < ${t[s]}) setOutput(getT${s}(yR, yC-${i}));`)}let r=t.length,a=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${a}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n.join(`
        `)}
      }
    `}},V9=class{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=N.computeOutShape(e,t);let n=this.outputShape,r=n.length,a=lt(r),s=hn("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((f,m)=>`T${m}`);let o=new Array(e.length-1);o[0]=e[0][t];for(let f=1;f<o.length;f++)o[f]=o[f-1]+e[f][t];let l=i[t],p=i.slice(-2),u=i.join(),d=`if (${l} < ${o[0]}) {
        return getChannel(
            getT0(${u}), vec2(${p.join()}));
        }`;for(let f=1;f<o.length;f++){let m=o[f-1];d+=`
        if (${l} < ${o[f]}  && ${l} >= ${o[f-1]}) {
          return getChannel(
            getT${f}(${eh(i,l,m)}),
            vec2(${eh(p,l,m)}));
        }`}let h=o.length,c=o[o.length-1];d+=`
        return getChannel(
          getT${h}(${eh(i,l,c)}),
          vec2(${eh(p,l,c)}));`,this.userCode=`
      float getValue(${i.map(f=>"int "+f)}) {
        ${d}
      }

      void main() {
        ${a} coords = getOutputCoords();
        vec4 result = vec4(getValue(${s}), 0., 0., 0.);

        ${s[r-1]} = ${s[r-1]} + 1;
        if (${s[r-1]} < ${n[r-1]}) {
          result.g = getValue(${s});
        }

        ${s[r-2]} = ${s[r-2]} + 1;
        if (${s[r-2]} < ${n[r-2]}) {
          result.a = getValue(${s});
        }

        ${s[r-1]} = ${s[r-1]} - 1;
        if (${s[r-2]} < ${n[r-2]} &&
            ${s[r-1]} < ${n[r-1]}) {
          result.b = getValue(${s});
        }
        setOutput(result);
      }
    `}};function eh(e,t,n){let r=e.indexOf(t);return e.map((a,s)=>s===r?`${a} - ${n}`:a).join()}function bf(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.texData.get(r.dataId);return Gn({inputs:{x:a.complexTensorInfos.imag},backend:n})}var U9={kernelName:rc,backendName:"webgl",kernelFunc:bf};function Zu(e,t,n){let r=e[0].dtype;if(r==="complex64"){let c=e.map(b=>wd({inputs:{input:b},backend:n})),f=e.map(b=>bf({inputs:{input:b},backend:n})),m=Zu(c,t,n),g=Zu(f,t,n),y=ls({inputs:{real:m,imag:g},backend:n});return c.forEach(b=>n.disposeIntermediateTensorInfo(b)),f.forEach(b=>n.disposeIntermediateTensorInfo(b)),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),y}let a=n.shouldExecuteOnCPU(e);if(r==="string"&&(a=!0),a){let c=e.map(v=>{let I=[-1,w.sizeFromShape(v.shape.slice(t))];return ue({inputs:{x:v},backend:n,attrs:{shape:I}})}),f=c.map(v=>({vals:n.readSync(v.dataId),shape:v.shape})),m=N.computeOutShape(c.map(v=>v.shape),1),g=c[0].shape[0]===1,y=A7(f,m,r,g),b=N.computeOutShape(e.map(v=>v.shape),t),x=n.makeTensorInfo(b,r,y);return c.forEach(v=>n.disposeIntermediateTensorInfo(v)),x}let s=e.filter(c=>w.sizeFromShape(c.shape)>0),i=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(s.length===1){let c=i?new Pr(e[0].shape,Ca):new Fa(e[0].shape,Ca);return n.runWebGLProgram(c,e,r)}let o=G().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>o){let c=[];for(let m=0;m<s.length;m+=o){let g=s.slice(m,m+o);c.push(Zu(g,t,n))}let f=Zu(c,t,n);for(let m of c)n.disposeIntermediateTensorInfo(m);return f}if(i){let c=new V9(s.map(f=>f.shape),t);return n.runWebGLProgram(c,s,r)}let{tensors2D:l,outShape:p}=G9(s,t,n),u=new W9(l.map(c=>c.shape)),d=n.runWebGLProgram(u,l,r);l.forEach(c=>n.disposeIntermediateTensorInfo(c));let h=ue({inputs:{x:d},attrs:{shape:p},backend:n});return n.disposeIntermediateTensorInfo(d),h}function G9(e,t,n){let r=N.computeOutShape(e.map(a=>a.shape),t);return{tensors2D:e.map(a=>ue({inputs:{x:a},attrs:{shape:[-1,w.sizeFromShape(a.shape.slice(t))]},backend:n})),outShape:r}}function DT(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,s=w.parseAxisParam(a,t[0].shape)[0],i=t.map(p=>p.shape);N.assertParamsConsistent(i,s);let o=N.computeOutShape(t.map(p=>p.shape),s);if(w.sizeFromShape(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter(p=>w.sizeFromShape(p.shape)>0);return l.length===1?Gn({inputs:{x:l[0]},backend:n}):Zu(l,s,n)}var H9={kernelName:xl,backendName:"webgl",kernelFunc:DT},MT=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;let s=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,l=e.strideWidth,p=e.dilationHeight,u=e.dilationWidth,d=e.filterHeight,h=e.filterWidth,c=Math.floor(e.inChannels/4)*4,f=e.inChannels%4,m=e.dataFormat==="channelsLast",g=m?1:2,y=m?2:3,b=m?3:1,x="",v="";n&&(r?x=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:a?x=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:x=`
          float activation(float x) {
            ${n}
          }
        `,v="result = activation(result);");let I=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${x}

      const ivec2 strides = ivec2(${o}, ${l});
      const ivec2 pads = ivec2(${s}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${b}];

        ivec2 xRCCorner =
            ivec2(coords[${g}], coords[${y}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${d}; wR++) {
          int xR = xRCorner + wR * ${p};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${h}; wC++) {
            int xC = xCCorner + wC * ${u};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${c}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${m}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${f===1}) {

              if (${m}) {
                dotProd +=
                    getX(batch, xR, xC, ${c}) *
                    getW(wR, wC, ${c}, d2);
              } else {
                dotProd +=
                    getX(batch, ${c}, xR, xC) *
                    getW(wR, wC, ${c}, d2);
              }

            } else if (${f===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${c}, d2),
                getW(wR, wC, ${c} + 1, d2)
              );

              if (${m}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${c}),
                  getX(batch, xR, xC, ${c} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${c}, xR, xC),
                  getX(batch, ${c} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${f===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${c}, d2),
                getW(wR, wC, ${c} + 1, d2),
                getW(wR, wC, ${c} + 2, d2)
              );

              if (${m}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${c}),
                  getX(batch, xR, xC, ${c} + 1),
                  getX(batch, xR, xC, ${c} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${c}, xR, xC),
                  getX(batch, ${c} + 1, xR, xC),
                  getX(batch, ${c} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${I}
        ${v}
        setOutput(result);
      }
    `}},j9=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,p=e.dilationWidth,u=e.filterDepth,d=e.filterHeight,h=e.filterWidth,c=Math.floor(e.inChannels/4)*4,f=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${a}, ${s}, ${i});
      const ivec3 pads = ivec3(${t}, ${n}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${u}; wF++) {
          int xF = xFCorner + wF * ${o};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d}; wR++) {
            int xR = xRCorner + wR * ${l};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${h}; wC++) {
              int xC = xCCorner + wC * ${p};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${c}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${f===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${c}) *
                  getW(wF, wR, wC, ${c}, d2);
              } else if (${f===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${c}),
                  getX(batch, xF, xR, xC, ${c} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${c}, d2),
                  getW(wF, wR, wC, ${c} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${f===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${c}),
                  getX(batch, xF, xR, xC, ${c} + 1),
                  getX(batch, xF, xR, xC, ${c} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${c}, d2),
                  getW(wF, wR, wC, ${c} + 1, d2),
                  getW(wF, wR, wC, ${c} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},OT=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=ln(this.outputShape.length);let s=e.padInfo.left,i=e.strideWidth,o=e.dilationWidth,l=e.filterHeight,p=e.filterWidth,u=p,d=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let m=0;m<p;m++)d+=`
           vec4 xTexelC${m*2};
           int xTexelC${m*2}Ready;
           vec4 xTexelC${m*2+1};
           int xTexelC${m*2+1}Ready;
           vec4 xC${m};`;d+=`
     for (int r = 0; r < ${l}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let m=0;m<p;m++)d+=`
           xTexelC${m*2} = vec4(0.0);
           xTexelC${m*2}Ready = 0;
           xTexelC${m*2+1} = vec4(0.0);
           xTexelC${m*2+1}Ready = 0;
           xC${m} = vec4(0.0);`;d+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let m=0;m<(u+1)/2;m++){let g=m*2;if(d+=`
           xC = xCCorner + ${g*o};
           `,i===1){if(g<p&&(s%2===1?(d+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }
               `,o===1&&g>0?d+=`
                 xC${g} = vec4(xTexelC${g-2}.zw, xTexelC${g}.xy);
                 `:d+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${g} = vec4(previous.zw, xTexelC${g}.xy);
                   } else {
                     xC${g} = vec4(0.0, 0.0, xTexelC${g}.xy);
                   }
                   `):d+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 xC${g} = xTexelC${g};
                 `,g+1<p)){let y=s%2===0?w.nearestLargerEven(o):o;o%2===0&&s%2===1||o%2!==0&&s%2!==1?(d+=`
                   xCOffset = xC + imod(pads[1], 2) + ${y};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {
                     xTexelC${g+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${g+1}.zw = vec2(0.0);
                     }
                     xTexelC${g+1}Ready = 1;
                   }
                   `,o>1?d+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${g+1} = vec4(previous.zw, xTexelC${g+1}.xy);
                     } else {
                      xC${g+1} = vec4(0.0, 0.0, xTexelC${g+1}.xy);
                     }
                     `:d+=`
                     xC${g+1} = vec4(xTexelC${g}.zw, xTexelC${g+1}.xy);
                     `):y===1?d+=`
                     xC${g+1} = xTexelC${g};
                     `:d+=`
                     xCOffset = xC + ${y};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {
                       xTexelC${g+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${g+1}.zw = vec2(0.0);
                       }
                       xTexelC${g+1}Ready = 1;
                     }

                     xC${g+1} = xTexelC${g+1};
                     `}}else g<p&&(s%2===1?(d+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${g+1}Ready == 0) {
                   xTexelC${g+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${g+1}.zw = vec2(0.0);
                   }
                   xTexelC${g+1}Ready = 1;
                 }

                 xC${g} = vec4(xTexelC${g}.zw, xTexelC${g+1}.zw);
               `,g+1<p&&(d+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${g+1} = vec4(xTexelC${g+1}.xy, final.xy);
                 `)):(d+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {
                   xTexelC${g+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g+1}.zw = vec2(0.);
                   }
                   xTexelC${g+1}Ready = 1;
                 }

                 xC${g} = vec4(
                   xTexelC${g}.xy, xTexelC${g+1}.xy);
               `,g+1<p&&(d+=`
                   xC${g+1} = vec4(xTexelC${g}.zw, xTexelC${g+1}.zw);
                 `)));g<p&&(d+=`
             wTexel = getW(r, ${g}, d1, d2);
             dotProd += xC${g}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${g}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,g+1<p&&(d+=`
               wTexel = getW(r, ${g+1}, d1, d2);
               dotProd += xC${g+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${g+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}d+=`
     }
   `,d+=`
     }
   `,d+=`
     }
   `;let h="",c="";n&&(r?h=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${n}
         }`:a?h=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${n}
         }`:h=`vec4 activation(vec4 x) {
           ${n}
         }`,c="result = activation(result);");let f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${h}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${d}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${f}
         ${c}
         setOutput(result);
       }
     `}},q9=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=ln(this.outputShape.length);let{dataFormat:n}=t,r=vn(),a=n==="channelsLast",s=a?1:2,i=a?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`,l="";for(let p=0;p<=1;p++)for(let u=0;u<=1;u++)l+=`
          blockIndex = rc.z + ${u};
          pos = rc.y + ${p};

          ${o}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${s}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${i}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${a}) {
                  innerDims = vec2(d1, ch);
                  result[${p*2+u}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${p*2+u}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l}

        ${r.output} = result;
      }
    `}};function zh(e,t){let n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&n===1&&e[0]>1?[e[0],1]:null}function LT({x:e,filter:t,convInfo:n,backend:r,bias:a=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:o=null}){let l=e.shape,p=r.texData.get(e.dataId),u=n.inChannels,d=l[0]*l[1]*l[2],h=n.outChannels,c=n.dataFormat==="channelsLast",f=!1,m=!1,g,y=[];if(s!=null){let b=zh(s.shape,c);b!=null&&(s=ue({inputs:{x:s},backend:r,attrs:{shape:b}}),y.push(s))}if(a!=null){let b=zh(a.shape,c);b!=null&&(a=ue({inputs:{x:a},backend:r,attrs:{shape:b}}),y.push(a))}if(!((d===1||h===1)&&u>ET)&&p.isPacked&&c&&p.texture!=null&&l[2]%2!==0&&w.arraysEqual(p.shape.slice(-3),l.slice(-3))){let b=l[0]*l[1]*(l[2]+1),x={dataId:e.dataId,shape:[1,b,n.inChannels],dtype:e.dtype},v=p.shape;p.shape=p.shape.slice(),p.shape[p.shape.length-2]++,w.assert(gp(p.shape,x.shape),()=>`packed reshape ${p.shape} to ${x.shape} isn't free`);let I=ue({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});y.push(I);let T=Lh({a:x,b:I,backend:r,transposeA:f,transposeB:m,bias:a,activation:o,preluActivationWeights:s,leakyreluAlpha:i}),_=r.texData.get(T.dataId);w.assert(_.isPacked,()=>"batchMatMul result is expected to be packed"),p.shape=v,_.shape=n.outShape,g=Gn({inputs:{x:T},backend:r}),g.shape=n.outShape,y.push(T)}else{let b=n.outHeight*n.outWidth,x=ue({inputs:{x:e},backend:r,attrs:{shape:c?[n.batchSize,b,n.inChannels]:[n.batchSize,n.inChannels,b]}}),v=ue({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),I=Lh({a:c?x:v,b:c?v:x,transposeA:!c,transposeB:m,backend:r,bias:a,activation:o,preluActivationWeights:s,leakyreluAlpha:i});g=ue({inputs:{x:I},backend:r,attrs:{shape:n.outShape}}),y.push(x),y.push(v),y.push(I)}for(let b of y)r.disposeIntermediateTensorInfo(b);return g}function zT({x:e,filter:t,convInfo:n,backend:r,bias:a=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:o=null}){let{filterWidth:l,filterHeight:p,inChannels:u,outWidth:d,outHeight:h,dataFormat:c}=n,f=c==="channelsLast",m=l*p*u,g=h*d,y=[n.batchSize,m,g],b=!0,x=!1,v=[];if(s!=null){let j=zh(s.shape,f);j!=null&&(s=ue({inputs:{x:s},backend:r,attrs:{shape:j}}),v.push(s))}if(a!=null){let j=zh(a.shape,f);j!=null&&(a=ue({inputs:{x:a},backend:r,attrs:{shape:j}}),v.push(a))}let I=ue({inputs:{x:t},backend:r,attrs:{shape:[1,m,w.sizeFromShape(t.shape)/m]}});v.push(I);let T=new q9(y,n),_=[e.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],E=r.runWebGLProgram(T,[e],"float32",_),A=ue({inputs:{x:E},backend:r,attrs:{shape:y}});v.push(E),v.push(A);let R=a!=null,F=s!=null,S=o==="leakyrelu",M=o?yp(o,!0):null,W=new _T(f?A.shape:I.shape,f?I.shape:A.shape,f?[n.batchSize,g,n.outChannels]:[n.batchSize,n.outChannels,g],b,x,R,M,F,S),U=f?[A,I]:[I,A];if(a&&U.push(a),F&&U.push(s),S){let j=r.makeTensorInfo([],"float32",w.createScalarValue(i,"float32"));U.push(j),v.push(j)}let H=r.runWebGLProgram(W,U,"float32"),K=ue({inputs:{x:H},backend:r,attrs:{shape:n.outShape}});v.push(H);for(let j of v)r.disposeIntermediateTensorInfo(j);return K}function K9(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dataFormat:l,dilations:p,dimRoundingMode:u}=r,d=N.convertConv2DDataFormat(l),h=N.computeConv2DInfo(a.shape,s.shape,i,p,o,u,!1,d),c;if(h.filterHeight===1&&h.filterWidth===1&&h.dilationHeight===1&&h.dilationWidth===1&&h.strideHeight===1&&h.strideWidth===1&&(h.padInfo.type==="SAME"||h.padInfo.type==="VALID"))c=LT({x:a,filter:s,convInfo:h,backend:n});else if(h.strideWidth<=2&&d==="channelsLast"&&G().getBool("WEBGL_EXP_CONV")){let m=new OT(h),g=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];c=n.runWebGLProgram(m,[a,s],"float32",g)}else if(G().getBool("WEBGL_CONV_IM2COL"))c=zT({x:a,filter:s,convInfo:h,backend:n});else{let m=new MT(h);c=n.runWebGLProgram(m,[a,s],"float32")}let f=ue({inputs:{x:c},backend:n,attrs:{shape:h.outShape}});return n.disposeIntermediateTensorInfo(c),f}var X9={kernelName:di,backendName:"webgl",kernelFunc:K9},Z9=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,s=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${a};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${s?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}},J9=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=e.dataFormat==="channelsLast",i=t-1-e.padInfo.top,o=n-1-e.padInfo.left,l=s?1:2,p=s?2:3,u=s?3:1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${u}];

        ivec2 dyCorner = ivec2(coords[${l}], coords[${p}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${s}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},Y9=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.padInfo.front,s=e.padInfo.top,i=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${a};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${n} - ${s};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${i};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Q9=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,l=n-1-e.padInfo.top,p=r-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${o}, ${l}, ${p});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${a}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${n}; wR++) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function eY(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:p,filterShape:u}=r,d=N.convertConv2DDataFormat(l),h=N.computeConv2DInfo(a.shape,u,i,1,o,p,!1,d),c=new Z9(h);return n.runWebGLProgram(c,[a,s],"float32")}var tY={kernelName:Zh,backendName:"webgl",kernelFunc:eY},nY=class{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=ln(this.outputShape.length);let t=e.filterHeight,n=e.filterWidth,r=t-1-e.padInfo.top,a=n-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            int wCPerm = ${n} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}};function rY(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:p,dimRoundingMode:u}=r,d=N.convertConv2DDataFormat(p),h=N.computeConv2DInfo(i,s.shape,o,1,l,u,!1,d);if(G().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&d==="channelsLast"){let c=[[h.strideHeight,h.strideWidth]],f=new nY(h);return n.runWebGLProgram(f,[a,s],"float32",c)}else{let c=new J9(h);return n.runWebGLProgram(c,[a,s],"float32")}}var aY={kernelName:hi,backendName:"webgl",kernelFunc:rY};function sY(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r,p=N.computeConv3DInfo(a.shape,s.shape,i,l,o),u=new j9(p);return n.runWebGLProgram(u,[a,s],"float32")}var iY={kernelName:ci,backendName:"webgl",kernelFunc:sY};function oY(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r,p=N.computeConv3DInfo(a.shape,l,i,1,o),u=new Y9(p);return n.runWebGLProgram(u,[a,s],"float32")}var lY={kernelName:vl,backendName:"webgl",kernelFunc:oY};function uY(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r,p=N.computeConv3DInfo(l,s.shape,o,1,i),u=new Q9(p);return n.runWebGLProgram(u,[a,s],"float32")}var pY={kernelName:wl,backendName:"webgl",kernelFunc:uY},dY=$u+`
  return cos(x);
`,hY=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Co}
  return result;
`,cY=Ke({opSnippet:dY,packedOpSnippet:hY}),fY={kernelName:fi,backendName:"webgl",kernelFunc:cY},mY=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,gY=Ke({opSnippet:mY}),yY={kernelName:mi,backendName:"webgl",kernelFunc:gY},bY=class{constructor(e,t,n,r,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[s,i,o,l]=e,[p]=t,[u,d]=n;this.outputShape=[p,u,d,l];let h=r==="bilinear"?1:0,[c,f]=[`${i-1}.0`,`${o-1}.0`],[m,g,y]=u>1?[`${(i-1)/(u-1)}`,"(y2-y1) * height_ratio",`y1*${c} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${c}`],[b,x,v]=d>1?[`${(o-1)/(d-1)}`,"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`
      const float height_ratio = float(${m});
      const float width_ratio = float(${b});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${s}) {
          return;
        }

        float height_scale = ${g};
        float width_scale = ${x};

        float in_y = ${y};
        if( in_y < 0.0 || in_y > ${c} ) {
          setOutput(float(${a}));
          return;
        }
        float in_x = ${v};
        if( in_x < 0.0 || in_x > ${f} ) {
          setOutput(float(${a}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${h} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}},xY=e=>{let{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:p}=r,u=new bY(a.shape,s.shape,o,l,p);return n.runWebGLProgram(u,[a,s,i],"float32")},vY={kernelName:Il,backendName:"webgl",kernelFunc:xY},xp;(function(e){e.Prod="*",e.Sum="+"})(xp||(xp={}));var a0=class{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];let a=this.outputShape.length,s=this.op===xp.Prod?"1.0":"0.0",i=n?s:`getX(${s0(a,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1],l="",p="";n?(l=r?`end != ${o-1}`:"end != 0",p=r?"end + 1":"end - 1"):(l=r?`end + pow2 < ${o}`:"end >= pow2",p=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${lt(a)} coords = getOutputCoords();
        int end = ${i0(a,"coords",this.op)};
        float val = ${i};
        int pow2 = int(pow(2.0, index));
        if (${l}) {
          int idx = ${p};
          ${i0(a,"coords",this.op)} = idx;
          val ${this.op}= getX(${s0(a,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function s0(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.x, ${t}.y`;if(e===3)return`${t}.x, ${t}.y, ${t}.z`;if(e===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function i0(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.y`;if(e===3)return`${t}.z`;if(e===4)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function PT(e,t,n,r,a,s){let i=t.shape.length,o=N.getAxesPermutation([r],i),l=t;o!=null&&(l=mn({inputs:{x:t},backend:n,attrs:{perm:o}}));let p=N.getInnerMostAxes(1,i)[0];if(p!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);let u=l.shape[p],d=Gn({inputs:{x:l},backend:n});for(let h=0;h<=Math.ceil(Math.log2(u))-1;h++){let c=new a0(e,l.shape,!1,s),f=[[h]],m=d;d=n.runWebGLProgram(c,[d],d.dtype,f),n.disposeIntermediateTensorInfo(m)}if(a){let h=new a0(e,l.shape,a,s),c=d;d=n.runWebGLProgram(h,[d],d.dtype),n.disposeIntermediateTensorInfo(c)}if(o!=null){let h=N.getUndoAxesPermutation(o),c=mn({inputs:{x:d},backend:n,attrs:{perm:h}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(l),c}return d}function wY(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;return PT(xp.Prod,a,n,s,i,o)}var kY={kernelName:kl,backendName:"webgl",kernelFunc:wY};function IY(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;return PT(xp.Sum,a,n,s,i,o)}var SY={kernelName:gi,backendName:"webgl",kernelFunc:IY};function NY(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i,binaryOutput:o}=r;if(a.shape.length===1){let l=n.readSync(a.dataId),p=n.readSync(s.dataId),u=yT(l,p,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,u)}else if(a.shape.length===2){let l=n.bufferSync(a),p=n.bufferSync(s),u=C7(l,p,i,o);return n.makeTensorInfo(u.shape,s.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}var TY={kernelName:Cp,backendName:"webgl",kernelFunc:NY},CY=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function _Y(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:s,dataFormat:i}=r,o=a.shape[0],l=i==="NHWC"?a.shape[1]:a.shape[2],p=i==="NHWC"?a.shape[2]:a.shape[3],u=i==="NHWC"?a.shape[3]:a.shape[1],d=l*s,h=p*s,c=u/(s*s),f=i==="NHWC"?[o,d,h,c]:[o,c,d,h],m=new CY(f,s,i);return n.runWebGLProgram(m,[a],a.dtype)}var EY={kernelName:Sl,backendName:"webgl",kernelFunc:_Y},BT=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=ln(this.outputShape.length);let s=e.filterHeight,i=e.filterWidth,o=e.outChannels/e.inChannels,l="",p="";n&&(r?l=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:a?l=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:l=`
          float activation(float x) {
            ${n}
          }
        `,p="result = activation(result);");let u=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${s}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${i}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${u}
        ${p}
        setOutput(result);
      }
    `}},WT=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=ln(this.outputShape.length);let s=e.outChannels/e.inChannels,i=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,p=e.filterHeight,u=e.filterWidth,d=u,h=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<u;g++)h+=`
          vec4 xTexelC${g*2};
          int xTexelC${g*2}Ready;
          vec4 xTexelC${g*2+1};
          int xTexelC${g*2+1}Ready;
          vec4 xC${g};`;h+=`
    for (int r = 0; r < ${p}; r++) {
      `;for(let g=0;g<u;g++)h+=`
          xTexelC${g*2} = vec4(0.0);
          xTexelC${g*2}Ready = 0;
          xTexelC${g*2+1} = vec4(0.0);
          xTexelC${g*2+1}Ready = 0;
          xC${g} = vec4(0.0);`;h+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let g=0;g<(d+1)/2;g++){let y=g*2;if(h+=`
          xC = xCCorner + ${y*l};
          `,o===1){if(y<u&&(i%2===1?(h+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }
              `,l===1&&y>0?h+=`
                xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);
                `:h+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                  } else {
                    xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                  }
                  `):h+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                xC${y} = xTexelC${y};
                `,y+1<u)){let b=i%2===0?w.nearestLargerEven(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(h+=`
                  xCOffset = xC + imod(pads[1], 2) + ${b};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                    xTexelC${y+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${y+1}.zw = vec2(0.0);
                    }
                    xTexelC${y+1}Ready = 1;
                  }
                  `,l>1?h+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);
                    } else {
                     xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);
                    }
                    `:h+=`
                    xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);
                    `):b===1?h+=`
                    xC${y+1} = xTexelC${y};
                    `:h+=`
                    xCOffset = xC + ${b};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                      xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${y+1}.zw = vec2(0.0);
                      }
                      xTexelC${y+1}Ready = 1;
                    }

                    xC${y+1} = xTexelC${y+1};
                    `}}else y<u&&(i%2===1?(h+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {
                  xTexelC${y+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${y+1}.zw = vec2(0.0);
                  }
                  xTexelC${y+1}Ready = 1;
                }

                xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
              `,y+1<u&&(h+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);
                `)):(h+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                  xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y+1}.zw = vec2(0.);
                  }
                  xTexelC${y+1}Ready = 1;
                }

                xC${y} = vec4(
                  xTexelC${y}.xy, xTexelC${y+1}.xy);
              `,y+1<u&&(h+=`
                  xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
                `)));y<u&&(h+=`
            wTexel = getW(r, ${y}, d1, q);
            dotProd += xC${y} * vec4(wTexel.xz, wTexel.xz);
          `,y+1<u&&(h+=`
              wTexel = getW(r, ${y+1}, d1, q);
              dotProd += xC${y+1} * vec4(wTexel.xz, wTexel.xz);
            `))}h+=`
    }
  `,h+=`
      }
    `;let c="",f="";n&&(r?c=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:a?c=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:c=`vec4 activation(vec4 x) {
          ${n}
        }`,f="result = activation(result);");let m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${c}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${s};
        int q = d2 - d1 * ${s};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${h}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${m}
        ${f}
        setOutput(result);
      }
    `}};function $Y(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:p}=r,u=l;u==null&&(u=[1,1]),w.assert(N.eitherStridesOrDilationsAreOne(i,u),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let d=N.computeConv2DInfo(a.shape,s.shape,i,u,o,p,!0),h;G().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels===1?h=new WT(d):h=new BT(d);let c=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return n.runWebGLProgram(h,[a,s],"float32",c)}var AY={kernelName:yi,backendName:"webgl",kernelFunc:$Y},FY=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${s} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${a};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},RY=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=t-1-e.padInfo.top,i=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${s}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${o}; dm++) {
              int d2 = d1 * ${o} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function DY(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:p,filterShape:u}=r,d=N.computeConv2DInfo(a.shape,u,i,o,l,p,!0),h=new FY(d);return n.runWebGLProgram(h,[a,s],"float32")}var MY={kernelName:Jh,backendName:"webgl",kernelFunc:DY};function OY(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:p,inputShape:u}=r,d=N.computeConv2DInfo(u,s.shape,i,o,l,p,!0),h=new RY(d);return n.runWebGLProgram(h,[a,s],"float32")}var LY={kernelName:Yh,backendName:"webgl",kernelFunc:OY},zY=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function PY(e){let{inputs:t,backend:n}=e,{x:r}=t,a=[...r.shape,...r.shape],s=w.sizeFromShape(r.shape),i=ue({inputs:{x:r},backend:n,attrs:{shape:[s]}}),o=new zY(s),l=n.runWebGLProgram(o,[i],i.dtype),p=ue({inputs:{x:l},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),p}var BY={kernelName:_p,backendName:"webgl",kernelFunc:PY},WY=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let{inHeight:t,inWidth:n,padInfo:r,strideHeight:a,strideWidth:s,filterHeight:i,filterWidth:o,dilationHeight:l,dilationWidth:p}=e,{top:u,left:d}=r;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${s});
      const ivec2 pads = ivec2(${u}, ${d});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${i}; h++) {
          int hIn = hBeg + h * ${l};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${o}; w++) {
              int wIn = wBeg + w * ${p};

              if (wIn >= 0 && wIn < ${n}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function VY(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r,p=N.computeDilation2DInfo(a.shape,s.shape,i,o,"NHWC",l),u,d=new WY(p);u=n.runWebGLProgram(d,[a,s],"float32");let h=ue({inputs:{x:u},backend:n,attrs:{shape:p.outShape}});return n.disposeIntermediateTensorInfo(u),h}var UY={kernelName:bi,backendName:"webgl",kernelFunc:VY};function GY(e){let{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,s=t,{allDims:i,summedDims:o,idDims:l}=N.decodeEinsumEquation(a,s.length);N.checkEinsumDimSizes(i.length,l,s);let{path:p,steps:u}=N.getEinsumComputePath(o,l),d=u.length,h=null,c=i.length,f=[];for(let m=0;m<d;++m){for(let g of u[m]){let{permutationIndices:y,expandDims:b}=N.getEinsumPermutation(c,l[g]),x;N.isIdentityPermutation(y)?x=s[g]:(x=mn({inputs:{x:s[g]},backend:n,attrs:{perm:y}}),f.push(x));let v=x.shape.slice();for(let I=0;I<b.length;++I)v.splice(b[I],0,1);w.arraysEqual(x.shape,v)||(x=ue({inputs:{x},backend:n,attrs:{shape:v}}),f.push(x)),h===null?h=x:(h=Vx({inputs:{a:x,b:h},backend:n}),f.push(h))}m<d-1&&(p[m]>=0&&(h=yf({inputs:{x:h},backend:n,attrs:{axis:p[m]-(i.length-c),keepDims:!1}}),f.push(h)),c--)}for(let m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}var HY={kernelName:ec,backendName:"webgl",kernelFunc:GY},jY="return (x >= 0.0) ? x : (exp(x) - 1.0);",qY=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,KY=Ke({opSnippet:jY,packedOpSnippet:qY}),XY={kernelName:vi,backendName:"webgl",kernelFunc:KY},ZY="return (b >= 0.0) ? a : a * (b + 1.0);",JY=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,YY=e=>{let{inputs:t,backend:n}=e,{dy:r,y:a}=t,s=G().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Eu(JY,r.shape,a.shape):new Xs(ZY,r.shape,a.shape);return n.runWebGLProgram(s,[r,a],r.dtype)},QY={kernelName:Nl,backendName:"webgl",kernelFunc:YY},eQ=`
  return vec4(equal(a, b));
`,tQ="return float(a == b);",nQ=rn({opSnippet:tQ,packedOpSnippet:eQ,dtype:"bool",cpuKernelImpl:F7}),rQ={kernelName:Tl,backendName:"webgl",kernelFunc:nQ},aQ=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${N.ERF_P};
  float a1 = ${N.ERF_A1};
  float a2 = ${N.ERF_A2};
  float a3 = ${N.ERF_A3};
  float a4 = ${N.ERF_A4};
  float a5 = ${N.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,sQ=Ke({opSnippet:aQ}),iQ={kernelName:wi,backendName:"webgl",kernelFunc:sQ},oQ=$u+`
  return exp(x);
`,lQ=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,VT=Ke({opSnippet:oQ,packedOpSnippet:lQ,cpuKernelImpl:R7,dtype:"float32"}),uQ={kernelName:ki,backendName:"webgl",kernelFunc:VT};function Gm(e){let{inputs:t,attrs:n,backend:r}=e,{dim:a}=n,{input:s}=t,i=s.shape.length,o=s.shape.slice(),l=a;return a<0&&(w.assert(-(i+1)<=a,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+a+1),o.splice(l,0,1),ue({inputs:{x:s},backend:r,attrs:{shape:o}})}var pQ={kernelName:Cl,backendName:"webgl",kernelFunc:Gm},o0="return exp(x) - 1.0;",dQ=Ke({opSnippet:o0,packedOpSnippet:o0,cpuKernelImpl:D7}),hQ={kernelName:Ii,backendName:"webgl",kernelFunc:dQ},l0=class{constructor(e,t,n){this.variableNames=["real","imag"];let r=t[1];this.outputShape=t;let a=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,s=n?`${r}.0`:"1.0",i;if(e==="real")i="return real * expR - imag * expI;";else if(e==="imag")i="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${a};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${i}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${s};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function UT(e,t,n){let r=n.texData.get(e.dataId),a=w.sizeFromShape(e.shape),s=e.shape[e.shape.length-1],i=a/s,o=ue({inputs:{x:e},backend:n,attrs:{shape:[i,s]}}),l=o.shape,p=new l0("real",l,t),u=new l0("imag",l,t),d=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],h=n.runWebGLProgram(p,d,"float32"),c=n.runWebGLProgram(u,d,"float32"),f=ls({inputs:{real:h,imag:c},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(c);let m=ue({inputs:{x:f},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(f),m}function cQ(e){let{inputs:t,backend:n}=e,{input:r}=t;return UT(r,!1,n)}var fQ={kernelName:tc,backendName:"webgl",kernelFunc:cQ},mQ=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};function kd(e){let{backend:t,attrs:n}=e,{shape:r,value:a}=n,{dtype:s}=n;if(s=s||w.inferDtype(a),s==="string"){let i=w.getArrayFromDType(s,w.sizeFromShape(r));return i.fill(a),t.makeTensorInfo(r,s,i)}else{let i=new mQ(r,a),o=[[a]];return t.runWebGLProgram(i,[],s,o)}}var gQ={kernelName:Ep,backendName:"webgl",kernelFunc:kd},yQ=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];let t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}},bQ={kernelName:_l,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{let{image:n}=e,r=t,a=new yQ(n.shape);return r.runWebGLProgram(a,[n],n.dtype)}},u0="return floor(x);",xQ=Ke({opSnippet:u0,packedOpSnippet:u0,cpuKernelImpl:M7}),vQ={kernelName:Si,backendName:"webgl",kernelFunc:xQ},wQ=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,kQ=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,IQ=rn({opSnippet:wQ,packedOpSnippet:kQ,dtype:"int32"}),SQ={kernelName:Ni,backendName:"webgl",kernelFunc:IQ},NQ=class{constructor(e){this.variableNames=["A"];let t=vn(),[n,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}},TQ=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let t=vn(),[n,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${n}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}},CQ={kernelName:gh,backendName:"webgl",kernelFunc:_Q},Do,Uf=G().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function _Q(e){let{inputs:t,backend:n,attrs:r}=e,{pixels:a}=t,{numChannels:s}=r,i=typeof HTMLVideoElement<"u"&&a instanceof HTMLVideoElement,o=typeof HTMLImageElement<"u"&&a instanceof HTMLImageElement,[l,p]=i?[a.videoWidth,a.videoHeight]:[a.width,a.height],u=[p,l],d=[p,l,s];if(o||i){let m=G().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Do==null||m!==Uf)&&(Uf=m,Do=document.createElement("canvas").getContext("2d",{willReadFrequently:Uf})),Do.canvas.width=l,Do.canvas.height=p,Do.drawImage(a,0,0,l,p),a=Do.canvas}let h=n.makeTensorInfo(u,"int32");n.texData.get(h.dataId).usage=Jn.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(h.dataId),a);let c=G().getBool("WEBGL_PACK")?new TQ(d):new NQ(d),f=n.runWebGLProgram(c,[h],"int32");return n.disposeData(h.dataId),f}function EQ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:p,dataFormat:u,dilations:d,dimRoundingMode:h,activation:c,leakyreluAlpha:f}=r,m=N.convertConv2DDataFormat(u),g=N.computeConv2DInfo(a.shape,s.shape,l,d,p,h,!1,m),y,b=[],x=i!=null,v=o!=null,I=c==="leakyrelu",T=()=>{let E=[a,s],A=(R,F)=>{if(F==="NCHW"&&R.shape.length===1&&R.shape[0]!==1){let S=ue({inputs:{x:R},backend:n,attrs:{shape:[R.shape[0],1,1]}});return b.push(S),S}return R};if(x&&E.push(A(i,u)),v&&E.push(A(o,u)),I){let R=n.makeTensorInfo([],"float32",w.createScalarValue(f,"float32"));E.push(R),b.push(R)}return E};if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))y=LT({x:a,filter:s,convInfo:g,backend:n,bias:i,activation:c,preluActivationWeights:o,leakyreluAlpha:f});else if(g.strideWidth<=2&&m==="channelsLast"&&G().getBool("WEBGL_EXP_CONV")){let E=c?yp(c,!0):null,A=new OT(g,x,E,v,I),R=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],F=T();y=n.runWebGLProgram(A,F,"float32",R)}else if(G().getBool("WEBGL_CONV_IM2COL"))y=zT({x:a,filter:s,convInfo:g,backend:n,bias:i,activation:c,preluActivationWeights:o,leakyreluAlpha:f});else{let E=c?yp(c,!1):null,A=new MT(g,x,E,v,I),R=T();y=n.runWebGLProgram(A,R,"float32")}let _=ue({inputs:{x:y},backend:n,attrs:{shape:g.outShape}});return b.push(y),b.forEach(E=>n.disposeIntermediateTensorInfo(E)),_}var $Q={kernelName:Rs,backendName:"webgl",kernelFunc:EQ};function AQ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:p,dilations:u,dimRoundingMode:d,activation:h,leakyreluAlpha:c}=r,f=[],m=u;m==null&&(m=[1,1]),w.assert(N.eitherStridesOrDilationsAreOne(l,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);let g=N.computeConv2DInfo(a.shape,s.shape,l,m,p,d,!0),y=G().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,b=h?yp(h,y):null,x=[a,s],v=i!=null,I=o!=null,T=h==="leakyrelu";if(v&&x.push(i),I&&x.push(o),T){let R=n.makeTensorInfo([],"float32",w.createScalarValue(c,"float32"));x.push(R),f.push(R)}let _;y?_=new WT(g,v,b,I,T):_=new BT(g,v,b,I,T);let E=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],A=n.runWebGLProgram(_,x,"float32",E);return f.forEach(R=>n.disposeIntermediateTensorInfo(R)),A}var FQ={kernelName:Ds,backendName:"webgl",kernelFunc:AQ},RQ=class{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;let a=lt(n.length),s=`
    int index;`;for(let i=0;i<this.sliceDim;i++)s+=`
          index = round(getIndices(coords[0], ${i}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[i]};
          flattenIndex += index * ${this.strides[i]};`;this.userCode=`
         void main() {
          ${a} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${s}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};function DQ(e){let{inputs:t,backend:n}=e,{params:r,indices:a}=t,s=a.shape,i=s[s.length-1],o=w.sizeFromShape(r.shape),[l,p,u,d]=N.prepareAndValidate(r,a),h=ue({inputs:{x:a},backend:n,attrs:{shape:[p,i]}}),c=ue({inputs:{x:r},backend:n,attrs:{shape:[w.sizeFromShape(r.shape)/u,u]}});if(n.shouldExecuteOnCPU([r,a])||r.dtype==="string"){let y=n.readSync(a.dataId),b=n.bufferSync(r),x=O7(y,b,r.dtype,p,i,u,d,r.shape,o);return n.makeTensorInfo(l,r.dtype,x.values)}let f=new RQ(i,d,[p,u],r.shape),m=n.runWebGLProgram(f,[c,h],c.dtype),g=ue({inputs:{x:m},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(m),g}var MQ={kernelName:$l,backendName:"webgl",kernelFunc:DQ},OQ=class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;let n=lt(this.rank),r=LQ(e);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}};function LQ(e,t){let n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let a=0;a<e.length;a++)a===2?r.push("index"):r.push(`${n[a]}`);return r.join()}function GT(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,indices:s}=t,{axis:i,batchDims:o}=r,l=w.parseAxisParam(i,a.shape)[0];if(G().get("DEBUG")){let b=n.readSync(s.dataId),x=a.shape[l];for(let v=0;v<b.length;++v){let I=b[v];w.assert(I<=x-1&&I>=0,()=>`GatherV2: the index value ${I} is not in [0, ${x-1}]`)}}let p=N.segment_util.collectGatherOpShapeInfo(a,s,l,o),u=w.sizeFromShape(s.shape),d=[],h=ue({inputs:{x:a},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),c=ue({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,u/p.batchSize]}});d.push(h),d.push(c);let f=[p.batchSize,p.outerSize,u/p.batchSize,p.sliceSize];if(n.shouldExecuteOnCPU([a,s])||a.dtype==="string"){let b=n.bufferSync(c),x=n.bufferSync(h),v=L7(x,b,f);return d.forEach(I=>n.disposeIntermediateTensorInfo(I)),n.makeTensorInfo(p.outputShape,v.dtype,v.values)}let m=new OQ(h.shape,f),g=n.runWebGLProgram(m,[h,c],h.dtype);d.push(g);let y=ue({inputs:{x:g},backend:n,attrs:{shape:p.outputShape}});return d.forEach(b=>n.disposeIntermediateTensorInfo(b)),y}var zQ={kernelName:El,backendName:"webgl",kernelFunc:GT},PQ="return float(a > b);",BQ=`
  return vec4(greaterThan(a, b));
`,WQ=rn({opSnippet:PQ,packedOpSnippet:BQ,cpuKernelImpl:z7,dtype:"bool"}),VQ={kernelName:Al,backendName:"webgl",kernelFunc:WQ},UQ="return float(a >= b);",GQ=`
  return vec4(greaterThanEqual(a, b));
`,HQ=rn({opSnippet:UQ,packedOpSnippet:GQ,dtype:"bool",cpuKernelImpl:P7}),jQ={kernelName:Ci,backendName:"webgl",kernelFunc:HQ};function qQ(e){let{inputs:t,backend:n}=e,{input:r}=t;return UT(r,!0,n)}var KQ={kernelName:nc,backendName:"webgl",kernelFunc:qQ},XQ="return float(!isnan(x) && !isinf(x));",ZQ=Ke({opSnippet:XQ,dtype:"bool"}),JQ={kernelName:Ei,backendName:"webgl",kernelFunc:ZQ},YQ="return float(isinf(x));",QQ=Ke({opSnippet:YQ,dtype:"bool"}),eee={kernelName:$i,backendName:"webgl",kernelFunc:QQ},tee="return float(isnan(x));",nee=Ke({opSnippet:tee,dtype:"bool"}),ree={kernelName:Ai,backendName:"webgl",kernelFunc:nee},aee="return float(a < b);",see=`
  return vec4(lessThan(a, b));
`,iee=rn({opSnippet:aee,packedOpSnippet:see,cpuKernelImpl:B7,dtype:"bool"}),oee={kernelName:Fl,backendName:"webgl",kernelFunc:iee},lee="return float(a <= b);",uee=`
  return vec4(lessThanEqual(a, b));
`,pee=rn({opSnippet:lee,packedOpSnippet:uee,cpuKernelImpl:W7,dtype:"bool"}),dee={kernelName:Rl,backendName:"webgl",kernelFunc:pee};function hee(e){let{backend:t,attrs:n}=e,{start:r,stop:a,num:s}=n,i=V7(r,a,s);return t.makeTensorInfo([i.length],"float32",i)}var cee={kernelName:Dl,backendName:"webgl",kernelFunc:hee},fee=$u+`
  return x < 0.0 ? 0./0. : log(x);
`,mee=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,gee=Ke({opSnippet:fee,packedOpSnippet:mee,cpuKernelImpl:U7}),yee={kernelName:Ri,backendName:"webgl",kernelFunc:gee},bee=$u+`
  return log(1.0 + x);
`,xee=Ke({opSnippet:bee}),vee={kernelName:Di,backendName:"webgl",kernelFunc:xee},wee="return float(a >= 1.0 && b >= 1.0);",kee=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,Iee=rn({opSnippet:wee,packedOpSnippet:kee,dtype:"bool"}),See={kernelName:Ml,backendName:"webgl",kernelFunc:Iee},Nee="return float(!(x >= 1.0));",Tee=Ke({opSnippet:Nee}),Cee={kernelName:Ol,backendName:"webgl",kernelFunc:Tee},_ee="return float(a >= 1.0 || b >= 1.0);",Eee=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,$ee=rn({opSnippet:_ee,packedOpSnippet:Eee,dtype:"bool"}),Aee={kernelName:Ll,backendName:"webgl",kernelFunc:$ee},Fee=class{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[];let s=t,i=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${r}) * sum`;a===.5?o=`inversesqrt(${l})`:a===1?o=`1.0/(${l})`:o=`exp(log(${l}) * float(-${a}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${s}; j <= ${s}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${i}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${o};
        setOutput(val);
      }
    `}},Ree=class{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let s=t,i=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${r}) * sum`;a===.5?o=`inversesqrt(${l})`:a===1?o=`1.0/(${l})`:o=`exp(log(${l}) * float(-${a}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${s};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${s}; j <= ${s}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${o};
        setOutput(result);
      }
    `}},Dee=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r,p=G().getBool("WEBGL_PACK_NORMALIZATION")?new Ree(a.shape,s,i,o,l):new Fee(a.shape,s,i,o,l);return n.runWebGLProgram(p,[a],a.dtype)},Mee={kernelName:Mi,backendName:"webgl",kernelFunc:Dee},Oee=class{constructor(e,t,n,r,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=a,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${n});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${a})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${a});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}},Lee=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:p,beta:u}=r,d=new Oee(a.shape,o,l,p,u);return n.runWebGLProgram(d,[a,s,i],a.dtype)},zee={kernelName:zl,backendName:"webgl",kernelFunc:Lee};function Pee(e,t,n,r){let a=w.sizeFromShape(t),s=w.sizeFromShape(e.shape)/a,i=ue({inputs:{x:e},attrs:{shape:[s,a]},backend:r}),o=_o(i,e.dtype,"max",r),l=ue({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(o),l}function HT(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:s,keepDims:i}=r,o=a.shape.length,l=w.parseAxisParam(s,a.shape),p=l,u=N.getAxesPermutation(p,o),d=u!=null,h=n.shouldExecuteOnCPU([a]),c=a;if(d){if(h){let b=n.texData.get(c.dataId).values,x=new Array(o);for(let T=0;T<x.length;T++)x[T]=a.shape[u[T]];let v=Px(b,a.shape,a.dtype,u,x);c=n.makeTensorInfo(x,a.dtype);let I=n.texData.get(c.dataId);I.values=v}else c=gf(a,u,n);p=N.getInnerMostAxes(p.length,o)}N.assertAxesAreInnerMostDims("max",p,o);let[f,m]=N.computeOutAndReduceShapes(c.shape,p),g=f;i&&(g=N.expandShapeToKeepDim(f,l));let y;if(h){let b=n.texData.get(c.dataId).values,x=G7(b,w.sizeFromShape(m),g,a.dtype);y=n.makeTensorInfo(g,a.dtype);let v=n.texData.get(y.dataId);v.values=x}else y=Pee(c,m,g,n);return d&&n.disposeIntermediateTensorInfo(c),y}var Bee={kernelName:Oi,backendName:"webgl",kernelFunc:HT},Wee=Wx+`
  return max(a, b);
`,Vee=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Co+`
  return result;
`,Uee=rn({opSnippet:Wee,packedOpSnippet:Vee,cpuKernelImpl:H7}),Gee={kernelName:Li,backendName:"webgl",kernelFunc:Uee};function Hee(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;Su(a,"maxPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r,p=1;w.assert(N.eitherStridesOrDilationsAreOne(i,p),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${p}'`);let u=N.computePool2DInfo(a.shape,s,i,p,o,l);if(u.filterWidth===1&&u.filterHeight===1&&w.arraysEqual(u.inShape,u.outShape))return Gn({inputs:{x:a},backend:n});let d=new bp(u,"max",!1);return n.runWebGLProgram(d,[a],a.dtype)}var jee={kernelName:zi,backendName:"webgl",kernelFunc:Hee};function qee(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dataFormat:l,dimRoundingMode:p}=r,u=[1,1,1],d=N.computePool3DInfo(a.shape,s,i,u,o,p,l),h=new Ux(d,"max",!1);return n.runWebGLProgram(h,[a],a.dtype)}var Kee={kernelName:Pl,backendName:"webgl",kernelFunc:qee},Xee=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,a=e.effectiveFilterHeight,s=e.effectiveFilterWidth,i=a-1-e.padInfo.top,o=s-1-e.padInfo.left,l=a*s-1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${a};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${n}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${s} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},Zee=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.dilationDepth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,l=e.effectiveFilterHeight,p=e.effectiveFilterWidth,u=o-1-e.padInfo.front,d=l-1-e.padInfo.top,h=p-1-e.padInfo.left,c=o*l*p-1;this.userCode=`
      const ivec3 pads = ivec3(${u}, ${d}, ${h});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${o};
           wD += ${a}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${s}) {
            float dyR = float(dyRCorner + wR) / ${n}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${p};
                wC += ${i}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${c} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${l} * ${p} +
                  wR * ${p} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Jee(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s,{filterSize:o,strides:l,pad:p,dimRoundingMode:u}=r,d=[1,1,1],h=N.computePool3DInfo(i.shape,o,l,d,p,u),c=new Ux(h,"max",!0),f=n.runWebGLProgram(c,[i],i.dtype),m=new Zee(h),g=n.runWebGLProgram(m,[a,f],i.dtype);return n.disposeIntermediateTensorInfo(f),g}var Yee={kernelName:Ap,backendName:"webgl",kernelFunc:Jee};function Qee(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s,output:i}=t,o=s;Su([s,i],"maxPoolGrad");let{filterSize:l,strides:p,pad:u,dimRoundingMode:d}=r,h=N.computePool2DInfo(o.shape,l,p,1,u,d),c=!0,f=new bp(h,"max",c),m=n.runWebGLProgram(f,[o],o.dtype),g=new Xee(h),y=n.runWebGLProgram(g,[a,m],o.dtype);return n.disposeIntermediateTensorInfo(m),y}var ete={kernelName:$p,backendName:"webgl",kernelFunc:Qee};function tte(e,t,n,r){let a=new bp(n,"max",!1),s=r.runWebGLProgram(a,[e],"float32");a=new bp(n,"max",!0,!0,t);let i=r.runWebGLProgram(a,[e],"float32");return[s,i]}var nte={kernelName:Fp,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{filterSize:a,strides:s,pad:i,includeBatchInIndex:o}=t,l=n;w.assert(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);let p=[1,1];w.assert(N.eitherStridesOrDilationsAreOne(s,p),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${p}'`);let u=N.computePool2DInfo(r.shape,a,s,p,i),[d,h]=tte(r,o,u,l);return[d,h]}};function rte(e,t,n,r){let a=w.sizeFromShape(t),s=w.sizeFromShape(e.shape)/a,i=ue({inputs:{x:e},attrs:{shape:[s,a]},backend:r}),o=_o(i,"float32","mean",r),l=ue({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(o),l}var ate={kernelName:Pi,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{keepDims:a,axis:s}=t,i=n,o=r.shape.length,l=w.parseAxisParam(s,r.shape),p=l,u=N.getAxesPermutation(p,o),d=u!=null,h=i.shouldExecuteOnCPU([r]),c=[],f=r;if(d){if(h){let x=i.texData.get(f.dataId).values,v=new Array(o);for(let _=0;_<v.length;_++)v[_]=r.shape[u[_]];let I=Px(x,r.shape,r.dtype,u,v);f=i.makeTensorInfo(v,r.dtype);let T=i.texData.get(f.dataId);T.values=I}else f=gf(r,u,i);c.push(f),p=N.getInnerMostAxes(p.length,o)}N.assertAxesAreInnerMostDims("sum",p,o);let[m,g]=N.computeOutAndReduceShapes(f.shape,p),y=m;a&&(y=N.expandShapeToKeepDim(m,l));let b=rte(f,g,y,i);for(let x of c)i.disposeIntermediateTensorInfo(x);return b}};function ste(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=w.parseAxisParam(s,a.shape),p=l,u=N.getAxesPermutation(p,o),d=a;u!=null&&(d=mn({inputs:{x:a},backend:n,attrs:{perm:u}}),p=N.getInnerMostAxes(p.length,a.shape.length)),N.assertAxesAreInnerMostDims("min",p,o);let[h,c]=N.computeOutAndReduceShapes(d.shape,p),f=w.sizeFromShape(c),m=ue({inputs:{x:d},backend:n,attrs:{shape:[-1,f]}}),g=_o(m,m.dtype,"min",n),y;if(i){let b=N.expandShapeToKeepDim(h,l);y=ue({inputs:{x:g},backend:n,attrs:{shape:b}})}else y=ue({inputs:{x:g},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),u!=null&&n.disposeIntermediateTensorInfo(d),y}var ite={kernelName:Bi,backendName:"webgl",kernelFunc:ste},ote=Wx+`
  return min(a, b);
`,lte=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Co+`
  return result;
`,ute=rn({opSnippet:ote,packedOpSnippet:lte,cpuKernelImpl:j7}),pte={kernelName:Wi,backendName:"webgl",kernelFunc:ute},dte=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((p,u)=>p[0]+e[u]+p[1]);let r=e.length,a=lt(r),s=t.map(p=>p[0]).join(","),i=t.map((p,u)=>p[0]+e[u]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l=n==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${s};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${l};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${l};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${a} start = ${a}(${s});
      ${a} end = ${a}(${i});

      void main() {
        ${a} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${l};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};
          }
        }
        ${a} coords = outC - start;
        setOutput(getX(${o}));
      }
    `}},hte=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((c,f)=>c[0]+e[f]+c[1]);let r=e.length,a=lt(r),s=t.map(c=>c[0]).join(","),i=t.map((c,f)=>c[0]+e[f]).join(","),o=hn("rc",r),l=hn("source",r),p=`${o[r-1]} < ${this.outputShape[r-1]}`,u=r===1?"source":`vec2(${l.slice(-2).join()})`,d=n==="reflect"?0:1,h="";if(r===1){let c=`
        ${a} source = rc;
        if (source < start) {
          source = start * 2 - source - ${d};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${d};
        }
        source -= start;
      `;h=`
        ${a} rc = outputLoc;
        ${c}
        result[0] = getChannel(getX(${l.join()}), ${u});
        ${o[r-1]} += 1;
        if(${p}) {
          ${c}
          result[1] = getChannel(getX(${l.join()}), ${u});
        }
      `}else{let c=`
        ${a} source = rc;
        ${a} lt = ${a}(lessThan(source, start));
        ${a} gte = ${a}(greaterThanEqual(source, end));
        ${a} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${d}) +
                gte * ((end - 1) * 2 - source + ${d});
        source -= start;
      `;h=`
        ${a} rc = outputLoc;
        ${c}
        result[0] = getChannel(getX(${l.join()}), ${u});
        ${o[r-1]} += 1;
        if(${p}) {
          ${c}
          result[1] = getChannel(getX(${l.join()}), ${u});
        }
        rc = outputLoc;
        ${o[r-2]} += 1;
        if(${o[r-2]} < ${this.outputShape[r-2]}) {
          ${c}
          result[2] = getChannel(getX(${l.join()}), ${u});
          ${o[r-1]} += 1;
          if(${p}) {
            ${c}
            result[3] = getChannel(getX(${l.join()}), ${u});
          }
        }
      `}this.userCode=`
      const ${a} start = ${a}(${s});
      const ${a} end = ${a}(${i});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${h}
        setOutput(result);
      }
    `}},cte=({inputs:e,backend:t,attrs:n})=>{let{x:r}=e,{paddings:a,mode:s}=n,i=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new hte(r.shape,a,s):new dte(r.shape,a,s);return t.runWebGLProgram(i,[r],r.dtype)},fte={kernelName:Vi,backendName:"webgl",kernelFunc:cte},mte=`if (b == 0.0) return NAN;
  return mod(a, b);`,gte=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Co+`
  return result;
`,yte=rn({opSnippet:mte,packedOpSnippet:gte}),bte={kernelName:Ui,backendName:"webgl",kernelFunc:yte},xte=class{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}},vte=`
if (a == b) {
  return 1.0;
};
return a / b;`,wte=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,jT=rn({opSnippet:vte,packedOpSnippet:wte,checkOutOfBounds:!0}),kte={kernelName:xi,backendName:"webgl",kernelFunc:jT},p0="return a - b;",qT=rn({opSnippet:p0,packedOpSnippet:p0,supportsComplex:!0,cpuKernelImpl:cZ}),Ite={kernelName:mo,backendName:"webgl",kernelFunc:qT};function KT(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:s}=r,i=w.parseAxisParam([s],a.shape),o=HT({inputs:{x:a},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),l=N.expandShapeToKeepDim(o.shape,i),p=ue({inputs:{x:o},backend:n,attrs:{shape:l}}),u=qT({inputs:{a,b:p},backend:n}),d=VT({inputs:{x:u},backend:n}),h=yf({inputs:{x:d},backend:n,attrs:{axis:i,keepDims:!1}}),c=ue({inputs:{x:h},backend:n,attrs:{shape:l}}),f=jT({inputs:{a:d,b:c},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(c),f}var Ste={kernelName:co,backendName:"webgl",kernelFunc:KT};function Nte(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r,l=o?a:KT({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),p=l.shape[0],u=l.shape[1],d=new xte(p,u,s),h=[[i]],c=n.runWebGLProgram(d,[l],"int32",h);return o||n.disposeIntermediateTensorInfo(l),c}var Tte={kernelName:Bl,backendName:"webgl",kernelFunc:Nte},Cte=fr+`
  return -x;
`,_te=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function Ete(e){let{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){let s=n.texData.get(r.dataId),[i,o]=K7(s.values,r.shape,r.dtype);return n.makeTensorInfo(o,r.dtype,i)}let a;return G().getBool("WEBGL_PACK_UNARY_OPERATIONS")?a=new Fa(r.shape,_te):a=new Pr(r.shape,Cte),n.runWebGLProgram(a,[r],r.dtype)}var $te={kernelName:Wl,backendName:"webgl",kernelFunc:Ete},Ate=Xr.nonMaxSuppressionV3Impl;function Fte(e){N.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r,p=n.readSync(a.dataId),u=n.readSync(s.dataId),{selectedIndices:d}=Ate(p,u,i,o,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}var Rte={kernelName:Ul,backendName:"webgl",kernelFunc:Fte},Dte=Xr.nonMaxSuppressionV4Impl;function Mte(e){N.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:p}=r,u=n.readSync(a.dataId),d=n.readSync(s.dataId),{selectedIndices:h,validOutputs:c}=Dte(u,d,i,o,l,p);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([c]))]}var Ote={kernelName:Gl,backendName:"webgl",kernelFunc:Mte},Lte=Xr.nonMaxSuppressionV5Impl;function zte(e){N.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:p}=r,u=n.readSync(a.dataId),d=n.readSync(s.dataId),h=i,c=o,f=l,m=p,{selectedIndices:g,selectedScores:y}=Lte(u,d,h,c,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var Pte={kernelName:Hl,backendName:"webgl",kernelFunc:zte},Bte=class{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${n}),
                      float(index == coords.y)));
      }
    `}},Wte=e=>{let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=r,p=w.sizeFromShape(a.shape),u=new Bte(p,i,o,l),d=ue({inputs:{x:a},backend:n,attrs:{shape:[p]}}),h=n.runWebGLProgram(u,[d],s);n.disposeIntermediateTensorInfo(d);let c=[...a.shape,i],f=ue({inputs:{x:h},backend:n,attrs:{shape:c}});return n.disposeIntermediateTensorInfo(h),f},Vte={kernelName:Hi,backendName:"webgl",kernelFunc:Wte};function Ph(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="complex64"){let a=wd({inputs:{input:r},backend:n}),s=Ph({inputs:{x:a},backend:n}),i=bf({inputs:{input:r},backend:n}),o=Ph({inputs:{x:i},backend:n}),l=ls({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return kd({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:n})}var Ute={kernelName:pu,backendName:"webgl",kernelFunc:Ph};function XT(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){let a=wd({inputs:{input:r},backend:n}),s=XT({inputs:{x:a},backend:n}),i=bf({inputs:{input:r},backend:n}),o=Ph({inputs:{x:i},backend:n}),l=ls({inputs:{real:s,imag:o},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return kd({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:n})}var Gte={kernelName:jl,backendName:"webgl",kernelFunc:XT};function Hte(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(t.length===1)return Gm({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let s=t[0].shape,i=t[0].dtype;t.forEach(u=>{w.assertShapesMatch(s,u.shape,"All tensors passed to stack must have matching shapes"),w.assert(i===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],l=t.map(u=>{let d=Gm({inputs:{input:u},backend:n,attrs:{dim:a}});return o.push(d),d}),p=DT({inputs:l,backend:n,attrs:{axis:a}});return o.forEach(u=>n.disposeIntermediateTensorInfo(u)),p}var jte={kernelName:ql,backendName:"webgl",kernelFunc:Hte},qte=class{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((l,p)=>l[0]+e[p]+l[1]);let r=e.length,a=lt(r),s=t.map(l=>l[0]).join(","),i=t.map((l,p)=>l[0]+e[p]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${s};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${a} start = ${a}(${s});
      ${a} end = ${a}(${i});

      void main() {
        ${a} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${a} coords = outC - start;
          setOutput(getX(${o}));
        }
      }
    `}},Kte=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((f,m)=>f[0]+e[m]+f[1]);let r=e.length,a=lt(r),s=t.map(f=>f[0]).join(","),i=t.map((f,m)=>f[0]+e[m]).join(","),o=hn("rc",r),l=hn("source",r),p=`${o[r-1]} < ${this.outputShape[r-1]}`,u=r===1?"source":`vec2(${l.slice(-2).join()})`,d=[`${a} rc = outputLoc;`,`${o[r-1]} += 1;
       if(${p}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${o[r-2]} += 1;
       if(${o[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${o[r-1]} += 1;
         if(${p}) {`],h=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",c="";for(let f=0,m=r===1?2:4;f<m;f++)c+=`
        ${d[f]}
        if (${h}) {
          result[${f}] = float(value);
        } else {
          ${a} source = rc - start;
          result[${f}] = getChannel(getX(${l.join()}), ${u});
        }
      `;c+=r===1?"} ":"}}",this.userCode=`
      const ${a} start = ${a}(${s});
      const ${a} end = ${a}(${i});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${c}
        setOutput(result);
      }
    `}},ZT=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,constantValue:i}=r;if(w.sizeFromShape(a.shape)===0){let p=s.map((u,d)=>u[0]+a.shape[d]+u[1]);return kd({backend:n,attrs:{shape:p,value:i,dtype:a.dtype}})}let o=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Kte(a.shape,s,i):new qte(a.shape,s,i),l=[[i]];return n.runWebGLProgram(o,[a],a.dtype,l)},Xte={kernelName:ji,backendName:"webgl",kernelFunc:ZT},Zte=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,Jte=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Co+`
  return result;
`,Yte=rn({opSnippet:Zte,packedOpSnippet:Jte}),Qte={kernelName:qi,backendName:"webgl",kernelFunc:Yte};function ene(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=[],p=w.parseAxisParam(s,a.shape),u=p,d=N.getAxesPermutation(u,o),h=a;d!=null&&(h=mn({inputs:{x:a},backend:n,attrs:{perm:d}}),u=N.getInnerMostAxes(u.length,o),l.push(h)),N.assertAxesAreInnerMostDims("prod",u,o);let c;if(n.shouldExecuteOnCPU([h])){let f=n.texData.get(h.dataId).values,{outVals:m,outShape:g,outDtype:y}=Z7(h.shape,h.dtype,f,u);c=n.makeTensorInfo(g,y,m)}else{let[f,m]=N.computeOutAndReduceShapes(h.shape,u),g=w.sizeFromShape(m),y=ue({inputs:{x:h},backend:n,attrs:{shape:[-1,g]}}),b=uc(a.dtype),x=_o(y,b,"prod",n);c=ue({inputs:{x},backend:n,attrs:{shape:f}}),l.push(y),l.push(x)}if(i){l.push(c);let f=N.expandShapeToKeepDim(c.shape,p);c=ue({inputs:{x:c},backend:n,attrs:{shape:f}})}return l.forEach(f=>n.disposeIntermediateTensorInfo(f)),c}var tne={kernelName:Xi,backendName:"webgl",kernelFunc:ene};function nne(e){let{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:a,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=r,l=a.map(y=>n.readSync(y.dataId)),p=a.map(y=>y.shape),u=n.readSync(s.dataId),d=n.readSync(i.dataId),[h,c,f]=J7(l,p,u,s.shape,s.dtype,d,i.shape,o),m=h.map(y=>n.makeTensorInfo([y.length],"int32",y)),g=n.makeTensorInfo(f,s.dtype,c);return m.concat([g])}var rne={kernelName:ac,backendName:"webgl",kernelFunc:nne};function ane(e){let{inputs:t,backend:n}=e,{starts:r,limits:a,deltas:s}=t,i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[p,u]=Y7(i,r.shape,r.dtype,o,a.shape,l,s.shape),d=n.makeTensorInfo([p.length],"int32",p),h=n.makeTensorInfo([u.length],r.dtype,u);return[d,h]}var sne={kernelName:sc,backendName:"webgl",kernelFunc:ane};function ine(e){let{inputs:t,backend:n,attrs:r}=e,{shape:a,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,p=n.readSync(a.dataId),u=n.readSync(s.dataId),d=n.readSync(i.dataId),h=o.map(g=>n.readSync(g.dataId)),c=o.map(g=>g.shape),[f,m]=Q7(p,a.shape,u,s.shape,s.dtype,d,i.shape,h,c,l);return n.makeTensorInfo(f,s.dtype,m)}var one={kernelName:ic,backendName:"webgl",kernelFunc:ine},JT=e=>{let{backend:t,attrs:n}=e,{start:r,stop:a,step:s,dtype:i}=n,o=eZ(r,a,s,i);return t.makeTensorInfo([o.length],i,o)},lne={kernelName:Rp,backendName:"webgl",kernelFunc:JT},une="return 1.0 / x;",pne=Ke({opSnippet:une}),dne={kernelName:Zi,backendName:"webgl",kernelFunc:pne},hne=fr+`
  return (x < 0.0) ? 0.0 : x;
`,cne=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,fne=Ke({opSnippet:hne,packedOpSnippet:cne}),mne={kernelName:Ji,backendName:"webgl",kernelFunc:fne},gne=fr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,yne=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,bne=Ke({opSnippet:gne,packedOpSnippet:yne}),xne={kernelName:eo,backendName:"webgl",kernelFunc:bne},vne=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let p=[r&&t>1?i-1:i,r&&n>1?o-1:o],u=[r&&t>1?t-1:t,r&&n>1?n-1:n],d;a?d="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${p[0]/u[0]},
          ${p[1]/u[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}},wne=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let p=[r&&t>1?i-1:i,r&&n>1?o-1:o],u=[r&&t>1?t-1:t,r&&n>1?n-1:n],d;a?d="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${p[0]/u[0]},
          ${p[1]/u[1]},
          ${p[1]/u[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,
                                     ${o}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function kne(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,p]=o,u=G().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new wne(a.shape,l,p,s,i):new vne(a.shape,l,p,s,i);return n.runWebGLProgram(u,[a],"float32")}var Ine={kernelName:Qi,backendName:"webgl",kernelFunc:kne},Sne=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,a]=t,[,s,i]=e,o=[n&&s>1?r-1:r,n&&i>1?a-1:a],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],p=o[0]/l[0],u=o[1]/l[1],d=1/p,h=1/u,c=Math.ceil(d)*2+2,f=Math.ceil(h)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${p});
        const float widthScale = float(${u});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${h});

        const int winHeight = int(${c});
        const int winWidth = int(${f});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${s}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${a-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function Nne(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=new Sne(s.shape,a.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}var Tne={kernelName:Zl,backendName:"webgl",kernelFunc:Nne},Cne=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let p=[r&&t>1?i-1:i,r&&n>1?o-1:o],u=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0",h;a?h="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":h="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${p[0]/u[0]},
          ${p[1]/u[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${h};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}},_ne=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let p=[r&&t>1?i-1:i,r&&n>1?o-1:o],u=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0",h;a?h="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":h="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${p[0]/u[0]},
          ${p[1]/u[1]},
          ${p[1]/u[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,
                                     ${o}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${h};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};function Ene(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,p]=o,u=G().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new _ne(a.shape,l,p,s,i):new Cne(a.shape,l,p,s,i);return n.runWebGLProgram(u,[a],a.dtype)}var $ne={kernelName:Yi,backendName:"webgl",kernelFunc:Ene},Ane=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,a]=t,[,s,i]=e,o=[n&&s>1?r-1:r,n&&i>1?a-1:a],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],p=o[0]/l[0],u=o[1]/l[1],d=1/p,h=1/u,c=Math.ceil(d)*2+2,f=Math.ceil(h)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${p});
        const float widthScale = float(${u});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${h});

        const int winHeight = int(${c});
        const int winWidth = int(${f});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${s}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float sourceFracRow =
              float(${o[0]}) *
                (float(dyR) / float(${l[0]}));

            float sourceFracCol =
                float(${o[1]}) *
                  (float(dyC) / float(${l[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${n} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${a}) - 1),
                ${n} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function Fne(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=new Ane(s.shape,a.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}var Rne={kernelName:Xl,backendName:"webgl",kernelFunc:Fne},Dne=class{constructor(e,t){this.variableNames=["x"];let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,n===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}let r=i=>t.indexOf(i)!==-1&&e[i]!==1?`${e[i]} - coords[${i}] - 1`:`coords[${i}]`,a=e.map((i,o)=>r(o)).join(","),s=lt(n);this.userCode=`
      void main() {
        ${s} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}},Mne=class{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;let r=hn("rc",n),a=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,s=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,i=lt(n);n===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${a}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${i} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${o(r.slice())};
          if(${a}){
            result.g = ${l(r.slice())};
          }
          if(${s}) {
            result.b = ${p(r.slice())};
            if(${a}) {
              result.a = ${u(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function o(c){return d(c)}function l(c){return c[n-1]="("+c[n-1]+" + 1)",d(c)}function p(c){return c[n-2]="("+c[n-2]+" + 1)",d(c)}function u(c){return c[n-1]="("+c[n-1]+" + 1)",c[n-2]="("+c[n-2]+" + 1)",d(c)}function d(c){let f=e.map((y,b)=>h(b,c)),m=f.join(","),g=f.slice(-2).join(",");return`getChannel(getX(${m}), vec2(${g}))`}function h(c,f){return t.indexOf(c)!==-1&&e[c]!==1?`${e[c]} - ${f[c]} - 1`:`${f[c]}`}}};function One(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r,i=a.shape.length,o=w.parseAxisParam(s,a.shape);if(i===0)return Gn({inputs:{x:a},backend:n});let l=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Mne(a.shape,o):new Dne(a.shape,o);return n.runWebGLProgram(l,[a],a.dtype)}var Lne={kernelName:to,backendName:"webgl",kernelFunc:One},zne=class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let n=e[1],r=e[2];this.outputShape=e;let a="";typeof t=="number"?a=`float outputValue = ${t.toFixed(2)};`:a=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${a}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}},Pne={kernelName:du,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:a,fillValue:s,center:i}=t,o=n,l=new zne(r.shape,s),[p,u]=N.getImageCenter(i,r.shape[1],r.shape[2]),d=[[p,u,Math.sin(a),Math.cos(a)]];return o.runWebGLProgram(l,[r],r.dtype,d)}},Bne=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,Wne=Ke({opSnippet:Bne}),Vne={kernelName:no,backendName:"webgl",kernelFunc:Wne},Une="return inversesqrt(x);",Gne=Ke({opSnippet:Une,cpuKernelImpl:tZ}),Hne={kernelName:ro,backendName:"webgl",kernelFunc:Gne},Gx=class{constructor(e,t,n,r,a,s,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;let l=lt(a.length),p=lt(s.length),u="";n===1?u="i":n===2&&(u="i, j");let d=`getIndices(${u})`,h="";r===1?h="i":r===2&&(h="i, coords[1]");let c=`getUpdates(${h})`,f="";o&&(f="coords[0], coords[1]");let m=`getDefaultValue(${f})`,g=t>1?"strides[j]":"strides";this.userCode=`
        ${l} strides = ${l}(${a});

        void main() {
          ${p} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${d});
              flattenedIndex += index * ${g};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${c};
              found = true;
            }
          }
          setOutput(mix(${m}, sum, float(found)));
        }
      `}},jne=class{constructor(e,t,n,r,a,s,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s;let l=lt(a.length),p=lt(s.length),u="";n===1?u="i":n===2&&(u="i, j");let d=`getIndices(${u})`,h="";r===1?h="i":r===2&&(h="i, coords[1]");let c=`getUpdates(${h})`,f="";o&&(f="coords[0], coords[1]");let m=`getDefaultValue(${f})`,g=t>1?"strides[j]":"strides",y=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${l} strides = ${l}(${a});

        void main() {
          ${p} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${d});
              flattenedIndex += index.xz * ${g};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${y};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${c};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${m}, sum, found));
        }
      `}};function qne(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:s}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:p,strides:u,outputSize:d}=N.calculateShapes(s,a,i),h=[d/p,p];if(d===0)return n.makeTensorInfo(i,a.dtype);let c=ue({inputs:{x:a},backend:n,attrs:{shape:[l,o]}}),f=ue({inputs:{x:s},backend:n,attrs:{shape:[l,p]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0])),g;G().getBool("WEBGL_PACK")?g=new jne(l,o,c.shape.length,f.shape.length,u,h):g=new Gx(l,o,c.shape.length,f.shape.length,u,h);let y=n.runWebGLProgram(g,[f,c,m],f.dtype),b=ue({inputs:{x:y},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(m),b}var Kne={kernelName:Jl,backendName:"webgl",kernelFunc:qne},Xne=class{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];let a="while (left < right) {",s=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,i=G().getNumber("WEBGL_VERSION")===2?a:s,o=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${i}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${o} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};function Zne(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r,o=new Xne(a.shape[0],a.shape[1],s.shape[1],i),l=[[a.shape[1]]];return n.runWebGLProgram(o,[a,s],"int32",l)}var Jne={kernelName:Ql,backendName:"webgl",kernelFunc:Zne},Yne=class{constructor(e,t,n){this.variableNames=["c","a","b"],this.outputShape=t;let r,a;if(n>4)throw Error(`Where for rank ${n} is not yet supported`);if(n===1)a="resRC",r="resRC";else{let i=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],l=[];for(let p=0;p<t.length;p++)l.push(`${i[p]}`),p<e&&o.push(`${i[p]}`);r=o.join(),a=l.join()}let s=lt(n);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${a}));
        } else {
          setOutput(getB(${a}));
        }
      }
    `}};function Qne(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t,i=new Yne(r.shape.length,a.shape,a.shape.length);return n.runWebGLProgram(i,[r,a,s],tr(a.dtype,s.dtype))}var ere={kernelName:eu,backendName:"webgl",kernelFunc:Qne},tre=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${N.SELU_SCALEALPHA};
  float scale = ${N.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,nre=Ke({opSnippet:tre}),rre={kernelName:ao,backendName:"webgl",kernelFunc:nre},are=$u+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,sre=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,ire=Ke({opSnippet:are,packedOpSnippet:sre,cpuKernelImpl:rZ}),ore={kernelName:lo,backendName:"webgl",kernelFunc:ire},lre=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,ure=Ke({opSnippet:lre}),pre={kernelName:oo,backendName:"webgl",kernelFunc:ure},dre=$u+`
  return sin(x);
`,hre=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Co}
  return result;
`,cre=Ke({opSnippet:dre,packedOpSnippet:hre}),fre={kernelName:so,backendName:"webgl",kernelFunc:cre},mre=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,gre=Ke({opSnippet:mre}),yre={kernelName:io,backendName:"webgl",kernelFunc:gre},bre=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,xre=Ke({opSnippet:bre}),vre={kernelName:uo,backendName:"webgl",kernelFunc:xre},wre=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r;w.assert(a.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let o=s.reduce((y,b)=>y*b),l=[[0,0]];l.push(...i);for(let y=1+s.length;y<a.shape.length;++y)l.push([0,0]);let p=[],u=ZT({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),d=N.getReshaped(u.shape,s,o,!1),h=N.getPermuted(d.length,s.length,!1),c=N.getReshapedPermuted(u.shape,s,o,!1),f=ue({inputs:{x:u},backend:n,attrs:{shape:d}}),m=mn({inputs:{x:f},backend:n,attrs:{perm:h}}),g=ue({inputs:{x:m},backend:n,attrs:{shape:c}});return p.push(u),p.push(f),p.push(m),p.forEach(y=>n.disposeIntermediateTensorInfo(y)),g},kre={kernelName:nu,backendName:"webgl",kernelFunc:wre};function Ire(e){let{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:s,defaultValue:i}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${s.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(a.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${a.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let o=n.readSync(r.dataId),l=n.readSync(a.dataId),p=n.readSync(s.dataId),u=n.readSync(i.dataId)[0],[d,h,c,f,m]=sZ(o,r.shape,r.dtype,l,a.dtype,p,u);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],a.dtype,c),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}var Sre={kernelName:Dp,backendName:"webgl",kernelFunc:Ire};function Nre(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:s}=t;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(a.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${a.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(n.readSync(a.dataId)),o=n.readSync(r.dataId),l=Array.from(n.readSync(s.dataId)),[p,u,d]=iZ(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(u,r.dtype,p),n.makeTensorInfo([d.length],s.dtype,new Int32Array(d))]}var Tre={kernelName:au,backendName:"webgl",kernelFunc:Nre};function Cre(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${a.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${s.shape}`);let i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[p,u]=xT(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(u,r.dtype,p)}var _re={kernelName:Mp,backendName:"webgl",kernelFunc:Cre};function Ere(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${a.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${s.shape}`);let i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[p,u]=xT(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(u,r.dtype,p)}var $re={kernelName:Op,backendName:"webgl",kernelFunc:Ere};function Are(e){let{inputs:t,backend:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:p,sliceSize:u,strides:d,outputSize:h}=N.calculateShapes(s,a,o),c=!1;if(s.dtype==="string"){let y=n.bufferSync(a),b=n.bufferSync(s),x=w.decodeString(n.readSync(i.dataId)[0]),v=nZ(y,b,o,h,u,p,l,d,x,c);return n.makeTensorInfo(o,v.dtype,v.values)}let f=new Gx(p,l,a.shape.length,s.shape.length,d,[h,1],c),m=n.runWebGLProgram(f,[s,a,i],s.dtype),g=ue({inputs:{x:m},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(m),g}var Fre={kernelName:su,backendName:"webgl",kernelFunc:Are};function Rre(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=r,o=w.parseAxisParam(i,a.shape)[0],l=N.prepareSplitSize(a,s,o),p=a.shape.length,u=new Array(p).fill(0),d=a.shape.slice();return l.map(h=>{let c=[...d];c[o]=h;let f=Au({inputs:{x:a},backend:n,attrs:{begin:u,size:c}});return u[o]+=h,f})}var Dre={kernelName:ru,backendName:"webgl",kernelFunc:Rre},d0="return sqrt(x);",Mre=Ke({opSnippet:d0,packedOpSnippet:d0,cpuKernelImpl:oZ}),Ore={kernelName:po,backendName:"webgl",kernelFunc:Mre},Lre="return x * x;",zre=Ke({opSnippet:Lre}),Pre={kernelName:Lp,backendName:"webgl",kernelFunc:zre},h0="return (a - b) * (a - b);",Bre=rn({opSnippet:h0,packedOpSnippet:h0}),Wre={kernelName:fo,backendName:"webgl",kernelFunc:Bre};function Vre(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");let s=n.readSync(a.dataId),i=N.fromUint8ToStringArray(s),o=lZ(i,"string",r);return n.makeTensorInfo(a.shape,"string",o)}var Ure={kernelName:zp,backendName:"webgl",kernelFunc:Vre};function Gre({inputs:e,attrs:t,backend:n}){let{x:r}=e,a=fr+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,s=new Pr(r.shape,a);return n.runWebGLProgram(s,[r],r.dtype)}var Hre={kernelName:ts,backendName:"webgl",kernelFunc:Gre},jre=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;let r=n.length,a=lt(n.length),s=lt(n.length),i="";if(r===1)i="coords * strides + begin";else{let o=0;i=n.map((l,p)=>(o++,n.length===1?`coords * strides[${p}] + begin[${p}]`:`coords[${o-1}] * strides[${p}] + begin[${p}]`)).join(",")}this.userCode=`
      ${a} begin = ${a}(${e});
      ${a} strides = ${a}(${t});

      void main() {
        ${s} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}};function qre(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,end:i,strides:o,beginMask:l,endMask:p,ellipsisMask:u,newAxisMask:d,shrinkAxisMask:h}=r,{finalShapeSparse:c,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:x,strides:v}=Lt.sliceInfo(a.shape,s,i,o,l,p,u,d,h),I;if(m)I=ue({inputs:{x:a},backend:n,attrs:{shape:f}});else if(g||y){w.assert(a.shape.length>=1,()=>`Input must have rank at least 1, got: ${a.shape.length}`);let _=Lt.computeOutShape(b,x,v),E=Au({inputs:{x:a},backend:n,attrs:{begin:b,size:_}});I=ue({inputs:{x:E},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(E)}else if(n.shouldExecuteOnCPU([a])){let _=n.readSync(a.dataId),E=ze(a.shape,a.dtype,_),A=uZ(c,E,v,b);I=n.makeTensorInfo(f,a.dtype,A.values)}else{let _=new jre(b,v,c);I=n.runWebGLProgram(_,[a],a.dtype)}let T=ue({inputs:{x:I},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(I),T}var Kre={kernelName:iu,backendName:"webgl",kernelFunc:qre};function Xre(e){let{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:p}=r,{data:u,dataSplits:d}=t,h=n.readSync(u.dataId),c=n.readSync(d.dataId),[f,m]=pZ(h,c,a,s,i,o,l,p);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}var Zre={kernelName:Pp,backendName:"webgl",kernelFunc:Xre};function Jre(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:s,delimiter:i}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.readSync(s.dataId),l=n.readSync(i.dataId)[0],[p,u,d]=dZ(o,l,a),h=u.length;return[n.makeTensorInfo([h,2],"int32",p),n.makeTensorInfo([h],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(d))]}var Yre={kernelName:Bp,backendName:"webgl",kernelFunc:Jre};function Qre(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");let i=n.readSync(s.dataId),o=hZ(i,a);return n.makeTensorInfo(s.shape,"int32",o)}var eae={kernelName:Wp,backendName:"webgl",kernelFunc:Qre},tae="return tan(x);",nae=Ke({opSnippet:tae}),rae={kernelName:go,backendName:"webgl",kernelFunc:nae},aae=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,sae=Ke({opSnippet:aae}),iae={kernelName:yo,backendName:"webgl",kernelFunc:sae};function oae(e){let{inputs:t,backend:n,attrs:r}=e,{tensor:a,indices:s,updates:i}=t,{sliceRank:o,numUpdates:l,sliceSize:p,strides:u,outputSize:d}=N.calculateShapes(i,s,a.shape),h=[d/p,p];if(d===0)return n.makeTensorInfo(a.shape,s.dtype);let c=ue({inputs:{x:s},backend:n,attrs:{shape:[l,o]}}),f=ue({inputs:{x:i},backend:n,attrs:{shape:[l,p]}}),m=ue({inputs:{x:a},backend:n,attrs:{shape:h}}),g=new Gx(l,o,c.shape.length,f.shape.length,u,h,!1,!0),y=n.runWebGLProgram(g,[f,c,m],m.dtype),b=ue({inputs:{x:y},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),b}var lae={kernelName:Yl,backendName:"webgl",kernelFunc:oae},uae=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[s]*t[s];this.outputShape=n,this.rank=n.length;let r=lt(this.rank),a=pae(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${a}));
      }
    `}};function pae(e){let t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${e[0]})`;let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let a=0;a<e.length;a++)r.push(`imod(${n[a]}, ${e[a]})`);return r.join()}function YT(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:s}=r;if(a.dtype==="string"||a.shape.length>5){let o=n.readSync(a.dataId),l=a.dtype==="string"?o.map(d=>w.decodeString(d)):o,p=ze(a.shape,a.dtype,l),u=fZ(p,s);return n.makeTensorInfo(u.shape,u.dtype,u.values)}let i=new uae(a.shape,s);return n.runWebGLProgram(i,[a],a.dtype)}var dae={kernelName:es,backendName:"webgl",kernelFunc:YT},hae=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},cae=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};function ys(e,t){t!==null&&e.disposeIntermediateTensorInfo(t)}function c0(e){let t=1;for(;t<e;)t*=2;return t}function fae(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:i}=r,o=G().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=G().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),p=a.shape,u=p[p.length-1];if(n.shouldExecuteOnCPU([a])||u<o||s>l){let A=n.readSync(a.dataId),[R,F]=mZ(A,p,a.dtype,s,i);return[n.makeTensorInfo(R.shape,R.dtype,R.values),n.makeTensorInfo(F.shape,F.dtype,F.values)]}if(s===0)return p[p.length-1]=0,[n.makeTensorInfo(p,a.dtype,[]),n.makeTensorInfo(p,"int32",[])];if(u===1)return[a,kd({attrs:{shape:p,dtype:"int32",value:0},backend:n})];let d=n.texData.get(a.dataId),h=d!==null&&d.isPacked,c=h?n.unpackTensor(a):a,f=w.sizeFromShape(p)/u,m=ue({inputs:{x:c},attrs:{shape:[f,u]},backend:n});h&&ys(n,c);let g=c0(s),y=c0(u),b=null,x=()=>b===null?[m,m]:[m,b],v=(A,R,F)=>{let S=x(),M=new hae(F),W=[[u],[b===null?1:0],[Number.NEGATIVE_INFINITY],[A],[R]],U=b;b=n.runWebGLProgram(M,S,"int32",W),ys(n,U)};for(let A=1;A<g;A*=2){let R=A*2;for(let F=A;F>=1;F/=2)v(R,F,[f,y])}for(let A=y;A>g;A/=2){let R=x(),F=new cae([f,A/2]),S=[[u],[b===null?1:0],[g]],M=b;b=n.runWebGLProgram(F,R,"int32",S),ys(n,M);let W=g/2,U=W*2;for(let H=W;H>=1;H/=2)v(U,H,b.shape)}let I=b;b=Au({inputs:{x:b},backend:n,attrs:{begin:0,size:[f,s]}}),ys(n,I);let T=GT({inputs:{x:m,indices:b},backend:n,attrs:{axis:1,batchDims:1}});ys(n,m);let _=p.slice(0,-1);_.push(s),I=b,b=ue({inputs:{x:b},attrs:{shape:_},backend:n}),ys(n,I);let E=T;return T=ue({inputs:{x:T},attrs:{shape:_},backend:n}),ys(n,E),[T,b]}var mae={kernelName:ou,backendName:"webgl",kernelFunc:fae},gae=class{constructor(e,t,n,r,a,s){this.variableNames=["Image","Transforms"],this.outputShape=s;let i=n==="nearest"?1:2,o;switch(r){case"constant":o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4;break;default:o=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${o} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${o} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${o} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${a});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${a});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${i} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function yae(e){let{inputs:t,backend:n,attrs:r}=e,{image:a,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:p}=r,[u,d,h,c]=a.shape,[f,m]=p??[d,h],g=[u,f,m,c],y=new gae(d,h,i,o,l,g);return n.runWebGLProgram(y,[a,s],"float32")}var bae={kernelName:lu,backendName:"webgl",kernelFunc:yae};function xae(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t;Su(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let i=r.readSync(s.dataId),{outputValues:o,outputShape:l,indices:p}=gZ(i,a,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,o),r.makeTensorInfo([p.length],"int32",p)]}var vae={kernelName:Vp,backendName:"webgl",kernelFunc:xae};function wae(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:s}=r;s<0&&(s+=a.shape.length);let i=a,o=i.shape.length,l=a.shape[s],p=new Array(o-1),u=0;for(let m=0;m<o;m++)m!==s&&(p[u++]=i.shape[m]);let d=[],h=new Array(o).fill(0),c=i.shape.slice();c[s]=1;let f=new Array(l);for(let m=0;m<f.length;m++){h[s]=m;let g=Au({inputs:{x:i},backend:n,attrs:{begin:h,size:c}}),y=ue({inputs:{x:g},backend:n,attrs:{shape:p}});f[m]=y,d.push(g)}return d.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}var kae={kernelName:uu,backendName:"webgl",kernelFunc:wae},Iae=class{constructor(e,t){this.variableNames=["x","segmentIds"];let n=e.windowSize,r=e.batchSize,a=e.inSize,s=e.numSegments,i=s*Math.ceil(a/n);this.outputShape=[r,i];let o="0.0",l="sumValue",p=Math.floor(n/4)*4,u=n%4,d=`
        sumValue += dot(values, segFilter);
    `,h="";a%n>0&&(h=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `);let c="";a%n>0&&(c=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${o};

      float getValue(int batch, int inIdx) {
        ${h}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${c}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${s})) * float(${n}));
        int currentSeg = int(mod(float(outIdx), float(${s})));

        float sumValue = 0.0;

        for (int i = 0; i < ${p}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${d}
        }

        int inIdx = inOffset + ${p};
        if (${u===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${d}
        } else if (${u===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${d}
        } else if (${u===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${d}
        }
        setOutput(${l});
      }
    `}};function Sae(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:s}=t,{numSegments:i}=r,o=a.shape.length,l=[],p=0,u=N.getAxesPermutation([p],o),d=a;u!=null&&(d=mn({inputs:{x:a},backend:n,attrs:{perm:u}}),l.push(d),p=N.getInnerMostAxes(1,o)[0]);let h=N.segment_util.computeOutShape(d.shape,p,i),c=w.sizeFromShape([d.shape[p]]),f=ue({inputs:{x:d},backend:n,attrs:{shape:[-1,c]}});l.push(f);let m=uc(a.dtype),g=(v,I,T,_,E)=>{let A=v.shape[0],R=v.shape[1],F=N.segment_util.segOpComputeOptimalWindowSize(R,E),S={windowSize:F,inSize:R,batchSize:A,numSegments:E},M=new Iae(S,I),W=n.compileAndRun(M,[v,T],_);if(l.push(W),W.shape[1]===E)return W;let U=JT({backend:n,attrs:{start:0,stop:E,step:1,dtype:"float32"}}),H=YT({inputs:{x:U},backend:n,attrs:{reps:[R/F]}});return l.push(U),l.push(H),g(W,I,H,_,E)},y=g(f,"unsortedSegmentSum",s,m,i),b=ue({inputs:{x:y},backend:n,attrs:{shape:h}}),x=b;if(u!=null){l.push(b);let v=N.getUndoAxesPermutation(u);x=mn({inputs:{x},backend:n,attrs:{perm:v}})}return l.forEach(v=>n.disposeIntermediateTensorInfo(v)),x}var Nae={kernelName:Up,backendName:"webgl",kernelFunc:Sae},Tae=[uJ,dJ,fJ,yJ,xJ,kJ,SJ,TJ,$J,FJ,MJ,zJ,WJ,HJ,KJ,ZJ,YJ,n9,a9,i9,p9,y9,x9,I9,N9,A9,R9,L9,jZ,B9,H9,X9,tY,aY,iY,lY,pY,fY,yY,vY,kY,SY,TY,EY,AY,MY,LY,BY,UY,HY,XY,QY,rQ,iQ,uQ,pQ,hQ,fQ,gQ,bQ,vQ,SQ,CQ,$Q,FQ,MQ,zQ,VQ,jQ,HZ,KQ,U9,JQ,eee,ree,KZ,oee,dee,cee,yee,vee,See,Cee,Aee,Mee,zee,Bee,Gee,jee,Kee,Yee,ete,nte,ate,ite,pte,fte,bte,Tte,JZ,$te,Rte,Ote,Pte,C9,Vte,Gte,jte,Xte,Qte,ZZ,tne,rne,sne,one,lne,_9,kte,dne,mne,xne,QZ,Ine,Tne,$ne,Rne,Lne,Pne,Vne,Hne,Kne,Jne,ere,rre,ore,pre,fre,yre,m9,Ste,vre,kre,Sre,Tre,_re,$re,Fre,Dre,Ore,Pre,Wre,Ure,Hre,Kre,Zre,Yre,eae,Ite,iJ,rae,iae,lae,dae,mae,bae,oJ,vae,kae,Nae,Ute];for(let e of Tae)Gp(e);var Ze;(function(e){e[e.float32=0]="float32",e[e.int32=1]="int32",e[e.bool=2]="bool",e[e.string=3]="string",e[e.complex64=4]="complex64"})(Ze||(Ze={}));var vp;(function(e){e[e.linear=0]="linear",e[e.relu=1]="relu",e[e.relu6=2]="relu6",e[e.prelu=3]="prelu",e[e.leakyrelu=4]="leakyrelu",e[e.sigmoid=5]="sigmoid",e[e.elu=6]="elu"})(vp||(vp={}));var QT;function Cae(e){QT=e.wasm.cwrap(Fs,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])}function _ae(e){let{inputs:t,backend:n,attrs:r}=e,{a,b:s,bias:i,preluActivationWeights:o}=t;if(a.dtype!=="float32"||s.dtype!=="float32")throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:l,transposeB:p,activation:u,leakyreluAlpha:d}=r,h=n.dataIdMap.get(a.dataId).id,c=n.dataIdMap.get(s.dataId).id,f=0;if(i!=null){let E=n.dataIdMap.get(i.dataId);if(E.shape.length!==1)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${E.shape.length}.`);f=E.id}let m=o==null?0:n.dataIdMap.get(o.dataId).id,g=vp[u];if(g==null)throw new Error(`${u} activation not yet supported for FusedConv2D in the wasm backend.`);let y=l?a.shape[2]:a.shape[1],b=p?s.shape[1]:s.shape[2],x=hu.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)),v=n.makeOutput([...x,y,b],a.dtype),I=n.dataIdMap.get(v.dataId).id,T=new Uint8Array(new Int32Array(a.shape).buffer),_=new Uint8Array(new Int32Array(s.shape).buffer);return QT(h,T,a.shape.length,c,_,s.shape.length,l,p,g,f,m,d||0,I),v}var Eae={kernelName:Fs,backendName:"wasm",setupFunc:Cae,kernelFunc:_ae};function je(e,t){let n;function r(s){n=s.wasm.cwrap(e,null,["number","number","number"])}function a(s){let{backend:i,inputs:{x:o}}=s,l=i.dataIdMap.get(o.dataId).id,p=i.makeOutput(o.shape,t||o.dtype),u=i.dataIdMap.get(p.dataId).id;return w.sizeFromShape(p.shape)===0||n(l,Ze[o.dtype],u),p}return{kernelName:e,backendName:"wasm",setupFunc:r,kernelFunc:a}}var $ae=je(pl),Aae=je(Qs),Fae=je(ei);function Dt(e,t,n){let r;function a(i){r=i.wasm.cwrap(e,null,["number","array","number","number","array","number","number","number"])}function s(i){let{backend:o,inputs:l}=i,{a:p,b:u}=l,d=o.dataIdMap.get(p.dataId).id,h=o.dataIdMap.get(u.dataId).id,c=n??p.dtype,f=N.assertAndGetBroadcastShape(p.shape,u.shape),m=o.makeOutput(f,c);if(w.sizeFromShape(f)===0)return m;let g=new Uint8Array(new Int32Array(p.shape).buffer),y=new Uint8Array(new Int32Array(u.shape).buffer),b=o.dataIdMap.get(m.dataId).id;return r(d,g,p.shape.length,h,y,u.shape.length,Ze[p.dtype],b),m}return{kernelName:e,backendName:"wasm",setupFunc:a,kernelFunc:s}}var Rae=Dt(Ya),eC;function Dae(e){eC=e.wasm.cwrap(ti,null,["array","number","number","number"])}function Mae(e){let{inputs:t,backend:n}=e,r=n.makeOutput(t[0].shape,t[0].dtype);if(w.sizeFromShape(r.shape)===0)return r;let a=t.map(o=>n.dataIdMap.get(o.dataId).id),s=new Uint8Array(new Int32Array(a).buffer),i=n.dataIdMap.get(r.dataId).id;return eC(s,a.length,Ze[r.dtype],i),r}var Oae={kernelName:ti,backendName:"wasm",setupFunc:Dae,kernelFunc:Mae};function xf(e){let{inputs:{x:t},backend:n}=e;if(t.dtype==="string")return cn(n.readSync(t.dataId),t.shape,t.dtype);let r=n.makeOutput(t.shape,t.dtype),a=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(r).set(a),r}var Lae={kernelName:_i,backendName:"wasm",kernelFunc:xf},tC;function zae(e){tC=e.wasm.cwrap(sa,null,["number","array","number","number","number","array","number"])}function Xa(e){let{inputs:t,backend:n,attrs:r}=e,[a,s]=Bae(t.x.shape,r.perm),i=!0;for(let f=0;f<s.length;f++)s[f]!==f&&(i=!1);let o=Pae(t.x.shape,r.perm),l={dataId:t.x.dataId,shape:a,dtype:t.x.dtype};if(i){let f=xf({inputs:t,backend:n});return f.shape=o,f}let p=n.makeOutput(o,l.dtype),u=n.dataIdMap.get(l.dataId).id,d=n.dataIdMap.get(p.dataId).id,h=new Uint8Array(new Int32Array(s).buffer),c=new Uint8Array(new Int32Array(l.shape).buffer);return tC(u,c,l.shape.length,Ze[l.dtype],d,h,s.length),p}function Pae(e,t){let n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];return n}function Bae(e,t){let n=[],r=[];for(let a=0;a<e.length;++a)e[a]!==1&&n.push(e[a]),e[t[a]]!==1&&r.push(t[a]);for(let a=0;a<r.length;++a){let s=-1;for(let i=0;i<r.length;++i)r[i]>=a&&(s===-1||r[s]>r[i])&&(s=i);r[s]=a}return[n,r]}var Wae={kernelName:sa,backendName:"wasm",kernelFunc:Xa,setupFunc:zae};function us(e,t,n){let r=e.shape,a=e.shape.length,s=w.parseAxisParam(t,r),i=s,o=N.getAxesPermutation(i,a),l=null,p=!1;if(o!=null){let u=new Array(a);for(let h=0;h<u.length;h++)u[h]=r[o[h]];i=N.getInnerMostAxes(i.length,a),l=Xa({inputs:{x:e},attrs:{perm:o},backend:n});let d=n.dataIdMap.get(e.dataId).id;n.dataIdMap.get(l.dataId).id!==d&&(p=!0)}return{transposed:l,originalAxes:s,axes:i,inputWasTransposed:p}}var nC;function Vae(e){nC=e.wasm.cwrap(dl,null,["number, number, number"])}function Uae(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:p,axes:u,originalAxes:d,inputWasTransposed:h}=us(i,a,t);if(h){let b=t.dataIdMap.get(p.dataId).id;l=p,o=b}let c=l.shape.length;N.assertAxesAreInnerMostDims("all",u,c);let[f,m]=N.computeOutAndReduceShapes(l.shape,u),g=w.sizeFromShape(m),y=t.makeOutput(f,i.dtype);if(w.sizeFromShape(l.shape)!==0){let b=t.dataIdMap.get(y.dataId).id;nC(o,g,b)}if(h&&t.disposeData(p.dataId),s){let b=N.expandShapeToKeepDim(y.shape,d);y.shape=b}return y}var Gae={kernelName:dl,backendName:"wasm",setupFunc:Vae,kernelFunc:Uae},rC;function Hae(e){rC=e.wasm.cwrap(hl,null,["number, number, number"])}function jae(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:p,axes:u,originalAxes:d,inputWasTransposed:h}=us(i,a,t);if(h){let b=t.dataIdMap.get(p.dataId).id;l=p,o=b}let c=l.shape.length;N.assertAxesAreInnerMostDims("any",u,c);let[f,m]=N.computeOutAndReduceShapes(l.shape,u),g=w.sizeFromShape(m),y=t.makeOutput(f,i.dtype);if(w.sizeFromShape(l.shape)!==0){let b=t.dataIdMap.get(y.dataId).id;rC(o,g,b)}if(h&&t.disposeData(p.dataId),s){let b=N.expandShapeToKeepDim(y.shape,d);y.shape=b}return y}var qae={kernelName:hl,backendName:"wasm",setupFunc:Hae,kernelFunc:jae};function aC(e){let t;function n(a){t=a.wasm.cwrap(e,null,["number","number","number","number","number"])}function r(a){let{backend:s,inputs:i,attrs:o}=a,{axis:l}=o,{x:p}=i,u=s.dataIdMap.get(p.dataId).id,d=u,h=p,{transposed:c,axes:f,inputWasTransposed:m}=us(p,l,s);if(m){let I=s.dataIdMap.get(c.dataId).id;I!==u&&(h=c,d=I)}let g=h.shape.slice(0,-1),y=s.makeOutput(g,"int32"),b=s.dataIdMap.get(y.dataId).id,x=w.sizeFromShape(y.shape),v=h.shape[f[0]];return t(d,Ze[h.dtype],x,v,b),m&&s.disposeData(c.dataId),y}return{kernelName:e,backendName:"wasm",setupFunc:n,kernelFunc:r}}var Kae=aC(cl),Xae=aC(fl),Zae=je(ni),Jae=je(ri),Yae=je(ai),Qae=Dt(ii),ese=je(si),sC;function tse(e){sC=e.wasm.cwrap(oi,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function nse(e){let{inputs:t,attrs:n,backend:r}=e,a=t.x,s=r.dataIdMap.get(a.dataId).id,{filterSize:i,strides:o,pad:l,dimRoundingMode:p}=n,u=N.computePool2DInfo(a.shape,i,o,1,l,p),d=u.filterHeight,h=u.filterWidth,c=u.padInfo.top,f=u.padInfo.right,m=u.padInfo.bottom,g=u.padInfo.left,y=u.strideHeight,b=u.strideWidth,x=u.inChannels;if(u.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${u.dataFormat}'. Please use 'channelsLast'.`);if(u.dilationWidth!==1||u.dilationHeight!==1)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${u.dilationHeight}, ${u.dilationWidth}].`);let v=r.makeOutput(u.outShape,"float32"),I=r.dataIdMap.get(v.dataId).id;return sC(s,a.shape[0],a.shape[1],a.shape[2],d,h,c,f,m,g,y,b,x,I),v}var rse={kernelName:oi,backendName:"wasm",setupFunc:tse,kernelFunc:nse},iC;function ase(e){iC=e.wasm.cwrap("AvgPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function sse(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:p}=r,u=N.computePool3DInfo(a.shape,s,i,1,o,l,p),d=n.makeOutput(u.outShape,a.dtype);return iC(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,u.batchSize,u.inChannels,u.inDepth,u.inHeight,u.inWidth,u.outDepth,u.outHeight,u.outWidth,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.effectiveFilterDepth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),d}var ise={kernelName:ml,backendName:"wasm",setupFunc:ase,kernelFunc:sse},oC;function ose(e){oC=e.wasm.cwrap("AvgPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function lse(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:p}=r,u=N.computePool3DInfo(s.shape,i,o,1,l,p),d=n.makeOutput(s.shape,s.dtype);return oC(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,u.batchSize,u.inChannels,u.inDepth,u.inHeight,u.inWidth,u.outDepth,u.outHeight,u.outWidth,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.effectiveFilterDepth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left,u.filterDepth,u.filterHeight,u.filterWidth),d}var use={kernelName:Sp,backendName:"wasm",setupFunc:ose,kernelFunc:lse},lC;function pse(e){lC=e.wasm.cwrap("AvgPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function dse(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l}=r,p=N.computePool2DInfo(s.shape,i,o,1,l),u=n.makeOutput(s.shape,s.dtype);return lC(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(u.dataId).id,p.batchSize,p.inChannels,p.inHeight,p.inWidth,p.outHeight,p.outWidth,p.strideHeight,p.strideWidth,p.dilationHeight,p.dilationWidth,p.effectiveFilterHeight,p.effectiveFilterWidth,p.padInfo.top,p.padInfo.left,p.filterHeight,p.filterWidth),u}var hse={kernelName:Ip,backendName:"wasm",setupFunc:pse,kernelFunc:dse};function Cn(e){let{inputs:t,attrs:n}=e,{x:r}=t,{shape:a}=n,s=w.sizeFromShape(r.shape),i=w.inferFromImplicitShape(a,s);return w.assert(s===w.sizeFromShape(i),()=>`new shape: ${i}, old shape: ${r.shape}. New shape and old shape must have the same number of elements.`),e.backend.incRef(r.dataId),{dataId:r.dataId,shape:i,dtype:r.dtype}}var cse={kernelName:Kl,backendName:"wasm",kernelFunc:Cn},uC;function fse(e){uC=e.wasm.cwrap(li,null,["number","array","number","number","array","number","number","number","number"])}function mse(e){let{inputs:t,backend:n,attrs:r}=e,{a,b:s}=t,{transposeA:i,transposeB:o}=r;if(a.dtype!=="float32"||s.dtype!=="float32")throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let l=a.shape.length,p=s.shape.length,u=i?a.shape[l-2]:a.shape[l-1],d=o?s.shape[p-1]:s.shape[p-2],h=i?a.shape[l-1]:a.shape[l-2],c=o?s.shape[p-2]:s.shape[p-1],f=a.shape.slice(0,-2),m=s.shape.slice(0,-2),g=w.sizeFromShape(f),y=w.sizeFromShape(m),b=hu.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)).concat([h,c]);w.assert(u===d,()=>`Error in matMul: inner shapes (${u}) and (${d}) of Tensors with shapes ${a.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`);let x=i?[g,u,h]:[g,h,u],v=o?[y,c,d]:[y,d,c],I=Cn({inputs:{x:a},backend:n,attrs:{shape:x}}),T=Cn({inputs:{x:s},backend:n,attrs:{shape:v}}),_=n.dataIdMap.get(I.dataId).id,E=n.dataIdMap.get(T.dataId).id,A=i?I.shape[2]:I.shape[1],R=o?T.shape[1]:T.shape[2],F=Math.max(g,y),S=n.makeOutput([F,A,R],I.dtype),M=n.dataIdMap.get(S.dataId).id,W=new Uint8Array(new Int32Array(I.shape).buffer),U=new Uint8Array(new Int32Array(T.shape).buffer);return uC(_,W,I.shape.length,E,U,T.shape.length,i,o,M),n.disposeData(I.dataId),n.disposeData(T.dataId),S.shape=b,S}var gse={kernelName:li,backendName:"wasm",setupFunc:fse,kernelFunc:mse};function Zs(e){let{inputs:{x:t},attrs:{begin:n,size:r},backend:a}=e,[s,i]=Lt.parseSliceParams(t,n,r),o=Lt.isSliceContinous(t.shape,s,i),l=a.readSync(t.dataId),p=a.makeOutput(i,t.dtype),u=w.computeStrides(t.shape),d=a.dataIdMap.get(p.dataId);if(o){let f=Lt.computeFlatOffset(s,u);return t.dtype==="string"?d.stringBytes=l.slice(f,f+w.sizeFromShape(i)):a.typedArrayFromHeap(p).set(l.subarray(f,f+w.sizeFromShape(i))),p}if(t.dtype==="string"){let f=Rh(l,s,i,t.shape,t.dtype);return d.stringBytes=f,p}let h=a.typedArrayFromHeap(p),c=t.shape.length;if(c===2)yse(l,u[0],h,s,i);else if(c===3)bse(l,u[0],u[1],h,s,i);else if(c===4)xse(l,u[0],u[1],u[2],h,s,i);else{let f=Rh(l,s,i,t.shape,t.dtype);h.set(f)}return p}function yse(e,t,n,r,a){let s=0,i=r[0],o=r[1],l=i+a[0];for(let p=i;p<l;p++){let u=p*t+o;n.set(e.subarray(u,u+a[1]),s),s+=a[1]}}function bse(e,t,n,r,a,s){let i=0,o=a[0],l=a[1],p=a[2],u=o+s[0],d=l+s[1];for(let h=o;h<u;h++)for(let c=l;c<d;c++){let f=h*t+c*n+p;r.set(e.subarray(f,f+s[2]),i),i+=s[2]}}function xse(e,t,n,r,a,s,i){let o=0,l=s[0],p=s[1],u=s[2],d=l+i[0],h=p+i[1],c=u+i[2],f=s[3];for(let m=l;m<d;m++)for(let g=p;g<h;g++)for(let y=u;y<c;y++){let b=m*t+g*n+y*r+f;a.set(e.subarray(b,b+i[3]),o),o+=i[3]}}var vse={kernelName:tu,backendName:"wasm",kernelFunc:Zs};function wse(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r,o=s.reduce((y,b)=>y*b),l=N.getReshaped(a.shape,s,o),p=N.getPermuted(l.length,s.length),u=N.getReshapedPermuted(a.shape,s,o),d=N.getSliceBeginCoords(i,s.length),h=N.getSliceSize(u,i,s.length),c=Cn({inputs:{x:a},backend:n,attrs:{shape:l}}),f=Xa({inputs:{x:c},backend:n,attrs:{perm:p}}),m=Cn({inputs:{x:f},backend:n,attrs:{shape:u}}),g=Zs({inputs:{x:m},backend:n,attrs:{begin:d,size:h}});return n.disposeData(c.dataId),n.disposeData(f.dataId),n.disposeData(m.dataId),g}var kse={kernelName:gl,backendName:"wasm",kernelFunc:wse},pC;function Ise(e){pC=e.wasm.cwrap(yl,null,["number","number","boolean","number","number","number"])}function Sse(e){let{backend:t,inputs:n,attrs:r}=e,{x:a,weights:s}=n,{size:i}=r,o=s.shape.reduce((d,h)=>d*h,1)!==0,l=a.shape.length===1?[i]:[a.shape[0],i],p=t.makeOutput(l,s.dtype);function u(d){return t.dataIdMap.get(d.dataId).id}return pC(u(a),i,o,u(s),Ze[s.dtype],u(p)),p}var Nse={kernelName:yl,backendName:"wasm",setupFunc:Ise,kernelFunc:Sse},Tse=Dt(bl);function Cse(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.typedArrayFromHeap(r),i=n.typedArrayFromHeap(a),o=N.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeOutput([o.length],"int32",void 0,new Int32Array(o))}var _se={kernelName:Np,backendName:"wasm",kernelFunc:Cse};function ps(e){let{inputs:{x:t},attrs:{dtype:n},backend:r}=e,a=r.makeOutput(t.shape,n),s=r.typedArrayFromHeap(t);return r.typedArrayFromHeap(a).set(s),a}var Ese={kernelName:ui,backendName:"wasm",kernelFunc:ps},$se=je(pi),dC;function Ase(e){dC=e.wasm.cwrap(Qa,null,["number","number","number","number"])}function Fse(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{clipValueMin:s,clipValueMax:i}=r,o=n.dataIdMap.get(a.dataId).id,l=n.makeOutput(a.shape,a.dtype),p=n.dataIdMap.get(l.dataId).id;return dC(o,s,i,p),l}var Rse={kernelName:Qa,backendName:"wasm",setupFunc:Ase,kernelFunc:Fse};function hC(e){let{inputs:t,backend:n}=e,r=w.parseAxisParam(e.attrs.axis,t[0].shape)[0],a=t.map(c=>c.shape);N.assertParamsConsistent(a,r);let s=N.computeOutShape(t.map(c=>c.shape),r),i=t.filter(c=>w.sizeFromShape(c.shape)>0);if(i.length===1)return xf({inputs:{x:i[0]},backend:n});let o=n.makeOutput(s,t[0].dtype);if(w.sizeFromShape(s)===0)return o;if(i[0].dtype==="string"){let c=i.map(x=>{let v=[-1,w.sizeFromShape(x.shape.slice(r))];return Cn({inputs:{x},backend:n,attrs:{shape:v}})}),f=c.map(x=>({vals:n.readSync(x.dataId),shape:x.shape}));s=N.computeOutShape(c.map(x=>x.shape),1);let m=c[0].shape[0]===1,g=gx(f,s,t[0].dtype,m),y=N.computeOutShape(i.map(x=>x.shape),r);o.shape=y;let b=n.dataIdMap.get(o.dataId);return b.stringBytes=N.fromStringArrayToUint8(g),c.forEach(x=>n.disposeData(x.dataId)),o}let l=w.sizeFromShape(i[0].shape.slice(0,r)),p=0,u=i.map(c=>{let f=w.sizeFromShape(c.shape.slice(r));return p+=f,f}),d=i.map(c=>n.typedArrayFromHeap(c)),h=n.typedArrayFromHeap(o);for(let c=0;c<l;c++){let f=c*p;for(let m=0;m<d.length;m++){let g=u[m],y=c*g,b=d[m].subarray(y,y+g);h.set(b,f),f+=g}}return o}var Dse={kernelName:xl,backendName:"wasm",kernelFunc:hC},cC;function Mse(e){cC=e.wasm.cwrap(di,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Ose(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s}=t,i=r.dataIdMap.get(a.dataId).id,o=r.dataIdMap.get(s.dataId).id,{strides:l,dilations:p,pad:u,dimRoundingMode:d,dataFormat:h}=n,c=N.convertConv2DDataFormat(h),f=N.computeConv2DInfo(a.shape,s.shape,l,p,u,d,!1,c),m=f.filterHeight,g=f.filterWidth,y=f.padInfo.top,b=f.padInfo.right,x=f.padInfo.bottom,v=f.padInfo.left,I=f.dilationHeight,T=f.dilationWidth,_=f.strideHeight,E=f.strideWidth,A=f.inChannels,R=f.outChannels,F=f.padInfo.type==="SAME"?1:0;if(f.dataFormat!=="channelsLast")throw new Error(`wasm backend Conv2D does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);let S=r.makeOutput(f.outShape,"float32"),M=r.dataIdMap.get(S.dataId).id;return cC(i,a.shape[0],a.shape[1],a.shape[2],o,m,g,y,b,x,v,F,I,T,_,E,A,R,M),S}var Lse={kernelName:di,backendName:"wasm",setupFunc:Mse,kernelFunc:Ose},fC;function zse(e){fC=e.wasm.cwrap(hi,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Pse(e){let{backend:t,inputs:n,attrs:r}=e,{dy:a,filter:s}=n,{strides:i,pad:o,dataFormat:l,dimRoundingMode:p,inputShape:u}=r,d=1,h=N.convertConv2DDataFormat(l),c=N.computeConv2DInfo(u,s.shape,i,d,o,p,!1,h),{batchSize:f,filterHeight:m,filterWidth:g,inChannels:y,inHeight:b,inWidth:x,outChannels:v,outHeight:I,outWidth:T,strideHeight:_,strideWidth:E}=c,A=m-1-c.padInfo.top,R=g-1-c.padInfo.left,F=c.dataFormat==="channelsLast",S=w.computeStrides(c.inShape),M=w.computeStrides(a.shape),[W,U,H]=w.computeStrides(s.shape),K=S[0],j=F?S[1]:S[2],Z=F?S[2]:1,ee=F?1:S[1],Y=M[0],re=F?M[1]:M[2],te=F?M[2]:1,ae=F?1:M[1],ie=t.makeOutput(c.inShape,"float32"),ve=t.dataIdMap.get(ie.dataId).id,be=t.dataIdMap.get(a.dataId).id,he=t.dataIdMap.get(s.dataId).id;return fC(be,he,f,m,g,b,x,y,I,T,v,_,E,A,R,W,U,H,K,j,Z,ee,Y,re,te,ae,ve),ie}var Bse={kernelName:hi,backendName:"wasm",setupFunc:zse,kernelFunc:Pse},mC;function Wse(e){mC=e.wasm.cwrap(ci,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Vse(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r;if(a.dtype!=="float32")throw new Error(`Tensor x must have dtype float32, got ${a.dtype}`);if(s.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let p=N.computeConv3DInfo(a.shape,s.shape,i,l,o),u=n.makeOutput(p.outShape,a.dtype);return mC(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(u.dataId).id,p.batchSize,p.inDepth,p.inHeight,p.inWidth,p.inChannels,p.outDepth,p.outHeight,p.outWidth,p.outChannels,p.strideDepth,p.strideHeight,p.strideWidth,p.dilationDepth,p.dilationHeight,p.dilationWidth,p.filterDepth,p.filterHeight,p.filterWidth,p.padInfo.front,p.padInfo.top,p.padInfo.left),u}var Use={kernelName:ci,backendName:"wasm",setupFunc:Wse,kernelFunc:Vse},gC;function Gse(e){gC=e.wasm.cwrap(vl,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Hse(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r;if(a.dtype!=="float32")throw new Error(`Tensor dy must have dtype float32, got ${a.dtype}`);if(s.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let p=N.computeConv3DInfo(a.shape,l,i,1,o),u=n.makeOutput(p.filterShape,s.dtype);return gC(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(u.dataId).id,p.batchSize,p.inDepth,p.inHeight,p.inWidth,p.inChannels,p.outDepth,p.outHeight,p.outWidth,p.outChannels,p.strideDepth,p.strideHeight,p.strideWidth,p.dilationDepth,p.dilationHeight,p.dilationWidth,p.filterDepth,p.filterHeight,p.filterWidth,p.padInfo.front,p.padInfo.top,p.padInfo.left),u}var jse={kernelName:vl,backendName:"wasm",setupFunc:Gse,kernelFunc:Hse},yC;function qse(e){yC=e.wasm.cwrap(wl,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Kse(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r;if(a.dtype!=="float32")throw new Error(`Tensor dy must have dtype float32, got ${a.dtype}`);if(s.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let p=N.computeConv3DInfo(l,s.shape,o,1,i),u=n.makeOutput(p.inShape,a.dtype);return yC(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(u.dataId).id,p.batchSize,p.inDepth,p.inHeight,p.inWidth,p.inChannels,p.outDepth,p.outHeight,p.outWidth,p.outChannels,p.strideDepth,p.strideHeight,p.strideWidth,p.dilationDepth,p.dilationHeight,p.dilationWidth,p.filterDepth,p.filterHeight,p.filterWidth,p.padInfo.front,p.padInfo.top,p.padInfo.left),u}var Xse={kernelName:wl,backendName:"wasm",setupFunc:qse,kernelFunc:Kse},Zse=je(fi),Jse=je(mi),Hm;(function(e){e[e.bilinear=0]="bilinear",e[e.nearest=1]="nearest"})(Hm||(Hm={}));var bC;function Yse(e){bC=e.wasm.cwrap(Il,null,["number","number","number","number","array","number","number","number","number","number"])}function Qse(e){let{backend:t,inputs:n,attrs:r}=e,{method:a,extrapolationValue:s,cropSize:i}=r,{image:o,boxes:l,boxInd:p}=n,u=l.shape[0],[d,h]=i,c=[u,d,h,o.shape[3]],f=t.dataIdMap.get(o.dataId),m;o.dtype!=="float32"&&(m=ps({backend:t,inputs:{x:o},attrs:{dtype:"float32"}}),f=t.dataIdMap.get(m.dataId));let g=f.id,y=t.dataIdMap.get(l.dataId).id,b=t.dataIdMap.get(p.dataId).id,x=t.makeOutput(c,"float32"),v=t.dataIdMap.get(x.dataId).id,I=new Uint8Array(new Int32Array(o.shape).buffer);return bC(g,y,b,u,I,d,h,Hm[a],s,v),m!=null&&t.disposeData(m.dataId),x}var eie={kernelName:Il,backendName:"wasm",setupFunc:Yse,kernelFunc:Qse},xC;function tie(e){xC=e.wasm.cwrap(kl,null,["number","number","number","number","number","number"])}function nie(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r,l=a.shape.length;w.assert(a.dtype==="float32"||a.dtype==="int32",()=>`cumprod does not support ${a.dtype} tensors in the WASM backend`);let p=N.getAxesPermutation([s],l),u=a;p!==null&&(u=Xa({inputs:{x:a},attrs:{perm:p},backend:n}));let d=N.getInnerMostAxes(1,l)[0];N.assertAxesAreInnerMostDims("cumprod",[d],l);let h=n.makeOutput(u.shape,u.dtype),c=u.shape[d],f=n.dataIdMap.get(u.dataId).id,m=n.dataIdMap.get(h.dataId).id;xC(f,i?1:0,o?1:0,c,m,Ze[a.dtype]);let g=h;if(p!==null){let y=N.getUndoAxesPermutation(p);g=Xa({inputs:{x:h},attrs:{perm:y},backend:n}),n.disposeData(u.dataId),n.disposeData(h.dataId)}return g}var rie={kernelName:kl,backendName:"wasm",setupFunc:tie,kernelFunc:nie},vC;function aie(e){vC=e.wasm.cwrap(gi,null,["number","number","number","number","number","number"])}function sie(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r,l=a.shape.length;w.assert(a.dtype==="float32"||a.dtype==="int32",()=>`cumsum does not support ${a.dtype} tensors in the WASM backend`);let p=N.getAxesPermutation([s],l),u=a;p!==null&&(u=Xa({inputs:{x:a},attrs:{perm:p},backend:n}));let d=N.getInnerMostAxes(1,l)[0];N.assertAxesAreInnerMostDims("cumsum",[d],l);let h=n.makeOutput(u.shape,u.dtype),c=u.shape[d],f=n.dataIdMap.get(u.dataId).id,m=n.dataIdMap.get(h.dataId).id;vC(f,i?1:0,o?1:0,c,m,Ze[a.dtype]);let g=h;if(p!==null){let y=N.getUndoAxesPermutation(p);g=Xa({inputs:{x:h},attrs:{perm:y},backend:n}),n.disposeData(u.dataId),n.disposeData(h.dataId)}return g}var iie={kernelName:gi,backendName:"wasm",setupFunc:aie,kernelFunc:sie},wC;function oie(e){wC=e.wasm.cwrap("DenseBincount",null,["number","array","number","number","boolean","number","number","boolean","number"])}function lie(e){let{backend:t,inputs:n,attrs:r}=e,{x:a,weights:s}=n,{size:i,binaryOutput:o}=r,l=s.shape.reduce((h,c)=>h*c,1)!==0,p=a.shape.length===1?[i]:[a.shape[0],i],u=t.makeOutput(p,s.dtype);function d(h){return t.dataIdMap.get(h.dataId).id}return wC(d(a),new Uint8Array(new Int32Array(a.shape).buffer),a.shape.length,i,l,d(s),Ze[s.dtype],o,d(u)),u}var uie={kernelName:Cp,backendName:"wasm",setupFunc:oie,kernelFunc:lie},kC;function pie(e){kC=e.wasm.cwrap(Sl,null,["number","number","number","array","number","array","array","number","number"])}function die(e){let{backend:t,inputs:n,attrs:r}=e,{x:a}=n,{blockSize:s,dataFormat:i}=r,o=a.shape[0],l=i==="NHWC"?a.shape[1]:a.shape[2],p=i==="NHWC"?a.shape[2]:a.shape[3],u=i==="NHWC"?a.shape[3]:a.shape[1],d=l*s,h=p*s,c=u/(s*s),f=i==="NHWC"?[o,d,h,c]:[o,c,d,h],m=t.makeOutput(f,"float32"),g=t.dataIdMap.get(a.dataId).id,y=new Uint8Array(new Int32Array(w.computeStrides(a.shape)).buffer),b=new Uint8Array(new Int32Array(f).buffer),x=new Uint8Array(new Int32Array(w.computeStrides(f)).buffer),v=t.dataIdMap.get(m.dataId).id;return kC(g,s,i==="NHWC"?1:0,y,a.shape.length-1,b,x,f.length,v),m}var hie={kernelName:Sl,backendName:"wasm",setupFunc:pie,kernelFunc:die},IC;function cie(e){IC=e.wasm.cwrap(yi,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function fie(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s}=t,i=r.dataIdMap.get(a.dataId).id,o=r.dataIdMap.get(s.dataId).id,{strides:l,dilations:p,pad:u,dimRoundingMode:d}=n,h=p??[1,1],c=N.computeConv2DInfo(a.shape,s.shape,l,h,u,d,!0),f=c.filterHeight,m=c.filterWidth,g=c.padInfo.top,y=c.padInfo.right,b=c.padInfo.bottom,x=c.padInfo.left,v=c.dilationHeight,I=c.dilationWidth,T=c.strideHeight,_=c.strideWidth,E=c.inChannels,A=c.outChannels,R=c.padInfo.type==="SAME"?1:0;if(c.dataFormat!=="channelsLast")throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);let F=r.makeOutput(c.outShape,"float32"),S=r.dataIdMap.get(F.dataId).id;return IC(i,a.shape[0],a.shape[1],a.shape[2],o,f,m,g,y,b,x,R,v,I,T,_,E,A,S),F}var mie={kernelName:yi,backendName:"wasm",setupFunc:cie,kernelFunc:fie},SC;function gie(e){SC=e.wasm.cwrap("Diag",null,["number","number","number","number"])}function yie(e){let{inputs:t,backend:n}=e,{x:r}=t,a=w.sizeFromShape(r.shape),s=n.makeOutput([...r.shape,...r.shape],r.dtype);return SC(n.dataIdMap.get(r.dataId).id,Ze[r.dtype],a,n.dataIdMap.get(s.dataId).id),s}var bie={kernelName:_p,backendName:"wasm",setupFunc:gie,kernelFunc:yie},NC;function xie(e){NC=e.wasm.cwrap(bi,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function vie(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r;if(a.dtype!==s.dtype)throw new Error(`Dilation2D error: x must have the same dtype as filter. Got ${a.dtype} and ${s.dtype}`);let p=N.computeDilation2DInfo(a.shape,s.shape,i,o,"NHWC",l),u=n.makeOutput(p.outShape,a.dtype);return NC(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(u.dataId).id,Ze[a.dtype],p.batchSize,p.inChannels,p.inHeight,p.inWidth,p.outHeight,p.outWidth,p.strideHeight,p.strideWidth,p.dilationHeight,p.dilationWidth,p.filterHeight,p.filterWidth,p.padInfo.top,p.padInfo.left),u}var wie={kernelName:bi,backendName:"wasm",setupFunc:xie,kernelFunc:vie},TC;function kie(e){TC=e.wasm.cwrap(qo,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Iie(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,dy:i}=t,{strides:o,pad:l,dilations:p}=r;if(a.dtype!==s.dtype||a.dtype!==i.dtype)throw new Error(`Dilation2DBackpropFilter error: x must have the same dtype as filter and dy. Got ${a.dtype}, ${s.dtype}, and ${i.dtype}`);let u=N.computeDilation2DInfo(a.shape,s.shape,o,l,"NHWC",p),d=n.makeOutput(s.shape,s.dtype);return TC(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,Ze[a.dtype],u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.filterHeight,u.filterWidth,u.padInfo.top,u.padInfo.left),d}var Sie={kernelName:qo,backendName:"wasm",setupFunc:kie,kernelFunc:Iie},CC;function Nie(e){CC=e.wasm.cwrap(jo,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Tie(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,dy:i}=t,{strides:o,pad:l,dilations:p}=r;if(a.dtype!==s.dtype||a.dtype!==i.dtype)throw new Error(`Dilation2DBackpropInput error: x must have the same dtype as filter and dy. Got ${a.dtype}, ${s.dtype}, and ${i.dtype}`);let u=N.computeDilation2DInfo(a.shape,s.shape,o,l,"NHWC",p),d=n.makeOutput(a.shape,a.dtype);return CC(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,Ze[a.dtype],u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.filterHeight,u.filterWidth,u.padInfo.top,u.padInfo.left),d}var Cie={kernelName:jo,backendName:"wasm",setupFunc:Nie,kernelFunc:Tie},_ie=je(vi),_C;function Eie(e){_C=e.wasm.cwrap(Nl,null,["number","number","number"])}function $ie(e){let{inputs:t,backend:n}=e,{dy:r,y:a}=t,s=n.makeOutput(a.shape,"float32"),i=o=>n.dataIdMap.get(o.dataId).id;return _C(i(a),i(r),i(s)),s}var Aie={kernelName:Nl,backendName:"wasm",setupFunc:Eie,kernelFunc:$ie},Fie=!1,Rie=Dt(Tl,Fie,"bool"),Die=je(wi),Mie=je(ki,"float32");function jm(e){let{inputs:t,attrs:n,backend:r}=e,{input:a}=t,{dim:s}=n,i=a.shape.length,o=a.shape.slice(),l=s;return s<0&&(w.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),o.splice(l,0,1),Cn({inputs:{x:a},backend:r,attrs:{shape:o}})}var Oie={kernelName:Cl,backendName:"wasm",kernelFunc:jm},Lie=je(Ii,"float32");function EC(e){let{attrs:{shape:t,value:n},backend:r}=e,{attrs:{dtype:a}}=e;a=a||w.inferDtype(n);let s=r.makeOutput(t,a);return r.typedArrayFromHeap(s).fill(n),s}var zie={kernelName:Ep,backendName:"wasm",kernelFunc:EC},$C;function Pie(e){$C=e.wasm.cwrap(_l,null,["number","number","number","number","number","number"])}function Bie(e){let{inputs:t,backend:n}=e,{image:r}=t,a=n.makeOutput(r.shape,r.dtype),s=n.dataIdMap.get(r.dataId).id,i=n.dataIdMap.get(a.dataId).id,[o,l,p,u]=r.shape;return $C(s,o,l,p,u,i),a}var Wie={kernelName:_l,backendName:"wasm",kernelFunc:Bie,setupFunc:Pie},Vie=je(Si),Uie=Dt(Ni),AC;function Gie(e){AC=e.wasm.cwrap(Ti,null,["number","number","number","number","number","number","number"])}function Hie(e){let{backend:t,inputs:n,attrs:r}=e,{varianceEpsilon:a}=r,{x:s,mean:i,variance:o,offset:l,scale:p}=n,u=t.dataIdMap.get(s.dataId).id,d=t.dataIdMap.get(i.dataId).id,h=t.dataIdMap.get(o.dataId).id,c=l!=null?t.dataIdMap.get(l.dataId).id:0,f=p!=null?t.dataIdMap.get(p.dataId).id:0,m=t.makeOutput(s.shape,s.dtype);if(w.sizeFromShape(s.shape)===0)return m;let g=t.dataIdMap.get(m.dataId).id;return AC(u,d,h,c,f,a,g),m}var jie={kernelName:Ti,backendName:"wasm",setupFunc:Gie,kernelFunc:Hie},FC;function qie(e){FC=e.wasm.cwrap(Rs,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Kie(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:p,dilations:u,dataFormat:d,dimRoundingMode:h,activation:c,leakyreluAlpha:f}=n,m=N.computeConv2DInfo(a.shape,s.shape,l,u,p,h),g=vp[c];if(g==null)throw new Error(`${c} activation not yet supported for FusedConv2D in the wasm backend.`);let y=r.dataIdMap.get(a.dataId).id,b=r.dataIdMap.get(s.dataId).id,x=m.outChannels,v=0;if(i!=null){let te=r.dataIdMap.get(i.dataId);if(te.shape.length!==1)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${te.shape.length}.`);if(te.shape[0]!==x)throw new Error(`FusedConv2D bias shape (${te.shape}) does not match the number of output channels (${x})`);v=te.id}let I=m.filterHeight,T=m.filterWidth,_=m.padInfo.top,E=m.padInfo.right,A=m.padInfo.bottom,R=m.padInfo.left,F=m.dilationHeight,S=m.dilationWidth,M=m.strideHeight,W=m.strideWidth,U=m.inChannels,H=m.padInfo.type==="SAME"?1:0,K=m.batchSize,j=m.inHeight,Z=m.inWidth;if(d!=="NHWC")throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);let ee=r.makeOutput(m.outShape,"float32"),Y=r.dataIdMap.get(ee.dataId).id,re=o==null?0:r.dataIdMap.get(o.dataId).id;return FC(y,K,j,Z,b,I,T,v,_,E,A,R,H,F,S,M,W,U,x,g,re,f||0,Y),ee}var Xie={kernelName:Rs,backendName:"wasm",setupFunc:qie,kernelFunc:Kie},RC;function Zie(e){RC=e.wasm.cwrap(Ds,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Jie(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:p,dilations:u,dataFormat:d,dimRoundingMode:h,activation:c,leakyreluAlpha:f}=n,m=N.computeConv2DInfo(a.shape,s.shape,l,u,p,h,!0),g=vp[c];if(g==null)throw new Error(`${c} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let y=r.dataIdMap.get(a.dataId).id,b=r.dataIdMap.get(s.dataId).id,x=m.outChannels,v=0;if(i!=null){let te=r.dataIdMap.get(i.dataId);if(te.shape.length!==1)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${te.shape.length}.`);if(te.shape[0]!==x)throw new Error(`FusedDepthwiseConv2D bias shape (${te.shape}) does not match the number of output channels (${x})`);v=te.id}let I=m.filterHeight,T=m.filterWidth,_=m.padInfo.top,E=m.padInfo.right,A=m.padInfo.bottom,R=m.padInfo.left,F=m.dilationHeight,S=m.dilationWidth,M=m.strideHeight,W=m.strideWidth,U=m.inChannels,H=m.padInfo.type==="SAME"?1:0,K=m.batchSize,j=m.inHeight,Z=m.inWidth;if(d!=="NHWC")throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);let ee=r.makeOutput(m.outShape,"float32"),Y=r.dataIdMap.get(ee.dataId).id,re=o==null?0:r.dataIdMap.get(o.dataId).id;return RC(y,K,j,Z,b,I,T,v,_,E,A,R,H,F,S,M,W,U,x,g,re,f||0,Y),ee}var Yie={kernelName:Ds,backendName:"wasm",setupFunc:Zie,kernelFunc:Jie},DC;function Qie(e){DC=e.wasm.cwrap($l,null,["number","number","number","number","number","number","array","number"])}function eoe(e){let{backend:t,inputs:n}=e,{params:r,indices:a}=n,[s,i,o,l]=_y.prepareAndValidate(r,a),p=t.makeOutput(s,r.dtype);if(i===0)return p;let u=a.shape,d=u[u.length-1],h=t.dataIdMap.get(r.dataId).id,c=t.dataIdMap.get(a.dataId).id,f=new Uint8Array(new Int32Array(l).buffer),m=t.dataIdMap.get(p.dataId).id;return DC(h,Ze[r.dtype],c,i,d,o,f,m),p}var toe={kernelName:$l,backendName:"wasm",setupFunc:Qie,kernelFunc:eoe},MC;function noe(e){MC=e.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])}function roe(e){let{backend:t,inputs:n,attrs:r}=e,{x:a,indices:s}=n,{axis:i,batchDims:o}=r,l=w.parseAxisParam(i,a.shape)[0],p=t.readSync(s.dataId),u=a.shape[l];for(let _=0;_<p.length;++_){let E=p[_];w.assert(E<=u-1&&E>=0,()=>`GatherV2: the index value ${E} is not in [0, ${u-1}]`)}let d=N.segment_util.collectGatherOpShapeInfo(a,s,l,o),h=Cn({inputs:{x:a},attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]},backend:t}),c=w.sizeFromShape(s.shape),f=Cn({inputs:{x:s},attrs:{shape:[d.batchSize,c/d.batchSize]},backend:t}),m=[d.batchSize,d.outerSize,c/d.batchSize,d.sliceSize],g=t.makeOutput(m,a.dtype);if(w.sizeFromShape(a.shape)===0)return g;let y=h.shape.length-1,b=t.dataIdMap.get(h.dataId).id,x=t.dataIdMap.get(f.dataId).id,v=t.dataIdMap.get(g.dataId).id,I=new Uint8Array(new Int32Array(w.computeStrides(h.shape)).buffer),T=new Uint8Array(new Int32Array(w.computeStrides(m)).buffer);return MC(b,Ze[a.dtype],I,y,x,d.batchSize,T,v),t.disposeData(h.dataId),t.disposeData(f.dataId),g.shape=d.outputShape,g}var aoe={kernelName:El,backendName:"wasm",setupFunc:noe,kernelFunc:roe},soe=!1,ioe=Dt(Al,soe,"bool"),ooe=!1,loe=Dt(Ci,ooe,"bool"),uoe=je(Ei,"bool"),poe=je($i,"bool"),doe=je(Ai,"bool"),OC;function hoe(e){OC=e.wasm.cwrap(Fi,null,["number","number","number","number"])}function coe(e){let{inputs:{x:t},attrs:{alpha:n},backend:r}=e,a=r.dataIdMap.get(t.dataId).id,s=r.makeOutput(t.shape,"float32");if(w.sizeFromShape(t.shape)!==0){let i=r.dataIdMap.get(s.dataId).id;OC(a,Ze[t.dtype],n,i)}return s}var foe={kernelName:Fi,backendName:"wasm",setupFunc:hoe,kernelFunc:coe},moe=!1,goe=Dt(Fl,moe,"bool"),yoe=!1,boe=Dt(Rl,yoe,"bool"),LC;function xoe(e){LC=e.wasm.cwrap(Dl,null,["number","number","number","number"])}function voe(e){let{attrs:t,backend:n}=e,{start:r,stop:a,num:s}=t,i=Math.floor(s),o=n.makeOutput([i],"float32");return LC(n.dataIdMap.get(o.dataId).id,r,a,i),o}var woe={kernelName:Dl,backendName:"wasm",setupFunc:xoe,kernelFunc:voe},koe=je(Ri),Ioe=je(Di),Soe=!1,Noe=Dt(Ml,Soe,"bool"),Toe=je(Ol),Coe=!1,_oe=Dt(Ll,Coe,"bool"),Eoe=!1,$oe=Dt(O0,Eoe,"bool"),zC;function Aoe(e){zC=e.wasm.cwrap(Mi,null,["number","number","number","number","number","number","number"])}function Foe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r;if(a.dtype!=="float32")throw new Error("LRN error: x must have dtype float32");let p=n.makeOutput(a.shape,a.dtype);return zC(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(p.dataId).id,a.shape[3],s,i,o,l),p}var Roe={kernelName:Mi,backendName:"wasm",setupFunc:Aoe,kernelFunc:Foe},PC;function Doe(e){PC=e.wasm.cwrap(zl,null,["number","number","number","number","number","number","number","number","number"])}function Moe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:p,beta:u}=r;if(a.dtype!=="float32"||s.dtype!=="float32"||i.dtype!=="float32")throw new Error("LRNGrad error: x, y, and dy must have dtype float32");let d=n.makeOutput(a.shape,a.dtype);return PC(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,i.shape[3],o,l,p,u),d}var Ooe={kernelName:zl,backendName:"wasm",setupFunc:Doe,kernelFunc:Moe},BC;function Loe(e){BC=e.wasm.cwrap(Oi,null,["number","number","number","number"])}function zoe(e){let{backend:t,inputs:n,attrs:r}=e,{reductionIndices:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:p,axes:u,originalAxes:d,inputWasTransposed:h}=us(i,a,t);if(h){let b=t.dataIdMap.get(p.dataId).id;l=p,o=b}let c=l.shape.length;N.assertAxesAreInnerMostDims("max",u,c);let[f,m]=N.computeOutAndReduceShapes(l.shape,u),g=w.sizeFromShape(m),y=t.makeOutput(f,i.dtype);if(w.sizeFromShape(l.shape)!==0){let b=t.dataIdMap.get(y.dataId).id;BC(o,Ze[i.dtype],g,b)}if(h&&t.disposeData(p.dataId),s){let b=N.expandShapeToKeepDim(y.shape,d);y.shape=b}return y}var Poe={kernelName:Oi,backendName:"wasm",setupFunc:Loe,kernelFunc:zoe},Boe=Dt(Li),WC;function Woe(e){WC=e.wasm.cwrap(zi,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Voe(e){let{inputs:t,attrs:n,backend:r}=e,a=t.x,s=r.dataIdMap.get(a.dataId).id;w.assert(a.dtype==="float32",()=>`Error in MaxPool: only float32 input is supported. Got ${a.dtype}.`);let{filterSize:i,strides:o,pad:l,dimRoundingMode:p}=n,u=N.computePool2DInfo(a.shape,i,o,1,l,p),d=u.filterHeight,h=u.filterWidth,c=u.padInfo.top,f=u.padInfo.right,m=u.padInfo.bottom,g=u.padInfo.left,y=u.dilationHeight,b=u.dilationWidth,x=u.strideHeight,v=u.strideWidth,I=u.inChannels,T=u.outChannels;if(u.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${u.dataFormat}'. Please use 'channelsLast'.`);let _=r.makeOutput(u.outShape,"float32"),E=r.dataIdMap.get(_.dataId).id;return WC(s,a.shape[0],a.shape[1],a.shape[2],d,h,c,f,m,g,y,b,x,v,I,T,E),_}var Uoe={kernelName:zi,backendName:"wasm",setupFunc:Woe,kernelFunc:Voe},VC;function Goe(e){VC=e.wasm.cwrap("MaxPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Hoe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:p}=r,u=N.computePool3DInfo(a.shape,s,i,1,o,l,p),d=n.makeOutput(u.outShape,a.dtype);return VC(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,u.batchSize,u.inChannels,u.inDepth,u.inHeight,u.inWidth,u.outDepth,u.outHeight,u.outWidth,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.effectiveFilterDepth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),d}var joe={kernelName:Pl,backendName:"wasm",setupFunc:Goe,kernelFunc:Hoe},UC;function qoe(e){UC=e.wasm.cwrap("MaxPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Koe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:p}=r,u=N.computePool3DInfo(s.shape,i,o,1,l,p),d=n.makeOutput(s.shape,s.dtype);return UC(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,u.batchSize,u.inChannels,u.inDepth,u.inHeight,u.inWidth,u.outDepth,u.outHeight,u.outWidth,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.effectiveFilterDepth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),d}var Xoe={kernelName:Ap,backendName:"wasm",setupFunc:qoe,kernelFunc:Koe},GC;function Zoe(e){GC=e.wasm.cwrap("MaxPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Joe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:p}=r,u=N.computePool2DInfo(s.shape,i,o,1,l,p),d=n.makeOutput(s.shape,s.dtype);return GC(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.top,u.padInfo.left),d}var Yoe={kernelName:$p,backendName:"wasm",setupFunc:Zoe,kernelFunc:Joe},HC;function Qoe(e){HC=e.wasm.cwrap("MaxPoolWithArgmax",null,["number","number","number","number","boolean","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function ele(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,includeBatchInIndex:l}=r;w.assert(a.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.shape.length}.`);let p=[1,1];w.assert(N.eitherStridesOrDilationsAreOne(i,p),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${p}'`);let u=N.computePool2DInfo(a.shape,s,i,[1,1],o),d=n.makeOutput(u.outShape,a.dtype),h=n.makeOutput(u.outShape,"int32");return HC(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,n.dataIdMap.get(h.dataId).id,Ze[a.dtype],l,u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.top,u.padInfo.left),[d,h]}var tle={kernelName:Fp,backendName:"wasm",setupFunc:Qoe,kernelFunc:ele},jC;function nle(e){jC=e.wasm.cwrap(Pi,null,["number, number, number"])}function rle(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,p=i,{transposed:u,axes:d,originalAxes:h,inputWasTransposed:c}=us(i,a,t),f=d;if(c){let v=t.dataIdMap.get(u.dataId).id;v!==o&&(p=u,l=v,f=N.getInnerMostAxes(f.length,p.shape.length))}N.assertAxesAreInnerMostDims("mean",f,p.shape.length);let[m,g]=N.computeOutAndReduceShapes(p.shape,f),y=w.sizeFromShape(g),b=p;p.dtype!=="float32"&&(b=ps({backend:t,inputs:{x:p},attrs:{dtype:"float32"}}),l=t.dataIdMap.get(b.dataId).id);let x=t.makeOutput(m,"float32");if(w.sizeFromShape(p.shape)!==0){let v=t.dataIdMap.get(x.dataId).id;jC(l,y,v)}if(c&&t.disposeData(u.dataId),s){let v=N.expandShapeToKeepDim(x.shape,h);x.shape=v}return p.dtype!=="float32"&&t.disposeData(b.dataId),x}var ale={kernelName:Pi,backendName:"wasm",setupFunc:nle,kernelFunc:rle},qC;function sle(e){qC=e.wasm.cwrap(Bi,null,["number","number","number","number"])}function ile(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,p=i,{transposed:u,axes:d,originalAxes:h,inputWasTransposed:c}=us(i,a,t);if(c){let x=t.dataIdMap.get(u.dataId).id;x!==o&&(p=u,l=x)}let f=p.shape.length;N.assertAxesAreInnerMostDims("min",d,f);let[m,g]=N.computeOutAndReduceShapes(p.shape,d),y=w.sizeFromShape(g),b=t.makeOutput(m,p.dtype);if(w.sizeFromShape(p.shape)!==0){let x=t.dataIdMap.get(b.dataId).id;qC(l,Ze[i.dtype],y,x)}if(c&&t.disposeData(u.dataId),s){let x=N.expandShapeToKeepDim(b.shape,h);b.shape=x}return b}var ole={kernelName:Bi,backendName:"wasm",setupFunc:sle,kernelFunc:ile},lle=Dt(Wi),qm;(function(e){e[e.reflect=0]="reflect",e[e.symmetric=1]="symmetric"})(qm||(qm={}));var KC;function ule(e){KC=e.wasm.cwrap(Vi,null,["number","array","number","number","array","array","number","number"])}function ple(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,mode:a}}=e,s=r.map((f,m)=>f[0]+t.shape[m]+f[1]),i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(s,t.dtype),l=n.dataIdMap.get(o.dataId).id,p=new Uint8Array(new Int32Array(t.shape).buffer),u=r.map(f=>f[0]),d=r.map(f=>f[1]),h=new Uint8Array(new Int32Array(u).buffer),c=new Uint8Array(new Int32Array(d).buffer);return KC(i,p,t.shape.length,Ze[t.dtype],h,c,qm[a],l),o}var dle={kernelName:Vi,backendName:"wasm",kernelFunc:ple,setupFunc:ule},XC;function hle(e){XC=e.wasm.cwrap(co,null,["number","number","number","number"])}function ZC(e){let{backend:t,inputs:{logits:n},attrs:{dim:r}}=e,a=t.dataIdMap.get(n.dataId).id,s=t.makeOutput(n.shape,n.dtype),i=t.dataIdMap.get(s.dataId).id,o=n.shape[r],l=w.sizeFromShape(n.shape)/o;return w.sizeFromShape(s.shape)===0||XC(a,i,o,l),s}var cle={kernelName:co,backendName:"wasm",setupFunc:hle,kernelFunc:ZC},JC;function fle(e){JC=e.wasm.cwrap(Bl,null,["number","number","number","number","number","number"])}function mle(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r;if(a.dtype!=="float32")throw new Error(`Tensor logits must have dtype float32, got ${a.dtype}`);let l=o?a:ZC({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),[p,u]=l.shape,d=n.makeOutput([p,s],"int32");return JC(n.dataIdMap.get(l.dataId).id,p,u,s,i,n.dataIdMap.get(d.dataId).id),o||n.disposeData(l.dataId),d}var gle={kernelName:Bl,backendName:"wasm",setupFunc:fle,kernelFunc:mle},yle=Dt(Ui),ble=Dt(Gi),xle=je(Wl);function Hx(e,t){let n=new Int32Array(e.wasm.HEAPU8.buffer,t,4),r=n[0],a=n[1],s=n[2],i=n[3];return e.wasm._free(t),{pSelectedIndices:r,selectedSize:a,pSelectedScores:s,pValidOutputs:i}}var YC;function vle(e){YC=e.wasm.cwrap(Ul,"number",["number","number","number","number","number"])}function wle(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:i}=r,{boxes:o,scores:l}=n,p=t.dataIdMap.get(o.dataId).id,u=t.dataIdMap.get(l.dataId).id,d=YC(p,u,s,a,i),{pSelectedIndices:h,selectedSize:c,pSelectedScores:f,pValidOutputs:m}=Hx(t,d);return t.wasm._free(f),t.wasm._free(m),t.makeOutput([c],"int32",h)}var kle={kernelName:Ul,backendName:"wasm",setupFunc:vle,kernelFunc:wle},QC;function Ile(e){QC=e.wasm.cwrap(Gl,"number",["number","number","number","number","number","bool"])}function Sle(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:i,padToMaxOutputSize:o}=r,{boxes:l,scores:p}=n,u=t.dataIdMap.get(l.dataId).id,d=t.dataIdMap.get(p.dataId).id,h=QC(u,d,s,a,i,o),{pSelectedIndices:c,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=Hx(t,h);t.wasm._free(m);let y=t.makeOutput([f],"int32",c),b=t.makeOutput([],"int32",g);return[y,b]}var Nle={kernelName:Gl,backendName:"wasm",setupFunc:Ile,kernelFunc:Sle},e_;function Tle(e){e_=e.wasm.cwrap(Hl,"number",["number","number","number","number","number","number"])}function Cle(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:i,softNmsSigma:o}=r,{boxes:l,scores:p}=n,u=t.dataIdMap.get(l.dataId).id,d=t.dataIdMap.get(p.dataId).id,h=e_(u,d,s,a,i,o),{pSelectedIndices:c,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=Hx(t,h);t.wasm._free(g);let y=t.makeOutput([f],"int32",c),b=t.makeOutput([f],"float32",m);return[y,b]}var _le={kernelName:Hl,backendName:"wasm",setupFunc:Tle,kernelFunc:Cle},Ele=!1,$le=Dt(Vl,Ele,"bool"),t_;function Ale(e){t_=e.wasm.cwrap(Hi,null,["number","number","number","number","number"])}function Fle(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=r,p=n.makeOutput([...a.shape,i],s),u=n.dataIdMap.get(p.dataId).id,d=n.dataIdMap.get(a.dataId).id;return t_(d,i,o,l,u),p}var Rle={kernelName:Hi,backendName:"wasm",setupFunc:Ale,kernelFunc:Fle};function Dle(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(1),r}var Mle={kernelName:jl,backendName:"wasm",kernelFunc:Dle};function Ole(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(t.length===1)return jm({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let s=t[0].shape,i=t[0].dtype;t.forEach(u=>{w.assertShapesMatch(s,u.shape,"All tensors passed to stack must have matching shapes"),w.assert(i===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],l=t.map(u=>{let d=jm({inputs:{input:u},backend:n,attrs:{dim:a}});return o.push(d),d}),p=hC({inputs:l,backend:n,attrs:{axis:a}});return o.forEach(u=>n.disposeData(u.dataId)),p}var Lle={kernelName:ql,backendName:"wasm",kernelFunc:Ole},n_;function zle(e){n_=e.wasm.cwrap(ji,null,["number","array","number","number","array","array","number","number"])}function Ple(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,constantValue:a}}=e,s=r.map((f,m)=>f[0]+t.shape[m]+f[1]);if(w.sizeFromShape(t.shape)===0)return EC({backend:n,attrs:{shape:s,value:a,dtype:t.dtype}});let i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(s,t.dtype),l=n.dataIdMap.get(o.dataId).id,p=new Uint8Array(new Int32Array(t.shape).buffer),u=r.map(f=>f[0]),d=r.map(f=>f[1]),h=new Uint8Array(new Int32Array(u).buffer),c=new Uint8Array(new Int32Array(d).buffer);return n_(i,p,t.shape.length,Ze[t.dtype],h,c,a,l),o}var r_={kernelName:ji,backendName:"wasm",kernelFunc:Ple,setupFunc:zle},Ble=Dt(qi),a_;function Wle(e){a_=e.wasm.cwrap(Ki,null,["number","number","number"])}function Vle(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t,s=n.dataIdMap.get(r.dataId).id,i=n.dataIdMap.get(a.dataId).id,o=s,l=r,p=l;l.dtype!=="float32"&&(p=ps({backend:n,inputs:{x:r},attrs:{dtype:"float32"}}),o=n.dataIdMap.get(p.dataId).id);let u=n.makeOutput(r.shape,"float32"),d=n.dataIdMap.get(u.dataId).id;return a_(o,i,d),l.dtype!=="float32"&&n.disposeData(p.dataId),u}var Ule={kernelName:Ki,backendName:"wasm",setupFunc:Wle,kernelFunc:Vle},s_;function Gle(e){s_=e.wasm.cwrap(Xi,null,["number","number","number","number"])}function Hle(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,p=i,{transposed:u,axes:d,originalAxes:h,inputWasTransposed:c}=us(i,a,t),f=d;if(c){let x=t.dataIdMap.get(u.dataId).id;x!==o&&(p=u,l=x,f=N.getInnerMostAxes(f.length,p.shape.length))}N.assertAxesAreInnerMostDims("prod",f,p.shape.length);let[m,g]=N.computeOutAndReduceShapes(p.shape,f),y=w.sizeFromShape(g),b=t.makeOutput(m,p.dtype);if(w.sizeFromShape(p.shape)!==0){let x=t.dataIdMap.get(b.dataId).id;s_(l,y,Ze[b.dtype],x)}if(c&&t.disposeData(u.dataId),s){let x=N.expandShapeToKeepDim(b.shape,h);b.shape=x}return b}var jle={kernelName:Xi,backendName:"wasm",setupFunc:Gle,kernelFunc:Hle},qle=e=>{let{backend:t,attrs:n}=e,{start:r,stop:a,step:s,dtype:i}=n,o=xx(r,a,s,i),l=t.makeOutput([o.length],i);return t.typedArrayFromHeap(l).set(o),l},Kle={kernelName:Rp,backendName:"wasm",kernelFunc:qle},Xle=Dt(xi),Zle=je(Zi),Jle=je(Ji),Yle=je(eo),i_;function Qle(e){i_=e.wasm.cwrap(Qi,null,["number","number","number","number","number","number","number","number","number","number"])}function eue(e){let{backend:t,inputs:n,attrs:r}=e,{images:a}=n,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,p]=o,[u,d,h,c]=a.shape,f=[u,l,p,c],m=t.dataIdMap.get(a.dataId),g;m.dtype!=="float32"&&(g=ps({backend:t,inputs:{x:a},attrs:{dtype:"float32"}}),m=t.dataIdMap.get(g.dataId));let y=m.id,b=t.makeOutput(f,"float32");if(w.sizeFromShape(a.shape)===0)return b;let x=t.dataIdMap.get(b.dataId).id;return i_(y,u,d,h,c,l,p,s?1:0,i?1:0,x),g!=null&&t.disposeData(g.dataId),b}var tue={kernelName:Qi,backendName:"wasm",setupFunc:Qle,kernelFunc:eue},o_;function nue(e){o_=e.wasm.cwrap(Zl,null,["number","number","number","array","array","boolean"])}function rue(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=n.makeOutput(a.shape,"float32"),l=n.dataIdMap.get(a.dataId),p;return l.dtype!=="float32"&&(p=ps({backend:n,inputs:{x:a},attrs:{dtype:"float32"}}),l=n.dataIdMap.get(p.dataId)),o_(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(o.dataId).id,new Uint8Array(new Int32Array(a.shape).buffer),new Uint8Array(new Int32Array(s.shape).buffer),i),p!=null&&n.disposeData(p.dataId),o}var aue={kernelName:Zl,backendName:"wasm",setupFunc:nue,kernelFunc:rue},l_;function sue(e){l_=e.wasm.cwrap(Yi,null,["number","number","number","number","number","number","number","number","number","number"])}function iue(e){let{backend:t,inputs:n,attrs:r}=e,{images:a}=n,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,p]=o,[u,d,h,c]=a.shape,f=[u,l,p,c],m=t.makeOutput(f,"float32");if(w.sizeFromShape(a.shape)===0)return m;let g=t.dataIdMap.get(a.dataId),y;g.dtype!=="float32"&&(y=ps({backend:t,inputs:{x:a},attrs:{dtype:"float32"}}),g=t.dataIdMap.get(y.dataId));let b=g.id,x=t.dataIdMap.get(m.dataId).id;return l_(b,u,d,h,c,l,p,s?1:0,i?1:0,x),y!=null&&t.disposeData(y.dataId),m}var oue={kernelName:Yi,backendName:"wasm",setupFunc:sue,kernelFunc:iue},u_;function lue(e){u_=e.wasm.cwrap(Xl,null,["number","number","number","array","array","boolean"])}function uue(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=n.makeOutput(a.shape,"float32"),l=n.dataIdMap.get(a.dataId),p;return l.dtype!=="float32"&&(p=ps({backend:n,inputs:{x:a},attrs:{dtype:"float32"}}),l=n.dataIdMap.get(p.dataId)),u_(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(o.dataId).id,new Uint8Array(new Int32Array(a.shape).buffer),new Uint8Array(new Int32Array(s.shape).buffer),i),p!=null&&n.disposeData(p.dataId),o}var pue={kernelName:Xl,backendName:"wasm",setupFunc:lue,kernelFunc:uue},p_;function due(e){p_=e.wasm.cwrap(to,null,["number","array","number","array","number","number"])}function hue(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r,i=w.parseAxisParam(s,a.shape);if(a.shape.length===0)return xf({inputs:{x:a},backend:n});let o=n.makeOutput(a.shape,a.dtype),l=n.dataIdMap.get(a.dataId).id,p=n.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(i).buffer),d=new Uint8Array(new Int32Array(a.shape).buffer);p_(l,u,i.length,d,a.shape.length,p);let h=Cn({inputs:{x:o},attrs:{shape:a.shape},backend:n});return n.disposeData(o.dataId),h}var cue={kernelName:to,backendName:"wasm",kernelFunc:hue,setupFunc:due},d_;function fue(e){d_=e.wasm.cwrap(du,null,["number","number","number","number","number","number","number","number","array","number","number"])}function mue(e){let{inputs:t,backend:n,attrs:r}=e,{image:a}=t,{radians:s,fillValue:i,center:o}=r,l=n.makeOutput(a.shape,a.dtype),p=n.dataIdMap.get(a.dataId).id,u=n.dataIdMap.get(l.dataId).id,[d,h,c,f]=a.shape,[m,g]=N.getImageCenter(o,h,c),y=i===0,b=255,x=typeof i=="number"?[i,i,i,y?0:b]:[...i,b],v=new Uint8Array(new Int32Array(x).buffer);return d_(p,d,h,c,f,s,m,g,v,x.length,u),l}var gue={kernelName:du,backendName:"wasm",kernelFunc:mue,setupFunc:fue},yue=je(no),bue=je(ro),h_;function xue(e){h_=e.wasm.cwrap(Jl,null,["number","number","number","number","number","number","array","number","number"])}function vue(e){let{backend:t,inputs:n,attrs:r}=e,{indices:a,updates:s}=n,{shape:i}=r,o=t.makeOutput(i,s.dtype);if(w.sizeFromShape(i)===0)return o;let{sliceRank:l,numUpdates:p,sliceSize:u,strides:d,outputSize:h}=Dc.calculateShapes(s,a,i),c=t.dataIdMap.get(a.dataId).id,f=t.dataIdMap.get(s.dataId).id,m=new Uint8Array(new Int32Array(d).buffer),g=t.dataIdMap.get(o.dataId).id;return h_(c,f,Ze[s.dtype],l,p,u,m,h,g),o}var wue={kernelName:Jl,backendName:"wasm",setupFunc:xue,kernelFunc:vue},c_;function kue(e){c_=e.wasm.cwrap(Ql,null,["number","number","number","number","number","number","bool","number"])}function Iue(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r;if(a.dtype!==s.dtype)throw new Error(`SearchSorted error: sorted_sequence must have the same dtype as values. Got ${a.dtype} and ${s.dtype}`);let o=n.makeOutput(s.shape,"int32");function l(p){return n.dataIdMap.get(p.dataId).id}return c_(l(a),l(s),a.shape[0],a.shape[1],s.shape[1],Ze[a.dtype],i==="left",l(o)),o}var Sue={kernelName:Ql,backendName:"wasm",setupFunc:kue,kernelFunc:Iue},f_;function Nue(e){f_=e.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}function Tue(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t,i=n.dataIdMap.get(r.dataId).id,o=n.dataIdMap.get(a.dataId).id,l=n.dataIdMap.get(s.dataId).id,p=n.makeOutput(a.shape,a.dtype),u=n.dataIdMap.get(p.dataId).id,d=r.shape.length,h=a.shape.length,c=d===0||d>1||h===1?1:w.sizeFromShape(a.shape.slice(1));return f_(i,o,l,c,u),p}var Cue={kernelName:eu,backendName:"wasm",kernelFunc:Tue,setupFunc:Nue},_ue=je(ao),m_;function Eue(e){m_=e.wasm.cwrap(lo,null,["number","number"])}function $ue(e){let{backend:t,inputs:{x:n}}=e,r=t.dataIdMap.get(n.dataId).id,a=t.makeOutput(n.shape,n.dtype),s=t.dataIdMap.get(a.dataId).id;return w.sizeFromShape(a.shape)===0||m_(r,s),a}var Aue={kernelName:"Sigmoid",backendName:"wasm",setupFunc:Eue,kernelFunc:$ue},Fue=je(oo),Rue=je(so),Due=je(io),Mue=je(uo);function Oue(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r,o=w.sizeFromShape(s),l=[[0,0]];l.push(...i);for(let g=1+s.length;g<a.shape.length;++g)l.push([0,0]);let p=r_.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),u=N.getReshaped(p.shape,s,o,!1),d=N.getPermuted(u.length,s.length,!1),h=N.getReshapedPermuted(p.shape,s,o,!1),c=Cn({inputs:{x:p},backend:n,attrs:{shape:u}}),f=Xa({inputs:{x:c},backend:n,attrs:{perm:d}}),m=Cn({inputs:{x:f},backend:n,attrs:{shape:h}});return n.disposeData(p.dataId),n.disposeData(c.dataId),n.disposeData(f.dataId),m}var Lue={kernelName:nu,backendName:"wasm",kernelFunc:Oue},g_;function zue(e){g_=e.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])}function Pue(e){let{backend:t,inputs:n}=e,{indices:r,values:a,denseShape:s,defaultValue:i}=n,o=r.shape[0],l=r.shape[1],p=t.readSync(s.dataId)[0],u=[o+p,l],d=t.dataIdMap.get(r.dataId).id,h=t.dataIdMap.get(a.dataId).id,c=t.dataIdMap.get(i.dataId).id,f=t.makeOutput(u,r.dtype),m=t.dataIdMap.get(f.dataId).id,g=t.makeOutput(u.slice(0,1),a.dtype),y=t.dataIdMap.get(g.dataId).id,b=t.makeOutput([p],"bool"),x=t.dataIdMap.get(b.dataId).id,v=t.makeOutput([o],r.dtype),I=t.dataIdMap.get(v.dataId).id,T=t.makeOutput([4],"int32"),_=t.dataIdMap.get(T.dataId).id,E=g_(d,h,Ze[a.dtype],o,p,l,c,m,y,x,I,_),A=t.readSync(T.dataId),R;switch(A[0]){case 1:{R=N.getSparseFillEmptyRowsIndicesDenseShapeMismatch(A[1]);break}case 2:{R=N.getSparseFillEmptyRowsNegativeIndexErrorMessage(A[1],A[2]);break}case 3:R=N.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(A[1],A[2],A[3]);break;default:R=""}if(t.disposeData(T.dataId),R)throw t.disposeData(f.dataId),t.disposeData(g.dataId),t.disposeData(b.dataId),t.disposeData(v.dataId),new Error(R);let F=f,S=g;return E!==u[0]&&(F=Zs({inputs:{x:f},attrs:{begin:0,size:[E,l]},backend:t}),S=Zs({inputs:{x:g},attrs:{begin:0,size:E},backend:t}),t.disposeData(f.dataId),t.disposeData(g.dataId)),[F,S,b,v]}var Bue={kernelName:Dp,backendName:"wasm",setupFunc:zue,kernelFunc:Pue},y_;function Wue(e){y_=e.wasm.cwrap(au,null,["number","number","number","number","number","number","number"])}function Vue(e){let{backend:t,inputs:n}=e,{inputIndices:r,inputShape:a,newShape:s}=n;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(a.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${a.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=t.dataIdMap.get(r.dataId).id,o=t.dataIdMap.get(a.dataId).id,l=t.dataIdMap.get(s.dataId).id,p=r.shape[0],u=w.sizeFromShape(s.shape),d=t.makeOutput([p,u],r.dtype),h=t.dataIdMap.get(d.dataId).id,c=t.makeOutput([u],s.dtype),f=t.dataIdMap.get(c.dataId).id,m=t.makeOutput([3],"int32"),g=t.dataIdMap.get(m.dataId).id;y_(i,o,l,p,h,f,g);let y=t.readSync(m.dataId),b;switch(y[0]){case 0:{b=N.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(y[1],y[2]);break}case 1:{b=N.getSparseReshapeNegativeOutputDimErrorMessage(y[1],y[2]);break}case 2:b=N.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{let x=Array.from(t.readSync(a.dataId)),v=Array.from(t.readSync(c.dataId));b=N.getSparseReshapeInputOutputMultipleErrorMessage(x,v);break}case 4:{let x=Array.from(t.readSync(a.dataId)),v=Array.from(t.readSync(c.dataId));b=N.getSparseReshapeInputOutputMismatchErrorMessage(x,v);break}default:b=""}if(t.disposeData(m.dataId),b)throw t.disposeData(d.dataId),t.disposeData(c.dataId),new Error(b);return[d,c]}var Uue={kernelName:au,backendName:"wasm",setupFunc:Wue,kernelFunc:Vue},b_;function x_(e){b_=e.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function v_(e,t){let{backend:n,inputs:r}=e,{data:a,indices:s,segmentIds:i}=r,o=s.shape[0],l=n.readSync(i.dataId,o-1,o)[0],p=o>0?l+1:0;if(p<0)throw new Error(N.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let u=a.shape.slice();u[0]=p;let d=n.dataIdMap.get(a.dataId).id,h=n.dataIdMap.get(s.dataId).id,c=n.dataIdMap.get(i.dataId).id,f=n.makeOutput(u,a.dtype),m=n.dataIdMap.get(f.dataId).id,g=n.makeOutput([4],"int32"),y=n.dataIdMap.get(g.dataId).id;b_(d,Ze[a.dtype],a.shape[0],h,c,m,y,t,0);let b=n.readSync(g.dataId),x;switch(b[0]){case 0:{x=N.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break}case 1:{x=N.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break}case 2:x=N.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(b[1],b[2]);break;case 3:x=N.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(b[1],b[2],b[3]);break;default:x=""}if(n.disposeData(g.dataId),x)throw n.disposeData(f.dataId),new Error(x);return f}function Gue(e){return v_(e,!0)}var Hue={kernelName:Mp,backendName:"wasm",setupFunc:x_,kernelFunc:Gue};function jue(e){return v_(e,!1)}var que={kernelName:Op,backendName:"wasm",setupFunc:x_,kernelFunc:jue},w_;function Kue(e){w_=e.wasm.cwrap(su,null,["number","number","number","number","number","number","number","number","array","number","number"])}function Xue(e){let{backend:t,inputs:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:i}=n,{outputShape:o}=r,l=t.makeOutput(o,i.dtype);if(w.sizeFromShape(o)===0)return l;let{sliceRank:p,numUpdates:u,sliceSize:d,strides:h,outputSize:c}=N.calculateShapes(s,a,o),f=t.dataIdMap.get(a.dataId).id,m=t.dataIdMap.get(s.dataId).id,g=t.dataIdMap.get(i.dataId).id,y=new Uint8Array(new Int32Array(h).buffer),b=t.dataIdMap.get(l.dataId).id;return w_(f,m,s.shape.length,g,Ze[i.dtype],p,u,d,y,c,b),l}var Zue={kernelName:su,backendName:"wasm",setupFunc:Kue,kernelFunc:Xue};function Jue(e){let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=n,o=w.parseAxisParam(i,a.shape)[0],l=N.prepareSplitSize(a,s,o),p=new Array(a.shape.length).fill(0),u=a.shape.slice();return l.map(d=>{let h=[...u];h[o]=d;let c=Zs({inputs:{x:a},attrs:{begin:p,size:h},backend:r});return p[o]+=d,c})}var Yue={kernelName:ru,backendName:"wasm",kernelFunc:Jue},Que=je(po),epe=je(Lp),tpe=Dt(fo),k_;function npe(e){k_=e.wasm.cwrap(ts,null,["number","number","number","number"])}function rpe(e){let{backend:t,inputs:n,attrs:r}=e,{alpha:a}=r,{x:s}=n,i=t.dataIdMap.get(s.dataId).id,o=t.makeOutput(s.shape,s.dtype),l=t.dataIdMap.get(o.dataId).id;return k_(i,a,Ze[s.dtype],l),o}var ape={kernelName:ts,backendName:"wasm",setupFunc:npe,kernelFunc:rpe},I_;function spe(e){I_=e.wasm.cwrap(iu,null,["number","array","number","array","array","array","array","array","number","number"])}function ipe(e){let{backend:t,inputs:n,attrs:r}=e,{x:a}=n,{begin:s,end:i,strides:o,beginMask:l,endMask:p,ellipsisMask:u,newAxisMask:d,shrinkAxisMask:h}=r,{finalShapeSparse:c,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:x,strides:v}=Lt.sliceInfo(a.shape,s,i,o,l,p,u,d,h),I;if(m)I=Cn({inputs:{x:a},backend:t,attrs:{shape:f}});else if(g||y){w.assert(a.shape.length>=1,()=>`Input must have rank at least 1, got: ${a.shape.length}`);let T=Lt.computeOutShape(b,x,v),_=Zs({inputs:{x:a},backend:t,attrs:{begin:b,size:T}});I=Cn({inputs:{x:_},backend:t,attrs:{shape:f}}),t.disposeData(_.dataId)}else{let T=t.makeOutput(c,"float32"),_=t.dataIdMap.get(a.dataId).id,E=new Uint8Array(new Int32Array(w.computeStrides(a.shape)).buffer),A=new Uint8Array(new Int32Array(b).buffer),R=new Uint8Array(new Int32Array(x).buffer),F=new Uint8Array(new Int32Array(v).buffer),S=new Uint8Array(new Int32Array(c).buffer),M=new Uint8Array(new Int32Array(w.computeStrides(c)).buffer),W=t.dataIdMap.get(T.dataId).id;I_(_,E,a.shape.length,A,R,F,S,M,c.length,W),I=Cn({inputs:{x:T},backend:t,attrs:{shape:f}}),t.disposeData(T.dataId)}return I}var ope={kernelName:iu,backendName:"wasm",setupFunc:spe,kernelFunc:ipe};function lpe(e){let{backend:t,inputs:n,attrs:r}=e,{data:a,dataSplits:s}=n,{separator:i,nGramWidths:o,leftPad:l,rightPad:p,padWidth:u,preserveShortSequences:d}=r,h=t.readSync(a.dataId),c=t.readSync(s.dataId),[f,m]=wx(h,c,i,o,l,p,u,d),g=t.makeOutput([f.length],"string"),y=t.dataIdMap.get(g.dataId);y.stringBytes=f;let b=t.makeOutput(s.shape,"int32");return t.typedArrayFromHeap(b).set(m),[g,b]}var upe={kernelName:Pp,backendName:"wasm",kernelFunc:lpe};function ppe(e){let{backend:t,inputs:n,attrs:r}=e,{input:a,delimiter:s}=n,{skipEmpty:i}=r,o=t.readSync(a.dataId),l=t.readSync(s.dataId),[p,u,d]=kx(o,l[0],i),h=u.length,c=t.makeOutput([h,2],"int32");t.typedArrayFromHeap(c).set(p);let f=t.makeOutput([h],"string"),m=t.dataIdMap.get(f.dataId);m.stringBytes=u;let g=t.makeOutput([2],"int32");return t.typedArrayFromHeap(g).set(d),[c,f,g]}var dpe={kernelName:Bp,backendName:"wasm",kernelFunc:ppe};function hpe(e){let{backend:t,inputs:n,attrs:r}=e,{input:a}=n,{numBuckets:s}=r,i=t.readSync(a.dataId),o=Ix(i,s),l=t.makeOutput(a.shape,"int32");return t.typedArrayFromHeap(l).set(o),l}var cpe={kernelName:Wp,backendName:"wasm",kernelFunc:hpe},fpe=Dt(mo),S_;function mpe(e){S_=e.wasm.cwrap(ho,null,["number","number","number","number"])}function gpe(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,p=i,{transposed:u,axes:d,originalAxes:h,inputWasTransposed:c}=us(i,a,t),f=d;if(c){let x=t.dataIdMap.get(u.dataId).id;x!==o&&(p=u,l=x,f=N.getInnerMostAxes(f.length,p.shape.length))}N.assertAxesAreInnerMostDims("sum",f,p.shape.length);let[m,g]=N.computeOutAndReduceShapes(p.shape,f),y=w.sizeFromShape(g),b=t.makeOutput(m,p.dtype);if(w.sizeFromShape(p.shape)!==0){let x=t.dataIdMap.get(b.dataId).id;S_(l,y,Ze[b.dtype],x)}if(c&&t.disposeData(u.dataId),s){let x=N.expandShapeToKeepDim(b.shape,h);b.shape=x}return b}var ype={kernelName:ho,backendName:"wasm",setupFunc:mpe,kernelFunc:gpe},bpe=je(go),xpe=je(yo),N_;function vpe(e){N_=e.wasm.cwrap(Yl,null,["number","number","number","number","number","number","array","number","number","number"])}function wpe(e){let{backend:t,inputs:n,attrs:r}=e,{tensor:a,indices:s,updates:i}=n,o=t.makeOutput(a.shape,a.dtype);if(w.sizeFromShape(a.shape)===0)return o;let{sliceRank:l,numUpdates:p,sliceSize:u,strides:d,outputSize:h}=Dc.calculateShapes(i,s,a.shape),c=t.dataIdMap.get(s.dataId).id,f=t.dataIdMap.get(i.dataId).id,m=t.dataIdMap.get(a.dataId).id,g=new Uint8Array(new Int32Array(d).buffer),y=t.dataIdMap.get(o.dataId).id;return N_(c,f,Ze[i.dtype],l,p,u,g,h,y,m),o}var kpe={kernelName:Yl,backendName:"wasm",setupFunc:vpe,kernelFunc:wpe},T_;function Ipe(e){T_=e.wasm.cwrap(es,null,["number","array","number","array","number","number"])}function Spe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,s=n.dataIdMap.get(a.dataId).id,{reps:i}=r,o=new Array(a.shape.length);for(let h=0;h<o.length;h++)o[h]=a.shape[h]*i[h];let l=new Uint8Array(new Int32Array(a.shape).buffer),p=new Uint8Array(new Int32Array(o).buffer),u=n.makeOutput(o,a.dtype),d=n.dataIdMap.get(u.dataId).id;return T_(s,l,a.shape.length,p,o.length,Ze[u.dtype],d),u}var Npe={kernelName:es,backendName:"wasm",setupFunc:Ipe,kernelFunc:Spe},C_;function Tpe(e){C_=e.wasm.cwrap(ou,null,["number","array","number","number","number","bool","number","number"])}var Cpe=({inputs:e,backend:t,attrs:n})=>{let{x:r}=e,{k:a,sorted:s}=n,i=t.dataIdMap.get(r.dataId).id,o=new Uint8Array(new Int32Array(r.shape).buffer),l=r.shape.slice();l[l.length-1]=a;let p=t.makeOutput(l,r.dtype),u=t.dataIdMap.get(p.dataId).id,d=t.makeOutput(l,"int32"),h=t.dataIdMap.get(d.dataId).id;return C_(i,o,r.shape.length,Ze[r.dtype],a,s,u,h),[p,d]},_pe={kernelName:ou,backendName:"wasm",setupFunc:Tpe,kernelFunc:Cpe},__;function Epe(e){__=e.wasm.cwrap(lu,null,["number","number","bool","number","number","number","number","number","number","array","number","array","number","number","number","number","number"])}function $pe(e){let{backend:t,inputs:n,attrs:r}=e,{image:a,transforms:s}=n,{interpolation:i,fillMode:o,fillValue:l,outputShape:p}=r,[u,d,h,c]=a.shape,[f,m]=p??[d,h],g=[u,f,m,c],y=new Uint8Array(new Int32Array(w.computeStrides(a.shape)).buffer),b=new Uint8Array(new Int32Array(w.computeStrides(g)).buffer),x=t.makeOutput(g,a.dtype),v=t.dataIdMap.get(x.dataId).id,I=t.dataIdMap.get(a.dataId).id,T=t.dataIdMap.get(s.dataId).id,_=i==="nearest"?1:2,E;switch(o){case"constant":E=1;break;case"reflect":E=2;break;case"wrap":E=3;break;case"nearest":E=4;break;default:E=1;break}return __(I,T,s.shape[0]>1,u,f,m,c,h,d,y,a.shape.length-1,b,g.length-1,_,E,l,v),x}var Ape={kernelName:lu,backendName:"wasm",setupFunc:Epe,kernelFunc:$pe};function Fpe(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t,{outputValues:i,outputShape:o,indices:l}=Nx(r.readSync(s.dataId),a,s.shape,s.dtype);return[r.makeOutput(o,s.dtype,void 0,i),r.makeOutput([l.length],"int32",void 0,l)]}var Rpe={kernelName:Vp,backendName:"wasm",kernelFunc:Fpe};function Dpe(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:s}=r;s<0&&(s+=a.shape.length);let i=a.shape[s],o=a.shape.length,l=new Array(o-1),p=0;for(let c=0;c<o;c++)c!==s&&(l[p++]=a.shape[c]);let u=new Array(i),d=new Array(o).fill(0),h=a.shape.slice();h[s]=1;for(let c=0;c<u.length;c++)d[s]=c,u[c]=Zs({inputs:{x:a},attrs:{begin:d,size:h},backend:n});return u.map(({dataId:c,dtype:f})=>({dataId:c,dtype:f,shape:l}))}var Mpe={kernelName:uu,backendName:"wasm",kernelFunc:Dpe};function Ope(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(0),r}var Lpe={kernelName:pu,backendName:"wasm",kernelFunc:Ope},zpe=[Eae,$ae,Aae,Fae,Rae,Oae,Gae,qae,Kae,Xae,Zae,Jae,Yae,Qae,ese,rse,hse,ise,use,gse,kse,Nse,Tse,_se,Ese,$se,Rse,Dse,Lse,Bse,Use,jse,Xse,Zse,Jse,eie,rie,iie,uie,hie,mie,bie,wie,Sie,Cie,_ie,Aie,Rie,Die,Mie,Oie,Lie,zie,Wie,Vie,Uie,jie,Xie,Yie,toe,aoe,ioe,loe,Lae,uoe,poe,doe,foe,goe,boe,woe,Ioe,koe,Noe,Toe,_oe,$oe,Roe,Ooe,Poe,Boe,Uoe,joe,Xoe,Yoe,tle,ale,ole,lle,dle,gle,yle,ble,xle,kle,Nle,_le,$le,Rle,Mle,Lle,r_,Ble,Ule,jle,Kle,Xle,Zle,Jle,Yle,cse,tue,aue,oue,pue,cue,gue,yue,bue,wue,Sue,Cue,_ue,Aue,Fue,Rue,Due,vse,cle,Mue,Lue,Bue,Uue,Hue,que,Zue,Yue,Que,epe,tpe,ape,ope,upe,dpe,cpe,fpe,ype,bpe,xpe,kpe,Npe,_pe,Ape,Wae,Rpe,Mpe,Lpe];for(let e of zpe)Gp(e);var Km=G();Km.registerFlag("WASM_HAS_SIMD_SUPPORT",async()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))}catch{return!1}});Km.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",async()=>{if(Km.get("IS_NODE"))return!1;try{return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}});var f0=Ja(x$()),Ppe=Ja(v$()),m0=Ja(w$()),g0=f0.default||f0,Bpe=m0.default||m0,E_=class extends wp{constructor(e){super(),this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount($_),Xm=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new jh(this,lr())}write(e,t,n){let r={id:this.dataIdNextNumber++};return this.move(r,e,t,n,1),r}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){let t=w.now();return e(),{kernelMs:w.now()-t}}move(e,t,n,r,a){let s=this.dataIdNextNumber++;if(r==="string"){let p=t;this.dataIdMap.set(e,{id:s,stringBytes:p,shape:n,dtype:r,memoryOffset:null,refCount:a});return}let i=w.sizeFromShape(n),o=i*w.bytesPerElement(r),l=this.wasm._malloc(o)>>>0;this.dataIdMap.set(e,{id:s,memoryOffset:l,shape:n,dtype:r,refCount:a}),this.wasm.tfjs.registerTensor(s,i,l),t!=null&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,o),l)}async read(e){return this.readSync(e)}readSync(e,t,n){let{memoryOffset:r,dtype:a,shape:s,stringBytes:i}=this.dataIdMap.get(e);if(a==="string")return(t==null||t===0)&&(n==null||n>=i.length)?i:i.slice(t,n);t=t||0,n=n||w.sizeFromShape(s);let o=w.bytesPerElement(a),l=this.wasm.HEAPU8.slice(r+t*o,r+n*o);return Upe(l.buffer,a)}disposeData(e,t=!1){if(this.dataIdMap.has(e)){let n=this.dataIdMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){let t=this.dataIdMap.get(e);t!=null&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,n,r){let a;if(n==null)a=this.write(r??null,e,t);else{let s=this.dataIdNextNumber++;a={id:s},this.dataIdMap.set(a,{id:s,memoryOffset:n,shape:e,dtype:t,refCount:1});let i=w.sizeFromShape(e);this.wasm.tfjs.registerTensor(s,i,n)}return{dataId:a,shape:e,dtype:t}}typedArrayFromHeap({shape:e,dtype:t,dataId:n}){let r=this.wasm.HEAPU8.buffer,{memoryOffset:a}=this.dataIdMap.get(n),s=w.sizeFromShape(e);switch(t){case"float32":return new Float32Array(r,a,s);case"int32":return new Int32Array(r,a,s);case"bool":return new Uint8Array(r,a,s);default:throw new Error(`Unknown dtype ${t}`)}}};function Wpe(e){return(t,n)=>(w.fetch(e,{credentials:"same-origin"}).then(r=>{r.ok||t.env.a(`failed to load wasm binary file at '${e}'`),r.arrayBuffer().then(a=>{WebAssembly.instantiate(a,t).then(s=>{n(s.instance,s.module)})})}),{})}function y0(e,t,n){if(Bh!=null)return Bh;let r="tfjs-backend-wasm.wasm";return e&&t?r="tfjs-backend-wasm-threaded-simd.wasm":e&&(r="tfjs-backend-wasm-simd.wasm"),ep!=null&&ep[r]!=null?ep[r]:n+r}async function Vpe(){let[e,t]=await Promise.all([G().getAsync("WASM_HAS_SIMD_SUPPORT"),G().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((n,r)=>{let a={};a.locateFile=(o,l)=>{if(o.endsWith(".worker.js")){let p=Ppe.wasmWorkerContents.replace(/\n/g,"\\n"),u=new Blob([p],{type:"application/javascript"});return URL.createObjectURL(u)}return o.endsWith(".wasm")?y0(e,t,Ju??l):l+o},jx&&(a.instantiateWasm=Wpe(y0(e,t,Ju??"")));let s=!1;a.onAbort=()=>{s||tp||(tp=!0,r({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"}))};let i;t&&e&&Bh==null?(a.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+g0.toString()],{type:"text/javascript"}),i=g0(a)):i=Bpe(a),i.then(o=>{s=!0,tp=!1;let l=null;o.tfjs={init:o.cwrap("init",null,[]),initWithThreadsCount:o.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:o.cwrap("get_threads_count","number",[]),registerTensor:o.cwrap("register_tensor",null,["number","number","number"]),disposeData:o.cwrap("dispose_data",l,["number"]),dispose:o.cwrap("dispose",l,[])},n({wasm:o})}).catch(r)})}function Upe(e,t){switch(t){case"float32":return new Float32Array(e);case"int32":return new Int32Array(e);case"bool":return new Uint8Array(e);default:throw new Error(`Unknown dtype ${t}`)}}var Gpe=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],Bh=null,Ju=null,ep={},tp=!1,jx=!1;function Hpe(e,t=!1){if(J0("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),tp)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");Bh=e,jx=t}function jpe(e,t=!1){if(tp)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if(typeof e=="string")Ju=e;else{ep=e;let n=Gpe.filter(r=>ep[r]==null);if(n.length>0)throw new Error(`There were no entries found for the following binaries: ${n.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}jx=t}var $_=-1,Xm=-1;function qpe(e){$_=e}function Kpe(){if(Xm===-1)throw new Error("WASM backend not initialized.");return Xm}var Xpe="4.22.0",Zpe=2;pc("wasm",async()=>{let{wasm:e}=await Vpe();return new E_(e)},Zpe);var b0="4.22.0",Jpe="4.22.0",Ype="4.22.0",Qpe="4.22.0",ede="4.22.0",tde={tfjs:b0,"tfjs-core":b0,"tfjs-converter":Jpe,"tfjs-backend-cpu":Ype,"tfjs-backend-webgl":Qpe,"tfjs-backend-wasm":ede},nde={};eg(nde,{AnchorPosition:()=>j_,DrawBox:()=>X_,DrawBoxOptions:()=>K_,DrawFaceLandmarks:()=>hE,DrawFaceLandmarksOptions:()=>dE,DrawTextField:()=>Qx,DrawTextFieldOptions:()=>Yx,drawContour:()=>Na,drawDetections:()=>mde,drawFaceExpressions:()=>_de,drawFaceLandmarks:()=>$de});function Na(e,t,n=!1){if(e.beginPath(),t.slice(1).forEach(({x:r,y:a},s)=>{let i=t[s];e.moveTo(i.x,i.y),e.lineTo(r,a)}),n){let r=t[t.length-1],a=t[0];if(!r||!a)return;e.moveTo(r.x,r.y),e.lineTo(a.x,a.y)}e.stroke()}var rde={};eg(rde,{computeReshapedDimensions:()=>D_,getCenterPoint:()=>Kx,isDimensions:()=>Jm,isEven:()=>Zm,isFloat:()=>R_,isTensor:()=>Fu,isTensor1D:()=>ade,isTensor2D:()=>F_,isTensor3D:()=>Id,isTensor4D:()=>oa,isValidNumber:()=>As,isValidProbablitiy:()=>sde,range:()=>ll,round:()=>qx});var Go=class A_{constructor(t,n){if(!As(t)||!As(n))throw new Error(`Dimensions.constructor - expected width and height to be valid numbers, instead have ${JSON.stringify({width:t,height:n})}`);this._width=t,this._height=n}get width(){return this._width}get height(){return this._height}reverse(){return new A_(1/this.width,1/this.height)}};function Fu(e,t){return e instanceof Fe&&e.shape.length===t}function ade(e){return Fu(e,1)}function F_(e){return Fu(e,2)}function Id(e){return Fu(e,3)}function oa(e){return Fu(e,4)}function R_(e){return e%1!==0}function Zm(e){return e%2===0}function qx(e,t=2){let n=10**t;return Math.floor(e*n)/n}function Jm(e){return e&&e.width&&e.height}function D_({width:e,height:t},n){let r=n/Math.max(t,e);return new Go(Math.round(e*r),Math.round(t*r))}function Kx(e){return e.reduce((t,n)=>t.add(n),new at(0,0)).div(new at(e.length,e.length))}function ll(e,t,n){return Array(e).fill(0).map((r,a)=>t+a*n)}function As(e){return!!e&&e!==1/0&&e!==-1/0&&!Number.isNaN(e)||e===0}function sde(e){return As(e)&&e>=0&&e<=1}var at=class vs{constructor(t,n){this._x=t,this._y=n}get x(){return this._x}get y(){return this._y}add(t){return new vs(this.x+t.x,this.y+t.y)}sub(t){return new vs(this.x-t.x,this.y-t.y)}mul(t){return new vs(this.x*t.x,this.y*t.y)}div(t){return new vs(this.x/t.x,this.y/t.y)}abs(){return new vs(Math.abs(this.x),Math.abs(this.y))}magnitude(){return Math.sqrt(this.x**2+this.y**2)}floor(){return new vs(Math.floor(this.x),Math.floor(this.y))}},Js=class yr{static isRect(t){return!!t&&[t.x,t.y,t.width,t.height].every(As)}static assertIsValidBox(t,n,r=!1){if(!yr.isRect(t))throw new Error(`${n} - invalid box: ${JSON.stringify(t)}, expected object with properties x, y, width, height`);if(!r&&(t.width<0||t.height<0))throw new Error(`${n} - width (${t.width}) and height (${t.height}) must be positive numbers`)}constructor(t,n=!0){let r=t||{},a=[r.left,r.top,r.right,r.bottom].every(As),s=[r.x,r.y,r.width,r.height].every(As);if(!s&&!a)throw new Error(`Box.constructor - expected box to be IBoundingBox | IRect, instead have ${JSON.stringify(r)}`);let[i,o,l,p]=s?[r.x,r.y,r.width,r.height]:[r.left,r.top,r.right-r.left,r.bottom-r.top];yr.assertIsValidBox({x:i,y:o,width:l,height:p},"Box.constructor",n),this._x=i,this._y=o,this._width=l,this._height=p}get x(){return this._x}get y(){return this._y}get width(){return this._width}get height(){return this._height}get left(){return this.x}get top(){return this.y}get right(){return this.x+this.width}get bottom(){return this.y+this.height}get area(){return this.width*this.height}get topLeft(){return new at(this.left,this.top)}get topRight(){return new at(this.right,this.top)}get bottomLeft(){return new at(this.left,this.bottom)}get bottomRight(){return new at(this.right,this.bottom)}round(){let[t,n,r,a]=[this.x,this.y,this.width,this.height].map(s=>Math.round(s));return new yr({x:t,y:n,width:r,height:a})}floor(){let[t,n,r,a]=[this.x,this.y,this.width,this.height].map(s=>Math.floor(s));return new yr({x:t,y:n,width:r,height:a})}toSquare(){let{x:t,y:n,width:r,height:a}=this,s=Math.abs(r-a);return r<a&&(t-=s/2,r+=s),a<r&&(n-=s/2,a+=s),new yr({x:t,y:n,width:r,height:a})}rescale(t){let n=Jm(t)?t.width:t,r=Jm(t)?t.height:t;return new yr({x:this.x*n,y:this.y*r,width:this.width*n,height:this.height*r})}pad(t,n){let[r,a,s,i]=[this.x-t/2,this.y-n/2,this.width+t,this.height+n];return new yr({x:r,y:a,width:s,height:i})}clipAtImageBorders(t,n){let{x:r,y:a,right:s,bottom:i}=this,o=Math.max(r,0),l=Math.max(a,0),p=s-o,u=i-l,d=Math.min(p,t-o),h=Math.min(u,n-l);return new yr({x:o,y:l,width:d,height:h}).floor()}shift(t,n){let{width:r,height:a}=this,s=this.x+t,i=this.y+n;return new yr({x:s,y:i,width:r,height:a})}padAtBorders(t,n){let r=this.width+1,a=this.height+1,s=1,i=1,o=r,l=a,p=this.left,u=this.top,d=this.right,h=this.bottom;return d>n&&(o=-d+n+r,d=n),h>t&&(l=-h+t+a,h=t),p<1&&(l=2-p,p=1),u<1&&(l=2-u,u=1),{dy:i,edy:l,dx:s,edx:o,y:u,ey:h,x:p,ex:d,w:r,h:a}}calibrate(t){return new yr({left:this.left+t.left*this.width,top:this.top+t.top*this.height,right:this.right+t.right*this.width,bottom:this.bottom+t.bottom*this.height}).toSquare().round()}},M_=class extends Js{constructor(e,t,n,r,a=!1){super({left:e,top:t,right:n,bottom:r},a)}},O_=class L_{constructor(t,n,r,a,s){this._imageDims=new Go(s.width,s.height),this._score=t,this._classScore=n,this._className=r,this._box=new Js(a).rescale(this._imageDims)}get score(){return this._score}get classScore(){return this._classScore}get className(){return this._className}get box(){return this._box}get imageDims(){return this._imageDims}get imageWidth(){return this.imageDims.width}get imageHeight(){return this.imageDims.height}get relativeBox(){return new Js(this._box).rescale(this.imageDims.reverse())}forSize(t,n){return new L_(this.score,this.classScore,this.className,this.relativeBox,{width:t,height:n})}},Cr=class z_ extends O_{constructor(t,n,r){super(t,t,"",n,r)}forSize(t,n){let{score:r,relativeBox:a,imageDims:s}=super.forSize(t,n);return new z_(r,a,s)}};function ide(e,t,n=!0){let r=Math.max(0,Math.min(e.right,t.right)-Math.max(e.left,t.left)),a=Math.max(0,Math.min(e.bottom,t.bottom)-Math.max(e.top,t.top)),s=r*a;return n?s/(e.area+t.area-s):s/Math.min(e.area,t.area)}function ode(e){let t=e.map(o=>o.x),n=e.map(o=>o.y),r=t.reduce((o,l)=>l<o?l:o,1/0),a=n.reduce((o,l)=>l<o?l:o,1/0),s=t.reduce((o,l)=>o<l?l:o,0),i=n.reduce((o,l)=>o<l?l:o,0);return new M_(r,a,s,i)}function lde(e,t,n,r=!0){let a=t.map((i,o)=>({score:i,boxIndex:o})).sort((i,o)=>i.score-o.score).map(i=>i.boxIndex),s=[];for(;a.length>0;){let i=a.pop();s.push(i);let o=a,l=[];for(let p=0;p<o.length;p++){let u=o[p],d=e[i],h=e[u];l.push(ide(d,h,r))}a=a.filter((p,u)=>l[u]<=n)}return s}function Sd(e,t){return B(()=>{let[n,r,a]=t,s=Bn([...e.shape.slice(0,3),1],n,"float32"),i=Bn([...e.shape.slice(0,3),1],r,"float32"),o=Bn([...e.shape.slice(0,3),1],a,"float32"),l=it([s,i,o],3);return de(e,l)})}function ude(e,t=!1){return B(()=>{let[n,r]=e.shape.slice(1);if(n===r)return e;let a=Math.abs(n-r),s=Math.round(a*(t?.5:1)),i=n>r?2:1,o=d=>{let h=e.shape.slice();return h[i]=d,Bn(h,0,"float32")},l=o(s),p=a-l.shape[i],u=[t&&p?o(p):null,e,l].filter(d=>!!d).map(d=>se(d,"float32"));return it(u,i)})}function Gf(e){return 1/(1+Math.exp(-e))}var P_=class extends Js{constructor(e,t,n,r,a=!1){super({x:e,y:t,width:n,height:r},a)}},pde=.5,dde=.43,hde=.45,Wh=class{constructor(e,t,n=new at(0,0)){let{width:r,height:a}=t;this._imgDims=new Go(r,a),this._shift=n,this._positions=e.map(s=>s.mul(new at(r,a)).add(n))}get shift(){return new at(this._shift.x,this._shift.y)}get imageWidth(){return this._imgDims.width}get imageHeight(){return this._imgDims.height}get positions(){return this._positions}get relativePositions(){return this._positions.map(e=>e.sub(this._shift).div(new at(this.imageWidth,this.imageHeight)))}forSize(e,t){return new this.constructor(this.relativePositions,{width:e,height:t})}shiftBy(e,t){return new this.constructor(this.relativePositions,this._imgDims,new at(e,t))}shiftByPoint(e){return this.shiftBy(e.x,e.y)}align(e,t={}){if(e){let a=e instanceof Cr?e.box.floor():new Js(e);return this.shiftBy(a.x,a.y).align(null,t)}let{useDlibAlignment:n,minBoxPadding:r}={useDlibAlignment:!1,minBoxPadding:.2,...t};return n?this.alignDlib():this.alignMinBbox(r)}alignDlib(){let e=this.getRefPointsForAlignment(),[t,n,r]=e,a=u=>r.sub(u).magnitude(),s=(a(t)+a(n))/2,i=Math.floor(s/hde),o=Kx(e),l=Math.floor(Math.max(0,o.x-pde*i)),p=Math.floor(Math.max(0,o.y-dde*i));return new P_(l,p,Math.min(i,this.imageWidth+l),Math.min(i,this.imageHeight+p))}alignMinBbox(e){let t=ode(this.positions);return t.pad(t.width*e,t.height*e)}getRefPointsForAlignment(){throw new Error("getRefPointsForAlignment not implemented by base class")}},B_=class extends Wh{getJawOutline(){return this.positions.slice(0,17)}getLeftEyeBrow(){return this.positions.slice(17,22)}getRightEyeBrow(){return this.positions.slice(22,27)}getNose(){return this.positions.slice(27,36)}getLeftEye(){return this.positions.slice(36,42)}getRightEye(){return this.positions.slice(42,48)}getMouth(){return this.positions.slice(48,68)}getRefPointsForAlignment(){return[this.getLeftEye(),this.getRightEye(),this.getMouth()].map(Kx)}};function Vh(e){return e.detection instanceof Cr}function W_(e,t){return{...e,detection:t}}function V_(){let e=window.fetch;if(!e)throw new Error("fetch - missing fetch implementation for browser environment");return{Canvas:HTMLCanvasElement,CanvasRenderingContext2D,Image:HTMLImageElement,ImageData,Video:HTMLVideoElement,createCanvasElement:()=>document.createElement("canvas"),createImageElement:()=>document.createElement("img"),createVideoElement:()=>document.createElement("video"),fetch:e,readFile:()=>{throw new Error("readFile - filesystem not available for browser environment")}}}function Xx(){return typeof global=="object"&&typeof process<"u"&&process.versions!=null&&process.versions.node!=null}function U_(e){let t="";if(!e&&Xx())try{e=JE("fs")}catch(n){t=n.toString()}return{readFile:e?n=>new Promise((r,a)=>{e.readFile(n,(s,i)=>s?a(s):r(i))}):()=>{throw new Error(`readFile - failed to require fs in nodejs environment with error: ${t}`)}}}function G_(){let e=global.Canvas||global.HTMLCanvasElement,t=global.Image||global.HTMLImageElement,n=global.Video||global.HTMLVideoElement,r=()=>{if(e)return new e;throw new Error("createCanvasElement - missing Canvas implementation for nodejs environment")},a=()=>{if(t)return new t;throw new Error("createImageElement - missing Image implementation for nodejs environment")},s=()=>{if(n)return new n;throw new Error("createVideoElement - missing Video implementation for nodejs environment")},i=global.fetch,o=U_();return{Canvas:e||class{},CanvasRenderingContext2D:global.CanvasRenderingContext2D||class{},Image:t||class{},ImageData:global.ImageData||class{},Video:global.HTMLVideoElement||class{},createCanvasElement:r,createImageElement:a,createVideoElement:s,fetch:i,...o}}function H_(){return typeof window=="object"&&typeof document<"u"&&typeof HTMLImageElement<"u"&&typeof HTMLCanvasElement<"u"&&typeof HTMLVideoElement<"u"&&typeof ImageData<"u"&&typeof CanvasRenderingContext2D<"u"}var Wt;function cde(){if(!Wt)throw new Error("getEnv - environment is not defined, check isNodejs() and isBrowser()");return Wt}function Ym(e){Wt=e}function Zx(){return H_()?Ym(V_()):Xx()?Ym(G_()):null}function fde(e){if(Wt||Zx(),!Wt)throw new Error("monkeyPatch - environment is not defined, check isNodejs() and isBrowser()");let{Canvas:t=Wt.Canvas,Image:n=Wt.Image}=e;Wt.Canvas=t,Wt.Image=n,Wt.createCanvasElement=e.createCanvasElement||(()=>new t),Wt.createImageElement=e.createImageElement||(()=>new n),Wt.ImageData=e.ImageData||Wt.ImageData,Wt.Video=e.Video||Wt.Video,Wt.fetch=e.fetch||Wt.fetch,Wt.readFile=e.readFile||Wt.readFile}var An={getEnv:cde,setEnv:Ym,initialize:Zx,createBrowserEnv:V_,createFileSystem:U_,createNodejsEnv:G_,monkeyPatch:fde,isBrowser:H_,isNodejs:Xx};Zx();function Jx(e){return!An.isNodejs()&&typeof e=="string"?document.getElementById(e):e}function Za(e){let{Canvas:t,CanvasRenderingContext2D:n}=An.getEnv();if(e instanceof n)return e;let r=Jx(e);if(!(r instanceof t))throw new Error("resolveContext2d - expected canvas to be of instance of Canvas");let a=r.getContext("2d",{willReadFrequently:!0});if(!a)throw new Error("resolveContext2d - canvas 2d context is null");return a}var j_=(e=>(e.TOP_LEFT="TOP_LEFT",e.TOP_RIGHT="TOP_RIGHT",e.BOTTOM_LEFT="BOTTOM_LEFT",e.BOTTOM_RIGHT="BOTTOM_RIGHT",e))(j_||{}),Yx=class{constructor(e={}){let{anchorPosition:t,backgroundColor:n,fontColor:r,fontSize:a,fontStyle:s,padding:i}=e;this.anchorPosition=t||"TOP_LEFT",this.backgroundColor=n||"rgba(0, 0, 0, 0.5)",this.fontColor=r||"rgba(255, 255, 255, 1)",this.fontSize=a||14,this.fontStyle=s||"Georgia",this.padding=i||4}},Qx=class q_{constructor(t,n,r={}){this.text=typeof t=="string"?[t]:t instanceof q_?t.text:t,this.anchor=n,this.options=new Yx(r)}measureWidth(t){let{padding:n}=this.options;return this.text.map(r=>t.measureText(r).width).reduce((r,a)=>r<a?a:r,0)+2*n}measureHeight(){let{fontSize:t,padding:n}=this.options;return this.text.length*t+2*n}getUpperLeft(t,n){let{anchorPosition:r}=this.options,a=r==="BOTTOM_RIGHT"||r==="TOP_RIGHT",s=r==="BOTTOM_LEFT"||r==="BOTTOM_RIGHT",i=this.measureWidth(t),o=this.measureHeight(),l=a?this.anchor.x-i:this.anchor.x,p=s?this.anchor.y-o:this.anchor.y;if(n){let{width:u,height:d}=n,h=Math.max(Math.min(l,u-i),0),c=Math.max(Math.min(p,d-o),0);return{x:h,y:c}}return{x:l,y:p}}draw(t){let n=Jx(t),r=Za(n),{backgroundColor:a,fontColor:s,fontSize:i,fontStyle:o,padding:l}=this.options;r.font=`${i}px ${o}`;let p=this.measureWidth(r),u=this.measureHeight();r.fillStyle=a;let d=this.getUpperLeft(r,n);r.fillRect(d.x,d.y,p,u),r.fillStyle=s,this.text.forEach((h,c)=>{let f=l+d.x,m=l+d.y+(c+1)*i;r.fillText(h,f,m)})}},K_=class{constructor(e={}){let{boxColor:t,lineWidth:n,label:r,drawLabelOptions:a}=e;this.boxColor=t||"rgba(0, 0, 255, 1)",this.lineWidth=n||2,this.label=r;let s={anchorPosition:"BOTTOM_LEFT",backgroundColor:this.boxColor};this.drawLabelOptions=new Yx({...s,...a})}},X_=class{constructor(e,t={}){this.box=new Js(e),this.options=new K_(t)}draw(e){let t=Za(e),{boxColor:n,lineWidth:r}=this.options,{x:a,y:s,width:i,height:o}=this.box;t.strokeStyle=n,t.lineWidth=r,t.strokeRect(a,s,i,o);let{label:l}=this.options;l&&new Qx([l],{x:a-r/2,y:s},this.options.drawLabelOptions).draw(e)}};function mde(e,t){(Array.isArray(t)?t:[t]).forEach(n=>{let r=n instanceof Cr?n.score:Vh(n)?n.detection.score:void 0,a=n instanceof Cr?n.box:Vh(n)?n.detection.box:new Js(n),s=r?`${qx(r)}`:void 0;new X_(a,{label:s}).draw(e)})}function Z_(e){let{Image:t,Video:n}=An.getEnv();return e instanceof t&&e.complete||e instanceof n&&e.readyState>=3}function gde(e){return new Promise((t,n)=>{if(e instanceof An.getEnv().Canvas||Z_(e)){t(null);return}function r(s){s.currentTarget&&(s.currentTarget.removeEventListener("load",a),s.currentTarget.removeEventListener("error",r),n(s))}function a(s){s.currentTarget&&(s.currentTarget.removeEventListener("load",a),s.currentTarget.removeEventListener("error",r),t(s))}e.addEventListener("load",a),e.addEventListener("error",r)})}function J_(e){let{Image:t,Video:n}=An.getEnv();return e instanceof t?new Go(e.naturalWidth,e.naturalHeight):e instanceof n?new Go(e.videoWidth,e.videoHeight):new Go(e.width,e.height)}function Uh({width:e,height:t}){let{createCanvasElement:n}=An.getEnv(),r=n();return r.width=e,r.height=t,r}function Y_(e,t){let{ImageData:n}=An.getEnv();if(!(e instanceof n)&&!Z_(e))throw new Error("createCanvasFromMedia - media has not finished loading yet");let{width:r,height:a}=J_(e),s=Uh({width:r,height:a});return e instanceof n?Za(s).putImageData(e,0,0):Za(s).drawImage(e,0,0,r,a),s}async function yde(e,t){let n=t||An.getEnv().createCanvasElement(),[r,a,s]=e.shape.slice(oa(e)?1:0),i=B(()=>e.as3D(r,a,s).toInt());return await ud.toPixels(i,n),i.dispose(),n}function x0(e){let{Image:t,Canvas:n,Video:r}=An.getEnv();return e instanceof t||e instanceof n||e instanceof r}function bde(e,t,n=!1){let{Image:r,Canvas:a}=An.getEnv();if(!(e instanceof r||e instanceof a))throw new Error("imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement");if(t<=0)return Uh({width:1,height:1});let s=J_(e),i=t/Math.max(s.height,s.width),o=i*s.width,l=i*s.height,p=Uh({width:t,height:t}),u=e instanceof a?e:Y_(e),d=Math.abs(o-l)/2,h=n&&o<l?d:0,c=n&&l<o?d:0;return u.width>0&&u.height>0&&Za(p).drawImage(u,h,c,o,l),p}var Gh=class{constructor(e,t=!1){if(this._imageTensors=[],this._canvases=[],this._treatAsBatchInput=!1,this._inputDimensions=[],this._inputSize=0,!Array.isArray(e))throw new Error(`NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have ${e}`);this._treatAsBatchInput=t,this._batchSize=e.length,e.forEach((n,r)=>{if(Id(n)){this._imageTensors[r]=n,this._inputDimensions[r]=n.shape;return}if(oa(n)){let s=n.shape[0];if(s!==1)throw new Error(`NetInput - tf.Tensor4D with batchSize ${s} passed, but not supported in input array`);this._imageTensors[r]=n,this._inputDimensions[r]=n.shape.slice(1);return}let a=n instanceof An.getEnv().Canvas?n:Y_(n);this._canvases[r]=a,this._inputDimensions[r]=[a.height,a.width,3]})}get imageTensors(){return this._imageTensors}get canvases(){return this._canvases}get isBatchInput(){return this.batchSize>1||this._treatAsBatchInput}get batchSize(){return this._batchSize}get inputDimensions(){return this._inputDimensions}get inputSize(){return this._inputSize}get reshapedInputDimensions(){return ll(this.batchSize,0,1).map((e,t)=>this.getReshapedInputDimensions(t))}getInput(e){return this.canvases[e]||this.imageTensors[e]}getInputDimensions(e){return this._inputDimensions[e]}getInputHeight(e){return this._inputDimensions[e][0]}getInputWidth(e){return this._inputDimensions[e][1]}getReshapedInputDimensions(e){if(typeof this.inputSize!="number")throw new Error("getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet");let t=this.getInputWidth(e),n=this.getInputHeight(e);return D_({width:t,height:n},this.inputSize)}toBatchTensor(e,t=!0){return this._inputSize=e,B(()=>{let n=ll(this.batchSize,0,1).map(r=>{let a=this.getInput(r);if(a instanceof Fe){let s=oa(a)?a:Ht(a);return s=ude(s,t),(s.shape[1]!==e||s.shape[2]!==e)&&(s=Zn.resizeBilinear(s,[e,e],!1,!1)),s.as3D(e,e,3)}if(a instanceof An.getEnv().Canvas)return ud.fromPixels(bde(a,e,t));throw new Error(`toBatchTensor - at batchIdx ${r}, expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have ${a}`)});return At(n.map(r=>se(r,"float32"))).as4D(this.batchSize,e,e,3)})}};async function gn(e){if(e instanceof Gh)return e;let t=Array.isArray(e)?e:[e];if(!t.length)throw new Error("toNetInput - empty array passed as input");let n=a=>Array.isArray(e)?` at input index ${a}:`:"",r=t.map(Jx);return r.forEach((a,s)=>{if(!x0(a)&&!Id(a)&&!oa(a))throw typeof t[s]=="string"?new Error(`toNetInput -${n(s)} string passed, but could not resolve HTMLElement for element id ${t[s]}`):new Error(`toNetInput -${n(s)} expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id`);if(oa(a)){let i=a.shape[0];if(i!==1)throw new Error(`toNetInput -${n(s)} tf.Tensor4D with batchSize ${i} passed, but not supported in input array`)}}),await Promise.all(r.map(a=>x0(a)&&gde(a))),new Gh(r,Array.isArray(e))}async function ev(e,t){let{Canvas:n}=An.getEnv(),r=e;if(!(e instanceof n)){let s=await gn(e);if(s.batchSize>1)throw new Error("extractFaces - batchSize > 1 not supported");let i=s.getInput(0);r=i instanceof n?i:await yde(i)}let a=Za(r);return t.map(s=>s instanceof Cr?s.forSize(r.width,r.height).box.floor():s).map(s=>s.clipAtImageBorders(r.width,r.height)).map(({x:s,y:i,width:o,height:l})=>{let p=Uh({width:o,height:l});return o>0&&l>0&&Za(p).putImageData(a.getImageData(s,i,o,l),0,0),p})}async function tv(e,t){if(!Id(e)&&!oa(e))throw new Error("extractFaceTensors - expected image tensor to be 3D or 4D");if(oa(e)&&e.shape[0]>1)throw new Error("extractFaceTensors - batchSize > 1 not supported");return B(()=>{let[n,r,a]=e.shape.slice(oa(e)?1:0);return t.map(s=>s instanceof Cr?s.forSize(r,n).box:s).map(s=>s.clipAtImageBorders(r,n)).filter(s=>s.width>0&&s.height>0).map(({x:s,y:i,width:o,height:l})=>bu(e.as3D(n,r,a),[i,s,0],[l,o,a]))})}async function xde(e,t){let{fetch:n}=An.getEnv(),r=await n(e,t);if(!(r.status<400))throw new Error(`failed to fetch: (${r.status}) ${r.statusText}, from url: ${r.url}`);return r}async function vde(e){return(await xde(e)).json()}function Q_(e,t){let n=`${t}-weights_manifest.json`;if(!e)return{modelBaseUri:"",manifestUri:n};if(e==="/")return{modelBaseUri:"/",manifestUri:`/${n}`};let r=e.startsWith("http://")?"http://":e.startsWith("https://")?"https://":"";e=e.replace(r,"");let a=e.split("/").filter(o=>o),s=e.endsWith(".json")?a[a.length-1]:n,i=r+(e.endsWith(".json")?a.slice(0,a.length-1):a).join("/");return i=e.startsWith("/")?`/${i}`:i,{modelBaseUri:i,manifestUri:i==="/"?`/${s}`:`${i}/${s}`}}async function wde(e,t){let{manifestUri:n,modelBaseUri:r}=Q_(e,t),a=await vde(n);return nn.loadWeights(a,r)}var ds=class{constructor(e){this._params=void 0,this._paramMappings=[],this._name=e}get params(){return this._params}get paramMappings(){return this._paramMappings}get isLoaded(){return!!this.params}getParamFromPath(e){let{obj:t,objProp:n}=this.traversePropertyPath(e);return t[n]}reassignParamFromPath(e,t){let{obj:n,objProp:r}=this.traversePropertyPath(e);n[r].dispose(),n[r]=t}getParamList(){return this._paramMappings.map(({paramPath:e})=>({path:e,tensor:this.getParamFromPath(e)}))}getTrainableParams(){return this.getParamList().filter(e=>e.tensor instanceof Ms)}getFrozenParams(){return this.getParamList().filter(e=>!(e.tensor instanceof Ms))}variable(){this.getFrozenParams().forEach(({path:e,tensor:t})=>{this.reassignParamFromPath(e,t.variable())})}freeze(){this.getTrainableParams().forEach(({path:e,tensor:t})=>{let n=cn(t.dataSync());t.dispose(),this.reassignParamFromPath(e,n)})}dispose(e=!0){this.getParamList().forEach(t=>{if(e&&t.tensor.isDisposed)throw new Error(`param tensor has already been disposed for path ${t.path}`);t.tensor.dispose()}),this._params=void 0}serializeParams(){return new Float32Array(this.getParamList().map(({tensor:e})=>Array.from(e.dataSync())).reduce((e,t)=>e.concat(t)))}async load(e){if(e instanceof Float32Array){this.extractWeights(e);return}await this.loadFromUri(e)}async loadFromUri(e){if(e&&typeof e!="string")throw new Error(`${this._name}.loadFromUri - expected model uri`);let t=await wde(e,this.getDefaultModelName());this.loadFromWeightMap(t)}async loadFromDisk(e){if(e&&typeof e!="string")throw new Error(`${this._name}.loadFromDisk - expected model file path`);let{readFile:t}=An.getEnv(),{manifestUri:n,modelBaseUri:r}=Q_(e,this.getDefaultModelName()),a=l=>Promise.all(l.map(p=>t(p).then(u=>typeof u=="string"?Buffer.from(u):u.buffer))),s=nn.weightsLoaderFactory(a),i=JSON.parse((await t(n)).toString()),o=await s(i,r);this.loadFromWeightMap(o)}loadFromWeightMap(e){let{paramMappings:t,params:n}=this.extractParamsFromWeightMap(e);this._paramMappings=t,this._params=n}extractWeights(e){let{paramMappings:t,params:n}=this.extractParams(e);this._paramMappings=t,this._params=n}traversePropertyPath(e){if(!this.params)throw new Error("traversePropertyPath - model has no loaded params");let t=e.split("/").reduce((a,s)=>{if(!a.nextObj.hasOwnProperty(s))throw new Error(`traversePropertyPath - object does not have property ${s}, for path ${e}`);return{obj:a.nextObj,objProp:s,nextObj:a.nextObj[s]}},{nextObj:this.params}),{obj:n,objProp:r}=t;if(!n||!r||!(n[r]instanceof Fe))throw new Error(`traversePropertyPath - parameter is not a tensor, for path ${e}`);return{obj:n,objProp:r}}};function Qn(e,t,n){return B(()=>{let r=yu(e,t.depthwise_filter,t.pointwise_filter,n,"same");return r=X(r,t.bias),r})}function Hf(e,t,n=!1){return B(()=>{let r=et(n?X(fn(e,t.conv0.filters,[2,2],"same"),t.conv0.bias):Qn(e,t.conv0,[2,2])),a=Qn(r,t.conv1,[1,1]),s=et(X(r,a)),i=Qn(s,t.conv2,[1,1]);return et(X(r,X(a,i)))})}function th(e,t,n=!1,r=!0){return B(()=>{let a=et(n?X(fn(e,t.conv0.filters,r?[2,2]:[1,1],"same"),t.conv0.bias):Qn(e,t.conv0,r?[2,2]:[1,1])),s=Qn(a,t.conv1,[1,1]),i=et(X(a,s)),o=Qn(i,t.conv2,[1,1]),l=et(X(a,X(s,o))),p=Qn(l,t.conv3,[1,1]);return et(X(a,X(s,X(o,p))))})}function np(e,t,n="same",r=!1){return B(()=>{let a=X(fn(e,t.filters,[1,1],n),t.bias);return r?et(a):a})}function hs(e,t){Object.keys(e).forEach(n=>{t.some(r=>r.originalPath===n)||e[n].dispose()})}function nv(e,t){return(n,r,a,s)=>{let i=Ua(e(n*r*a*a),[a,a,n,r]),o=Ye(e(r));return t.push({paramPath:`${s}/filters`},{paramPath:`${s}/bias`}),{filters:i,bias:o}}}function eE(e,t){return(n,r,a)=>{let s=Wr(e(n*r),[n,r]),i=Ye(e(r));return t.push({paramPath:`${a}/weights`},{paramPath:`${a}/bias`}),{weights:s,bias:i}}}var tE=class{constructor(e,t,n){this.depthwise_filter=e,this.pointwise_filter=t,this.bias=n}};function rv(e,t){return(n,r,a)=>{let s=Ua(e(9*n),[3,3,n,1]),i=Ua(e(n*r),[1,1,n,r]),o=Ye(e(r));return t.push({paramPath:`${a}/depthwise_filter`},{paramPath:`${a}/pointwise_filter`},{paramPath:`${a}/bias`}),new tE(s,i,o)}}function av(e){return t=>{let n=e(`${t}/depthwise_filter`,4),r=e(`${t}/pointwise_filter`,4),a=e(`${t}/bias`,1);return new tE(n,r,a)}}function Eo(e,t){return(n,r,a)=>{let s=e[n];if(!Fu(s,r))throw new Error(`expected weightMap[${n}] to be a Tensor${r}D, instead have ${s}`);return t.push({originalPath:n,paramPath:a||n}),s}}function cs(e){let t=e;function n(a){let s=t.slice(0,a);return t=t.slice(a),s}function r(){return t}return{extractWeights:n,getRemainingWeights:r}}function nE(e,t){let n=nv(e,t),r=rv(e,t);function a(i,o,l,p=!1){let u=p?n(i,o,3,`${l}/conv0`):r(i,o,`${l}/conv0`),d=r(o,o,`${l}/conv1`),h=r(o,o,`${l}/conv2`);return{conv0:u,conv1:d,conv2:h}}function s(i,o,l,p=!1){let{conv0:u,conv1:d,conv2:h}=a(i,o,l,p),c=r(o,o,`${l}/conv3`);return{conv0:u,conv1:d,conv2:h,conv3:c}}return{extractDenseBlock3Params:a,extractDenseBlock4Params:s}}function kde(e){let t=[],{extractWeights:n,getRemainingWeights:r}=cs(e),{extractDenseBlock4Params:a}=nE(n,t),s=a(3,32,"dense0",!0),i=a(32,64,"dense1"),o=a(64,128,"dense2"),l=a(128,256,"dense3");if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:s,dense1:i,dense2:o,dense3:l}}}function rE(e){return t=>{let n=e(`${t}/filters`,4),r=e(`${t}/bias`,1);return{filters:n,bias:r}}}function aE(e,t){let n=Eo(e,t),r=rE(n),a=av(n);function s(o,l=!1){let p=l?r(`${o}/conv0`):a(`${o}/conv0`),u=a(`${o}/conv1`),d=a(`${o}/conv2`);return{conv0:p,conv1:u,conv2:d}}function i(o,l=!1){let p=l?r(`${o}/conv0`):a(`${o}/conv0`),u=a(`${o}/conv1`),d=a(`${o}/conv2`),h=a(`${o}/conv3`);return{conv0:p,conv1:u,conv2:d,conv3:h}}return{extractDenseBlock3Params:s,extractDenseBlock4Params:i}}function Ide(e){let t=[],{extractDenseBlock4Params:n}=aE(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2"),dense3:n("dense3")};return hs(e,t),{params:r,paramMappings:t}}var sE=class extends ds{constructor(){super("FaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceFeatureExtractor - load model before inference");return B(()=>{let n=se(e.toBatchTensor(112,!0),"float32"),r=Sd(n,[122.782,117.001,104.298]).div(255),a=th(r,t.dense0,!0);return a=th(a,t.dense1),a=th(a,t.dense2),a=th(a,t.dense3),a=ha(a,[7,7],[2,2],"valid"),a})}async forward(e){return this.forwardInput(await gn(e))}getDefaultModelName(){return"face_feature_extractor_model"}extractParamsFromWeightMap(e){return Ide(e)}extractParams(e){return kde(e)}};function Qm(e,t){return B(()=>X(Oe(e,t.weights),t.bias))}function Sde(e,t,n){let r=[],{extractWeights:a,getRemainingWeights:s}=cs(e),i=eE(a,r)(t,n,"fc");if(s().length!==0)throw new Error(`weights remaing after extract: ${s().length}`);return{paramMappings:r,params:{fc:i}}}function Nde(e){let t=[],n=Eo(e,t);function r(s){let i=n(`${s}/weights`,2),o=n(`${s}/bias`,1);return{weights:i,bias:o}}let a={fc:r("fc")};return hs(e,t),{params:a,paramMappings:t}}function iE(e){let t={},n={};return Object.keys(e).forEach(r=>{let a=r.startsWith("fc")?n:t;a[r]=e[r]}),{featureExtractorMap:t,classifierMap:n}}var oE=class extends ds{constructor(e,t){super(e),this._faceFeatureExtractor=t}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return B(()=>{let n=e instanceof Gh?this.faceFeatureExtractor.forwardInput(e):e;return Qm(n.as2D(n.shape[0],-1),t.fc)})}dispose(e=!0){this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return Sde(e,this.getClassifierChannelsIn(),this.getClassifierChannelsOut())}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=iE(e);return this.faceFeatureExtractor.loadFromWeightMap(t),Nde(n)}extractParams(e){let t=this.getClassifierChannelsIn(),n=this.getClassifierChannelsOut(),r=n*t+n,a=e.slice(0,e.length-r),s=e.slice(e.length-r);return this.faceFeatureExtractor.extractWeights(a),this.extractClassifierParams(s)}},v0=["neutral","happy","sad","angry","fearful","disgusted","surprised"],sv=class{constructor(e){if(this.neutral=0,this.happy=0,this.sad=0,this.angry=0,this.fearful=0,this.disgusted=0,this.surprised=0,e.length!==7)throw new Error(`FaceExpressions.constructor - expected probabilities.length to be 7, have: ${e.length}`);v0.forEach((t,n)=>{this[t]=e[n]})}asSortedArray(){return v0.map(e=>({expression:e,probability:this[e]})).sort((e,t)=>t.probability-e.probability)}},Tde=class extends oE{constructor(e=new sE){super("FaceExpressionNet",e)}forwardInput(e){return B(()=>ss(this.runNet(e)))}async forward(e){return this.forwardInput(await gn(e))}async predictExpressions(e){let t=await gn(e),n=await this.forwardInput(t),r=await Promise.all(St(n).map(async s=>{let i=s.dataSync();return s.dispose(),i}));n.dispose();let a=r.map(s=>new sv(s));return t.isBatchInput?a:a[0]}getDefaultModelName(){return"face_expression_model"}getClassifierChannelsIn(){return 256}getClassifierChannelsOut(){return 7}};function Cde(e){return e.expressions instanceof sv}function lE(e,t){return{...e,expressions:t}}function _de(e,t,n=.1,r){(Array.isArray(t)?t:[t]).forEach(a=>{let s=a instanceof sv?a:Cde(a)?a.expressions:void 0;if(!s)throw new Error("drawFaceExpressions - expected faceExpressions to be FaceExpressions | WithFaceExpressions<{}> or array thereof");let i=s.asSortedArray().filter(l=>l.probability>n),o=Vh(a)?a.detection.box.bottomLeft:r||new at(0,0);new Qx(i.map(l=>`${l.expression} (${qx(l.probability)})`),o).draw(e)})}function uE(e){return Vh(e)&&e.landmarks instanceof Wh&&e.unshiftedLandmarks instanceof Wh&&e.alignedRect instanceof Cr}function Ede(e){let t=l=>l*180/Math.PI,n=(l,p)=>Math.sqrt((l.x-p.x)**2+(l.y-p.y)**2),r={roll:void 0,pitch:void 0,yaw:void 0},a=(l,p,u)=>{let d=Math.floor(l.x-p.x),h=Math.floor(p.x-u.x);return d-h},s=(l,p)=>{let u=Math.hypot(p.x-l.x,p.y-l.y),d=p.y-l.y,h=Math.asin(d/u),c=t(h),f=Math.floor(90-c),m=p.x-l.x<0?-1:1;return f*m},i=(l,p,u)=>{let d=n(l,u),h=new at((l.x+u.x)/2,(l.y+u.y)/2),c=n(p,h),f=Math.atan(c/d),m=Math.floor(t(f)),g=h.y-p.y<0?-1:1;return m*g};if(!e||!e.positions||e.positions.length!==68)return r;let o=e.positions;return r.roll=s(o[27],o[66]),r.pitch=i(o[14],o[30],o[2]),r.yaw=a(o[14],o[33],o[2]),r}function pE(e,t){let{box:n}=e.detection,r=t.shiftBy(n.x,n.y),a=r.align(),{imageDims:s}=e.detection,i=new Cr(e.detection.score,a.rescale(s.reverse()),s),o=Ede(t);return{...e,landmarks:r,unshiftedLandmarks:t,alignedRect:i,angle:o}}var dE=class{constructor(e={}){let{drawLines:t=!0,drawPoints:n=!0,lineWidth:r,lineColor:a,pointSize:s,pointColor:i}=e;this.drawLines=t,this.drawPoints=n,this.lineWidth=r||1,this.pointSize=s||2,this.lineColor=a||"rgba(0, 255, 255, 1)",this.pointColor=i||"rgba(255, 0, 255, 1)"}},hE=class{constructor(e,t={}){this.faceLandmarks=e,this.options=new dE(t)}draw(e){let t=Za(e),{drawLines:n,drawPoints:r,lineWidth:a,lineColor:s,pointSize:i,pointColor:o}=this.options;if(n&&this.faceLandmarks instanceof B_&&(t.strokeStyle=s,t.lineWidth=a,Na(t,this.faceLandmarks.getJawOutline()),Na(t,this.faceLandmarks.getLeftEyeBrow()),Na(t,this.faceLandmarks.getRightEyeBrow()),Na(t,this.faceLandmarks.getNose()),Na(t,this.faceLandmarks.getLeftEye(),!0),Na(t,this.faceLandmarks.getRightEye(),!0),Na(t,this.faceLandmarks.getMouth(),!0)),r){t.strokeStyle=o,t.fillStyle=o;let l=p=>{t.beginPath(),t.arc(p.x,p.y,i,0,2*Math.PI),t.fill()};this.faceLandmarks.positions.forEach(l)}}};function $de(e,t){(Array.isArray(t)?t:[t]).forEach(n=>{let r=n instanceof Wh?n:uE(n)?n.landmarks:void 0;if(!r)throw new Error("drawFaceLandmarks - expected faceExpressions to be FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>> or array thereof");new hE(r).draw(e)})}function Ade(e,t){let n=nv(e,t),r=rv(e,t);function a(i,o,l){let p=r(i,o,`${l}/separable_conv0`),u=r(o,o,`${l}/separable_conv1`),d=n(i,o,1,`${l}/expansion_conv`);return{separable_conv0:p,separable_conv1:u,expansion_conv:d}}function s(i,o){let l=r(i,i,`${o}/separable_conv0`),p=r(i,i,`${o}/separable_conv1`),u=r(i,i,`${o}/separable_conv2`);return{separable_conv0:l,separable_conv1:p,separable_conv2:u}}return{extractConvParams:n,extractSeparableConvParams:r,extractReductionBlockParams:a,extractMainBlockParams:s}}function Fde(e,t){let n=[],{extractWeights:r,getRemainingWeights:a}=cs(e),{extractConvParams:s,extractSeparableConvParams:i,extractReductionBlockParams:o,extractMainBlockParams:l}=Ade(r,n),p=s(3,32,3,"entry_flow/conv_in"),u=o(32,64,"entry_flow/reduction_block_0"),d=o(64,128,"entry_flow/reduction_block_1"),h={conv_in:p,reduction_block_0:u,reduction_block_1:d},c={};ll(t,0,1).forEach(y=>{c[`main_block_${y}`]=l(128,`middle_flow/main_block_${y}`)});let f=o(128,256,"exit_flow/reduction_block"),m=i(256,512,"exit_flow/separable_conv"),g={reduction_block:f,separable_conv:m};if(a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{paramMappings:n,params:{entry_flow:h,middle_flow:c,exit_flow:g}}}function Rde(e,t){let n=Eo(e,t),r=rE(n),a=av(n);function s(o){let l=a(`${o}/separable_conv0`),p=a(`${o}/separable_conv1`),u=r(`${o}/expansion_conv`);return{separable_conv0:l,separable_conv1:p,expansion_conv:u}}function i(o){let l=a(`${o}/separable_conv0`),p=a(`${o}/separable_conv1`),u=a(`${o}/separable_conv2`);return{separable_conv0:l,separable_conv1:p,separable_conv2:u}}return{extractConvParams:r,extractSeparableConvParams:a,extractReductionBlockParams:s,extractMainBlockParams:i}}function Dde(e,t){let n=[],{extractConvParams:r,extractSeparableConvParams:a,extractReductionBlockParams:s,extractMainBlockParams:i}=Rde(e,n),o=r("entry_flow/conv_in"),l=s("entry_flow/reduction_block_0"),p=s("entry_flow/reduction_block_1"),u={conv_in:o,reduction_block_0:l,reduction_block_1:p},d={};ll(t,0,1).forEach(m=>{d[`main_block_${m}`]=i(`middle_flow/main_block_${m}`)});let h=s("exit_flow/reduction_block"),c=a("exit_flow/separable_conv"),f={reduction_block:h,separable_conv:c};return hs(e,n),{params:{entry_flow:u,middle_flow:d,exit_flow:f},paramMappings:n}}function cE(e,t,n){return X(fn(e,t.filters,n,"same"),t.bias)}function jf(e,t,n=!0){let r=n?et(e):e;return r=Qn(r,t.separable_conv0,[1,1]),r=Qn(et(r),t.separable_conv1,[1,1]),r=Vt(r,[3,3],[2,2],"same"),r=X(r,cE(e,t.expansion_conv,[2,2])),r}function Mde(e,t){let n=Qn(et(e),t.separable_conv0,[1,1]);return n=Qn(et(n),t.separable_conv1,[1,1]),n=Qn(et(n),t.separable_conv2,[1,1]),n=X(n,e),n}var Ode=class extends ds{constructor(e){super("TinyXception"),this._numMainBlocks=e}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyXception - load model before inference");return B(()=>{let n=se(e.toBatchTensor(112,!0),"float32"),r=Sd(n,[122.782,117.001,104.298]).div(255),a=et(cE(r,t.entry_flow.conv_in,[2,2]));return a=jf(a,t.entry_flow.reduction_block_0,!1),a=jf(a,t.entry_flow.reduction_block_1),ll(this._numMainBlocks,0,1).forEach(s=>{a=Mde(a,t.middle_flow[`main_block_${s}`])}),a=jf(a,t.exit_flow.reduction_block),a=et(Qn(a,t.exit_flow.separable_conv,[1,1])),a})}async forward(e){return this.forwardInput(await gn(e))}getDefaultModelName(){return"tiny_xception_model"}extractParamsFromWeightMap(e){return Dde(e,this._numMainBlocks)}extractParams(e){return Fde(e,this._numMainBlocks)}};function Lde(e){let t=[],{extractWeights:n,getRemainingWeights:r}=cs(e),a=eE(n,t),s=a(512,1,"fc/age"),i=a(512,2,"fc/gender");if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{fc:{age:s,gender:i}}}}function zde(e){let t=[],n=Eo(e,t);function r(s){let i=n(`${s}/weights`,2),o=n(`${s}/bias`,1);return{weights:i,bias:o}}let a={fc:{age:r("fc/age"),gender:r("fc/gender")}};return hs(e,t),{params:a,paramMappings:t}}var Pde=(e=>(e.FEMALE="female",e.MALE="male",e))(Pde||{}),Bde=class extends ds{constructor(e=new Ode(2)){super("AgeGenderNet"),this._faceFeatureExtractor=e}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return B(()=>{let n=e instanceof Gh?this.faceFeatureExtractor.forwardInput(e):e,r=ha(n,[7,7],[2,2],"valid").as2D(n.shape[0],-1),a=Qm(r,t.fc.age).as1D(),s=Qm(r,t.fc.gender);return{age:a,gender:s}})}forwardInput(e){return B(()=>{let{age:t,gender:n}=this.runNet(e);return{age:t,gender:ss(n)}})}async forward(e){return this.forwardInput(await gn(e))}async predictAgeAndGender(e){let t=await gn(e),n=await this.forwardInput(t),r=St(n.age),a=St(n.gender),s=r.map((o,l)=>({ageTensor:o,genderTensor:a[l]})),i=await Promise.all(s.map(async({ageTensor:o,genderTensor:l})=>{let p=o.dataSync()[0],u=l.dataSync()[0],d=u>.5,h=d?"male":"female",c=d?u:1-u;return o.dispose(),l.dispose(),{age:p,gender:h,genderProbability:c}}));return n.age.dispose(),n.gender.dispose(),t.isBatchInput?i:i[0]}getDefaultModelName(){return"age_gender_model"}dispose(e=!0){this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return Lde(e)}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=iE(e);return this.faceFeatureExtractor.loadFromWeightMap(t),zde(n)}extractParams(e){let t=e.slice(0,e.length-1539),n=e.slice(e.length-1539);return this.faceFeatureExtractor.extractWeights(t),this.extractClassifierParams(n)}},fE=class extends oE{postProcess(e,t,n){let r=n.map(({width:s,height:i})=>{let o=t/Math.max(i,s);return{width:s*o,height:i*o}}),a=r.length;return B(()=>{let s=(p,u)=>At([Bn([68],p,"float32"),Bn([68],u,"float32")],1).as2D(1,136).as1D(),i=(p,u)=>{let{width:d,height:h}=r[p];return u(d,h)?Math.abs(d-h)/2:0},o=p=>i(p,(u,d)=>u<d),l=p=>i(p,(u,d)=>d<u);return e.mul(Bn([a,136],t,"float32")).sub(At(Array.from(Array(a),(p,u)=>s(o(u),l(u))))).div(At(Array.from(Array(a),(p,u)=>s(r[u].width,r[u].height))))})}forwardInput(e){return B(()=>{let t=this.runNet(e);return this.postProcess(t,e.inputSize,e.inputDimensions.map(([n,r])=>({height:n,width:r})))})}async forward(e){return this.forwardInput(await gn(e))}async detectLandmarks(e){let t=await gn(e),n=B(()=>St(this.forwardInput(t))),r=await Promise.all(n.map(async(a,s)=>{let i=Array.from(a.dataSync()),o=i.filter((p,u)=>Zm(u)),l=i.filter((p,u)=>!Zm(u));return new B_(Array(68).fill(0).map((p,u)=>new at(o[u],l[u])),{height:t.getInputHeight(s),width:t.getInputWidth(s)})}));return n.forEach(a=>a.dispose()),t.isBatchInput?r:r[0]}getClassifierChannelsOut(){return 136}},Wde=class extends fE{constructor(e=new sE){super("FaceLandmark68Net",e)}getDefaultModelName(){return"face_landmark_68_model"}getClassifierChannelsIn(){return 256}};function Vde(e){let t=[],{extractDenseBlock3Params:n}=aE(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2")};return hs(e,t),{params:r,paramMappings:t}}function Ude(e){let t=[],{extractWeights:n,getRemainingWeights:r}=cs(e),{extractDenseBlock3Params:a}=nE(n,t),s=a(3,32,"dense0",!0),i=a(32,64,"dense1"),o=a(64,128,"dense2");if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:s,dense1:i,dense2:o}}}var Gde=class extends ds{constructor(){super("TinyFaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyFaceFeatureExtractor - load model before inference");return B(()=>{let n=se(e.toBatchTensor(112,!0),"float32"),r=Sd(n,[122.782,117.001,104.298]).div(255),a=Hf(r,t.dense0,!0);return a=Hf(a,t.dense1),a=Hf(a,t.dense2),a=ha(a,[14,14],[2,2],"valid"),a})}async forward(e){return this.forwardInput(await gn(e))}getDefaultModelName(){return"face_feature_extractor_tiny_model"}extractParamsFromWeightMap(e){return Vde(e)}extractParams(e){return Ude(e)}},Hde=class extends fE{constructor(e=new Gde){super("FaceLandmark68TinyNet",e)}getDefaultModelName(){return"face_landmark_68_tiny_model"}getClassifierChannelsIn(){return 128}};function jde(e,t){return X(z(e,t.weights),t.biases)}function iv(e,t,n,r,a="same"){let{filters:s,bias:i}=t.conv,o=fn(e,s,n,a);return o=X(o,i),o=jde(o,t.scale),r?et(o):o}function qde(e,t){return iv(e,t,[1,1],!0)}function mE(e,t){return iv(e,t,[1,1],!1)}function gE(e,t){return iv(e,t,[2,2],!0,"valid")}function Kde(e,t){function n(o,l,p){let u=e(o),d=u.length/(l*p*p);if(R_(d))throw new Error(`depth has to be an integer: ${d}, weights.length: ${u.length}, numFilters: ${l}, filterSize: ${p}`);return B(()=>Le(Ua(u,[l,d,p,p]),[2,3,1,0]))}function r(o,l,p,u){let d=n(o,l,p),h=Ye(e(l));return t.push({paramPath:`${u}/filters`},{paramPath:`${u}/bias`}),{filters:d,bias:h}}function a(o,l){let p=Ye(e(o)),u=Ye(e(o));return t.push({paramPath:`${l}/weights`},{paramPath:`${l}/biases`}),{weights:p,biases:u}}function s(o,l,p,u){let d=r(o,l,p,`${u}/conv`),h=a(l,`${u}/scale`);return{conv:d,scale:h}}function i(o,l,p,u,d=!1){let h=s((d?.5:1)*o,l,p,`${u}/conv1`),c=s(o,l,p,`${u}/conv2`);return{conv1:h,conv2:c}}return{extractConvLayerParams:s,extractResidualLayerParams:i}}function Xde(e){let{extractWeights:t,getRemainingWeights:n}=cs(e),r=[],{extractConvLayerParams:a,extractResidualLayerParams:s}=Kde(t,r),i=a(4704,32,7,"conv32_down"),o=s(9216,32,3,"conv32_1"),l=s(9216,32,3,"conv32_2"),p=s(9216,32,3,"conv32_3"),u=s(36864,64,3,"conv64_down",!0),d=s(36864,64,3,"conv64_1"),h=s(36864,64,3,"conv64_2"),c=s(36864,64,3,"conv64_3"),f=s(147456,128,3,"conv128_down",!0),m=s(147456,128,3,"conv128_1"),g=s(147456,128,3,"conv128_2"),y=s(589824,256,3,"conv256_down",!0),b=s(589824,256,3,"conv256_1"),x=s(589824,256,3,"conv256_2"),v=s(589824,256,3,"conv256_down_out"),I=B(()=>Le(Wr(t(256*128),[128,256]),[1,0]));if(r.push({paramPath:"fc"}),n().length!==0)throw new Error(`weights remaing after extract: ${n().length}`);return{params:{conv32_down:i,conv32_1:o,conv32_2:l,conv32_3:p,conv64_down:u,conv64_1:d,conv64_2:h,conv64_3:c,conv128_down:f,conv128_1:m,conv128_2:g,conv256_down:y,conv256_1:b,conv256_2:x,conv256_down_out:v,fc:I},paramMappings:r}}function Zde(e,t){let n=Eo(e,t);function r(i){let o=n(`${i}/scale/weights`,1),l=n(`${i}/scale/biases`,1);return{weights:o,biases:l}}function a(i){let o=n(`${i}/conv/filters`,4),l=n(`${i}/conv/bias`,1),p=r(i);return{conv:{filters:o,bias:l},scale:p}}function s(i){return{conv1:a(`${i}/conv1`),conv2:a(`${i}/conv2`)}}return{extractConvLayerParams:a,extractResidualLayerParams:s}}function Jde(e){let t=[],{extractConvLayerParams:n,extractResidualLayerParams:r}=Zde(e,t),a=n("conv32_down"),s=r("conv32_1"),i=r("conv32_2"),o=r("conv32_3"),l=r("conv64_down"),p=r("conv64_1"),u=r("conv64_2"),d=r("conv64_3"),h=r("conv128_down"),c=r("conv128_1"),f=r("conv128_2"),m=r("conv256_down"),g=r("conv256_1"),y=r("conv256_2"),b=r("conv256_down_out"),{fc:x}=e;if(t.push({originalPath:"fc",paramPath:"fc"}),!F_(x))throw new Error(`expected weightMap[fc] to be a Tensor2D, instead have ${x}`);let v={conv32_down:a,conv32_1:s,conv32_2:i,conv32_3:o,conv64_down:l,conv64_1:p,conv64_2:u,conv64_3:d,conv128_down:h,conv128_1:c,conv128_2:f,conv256_down:m,conv256_1:g,conv256_2:y,conv256_down_out:b,fc:x};return hs(e,t),{params:v,paramMappings:t}}function Ar(e,t){let n=qde(e,t.conv1);return n=mE(n,t.conv2),n=X(n,e),n=et(n),n}function nh(e,t){let n=gE(e,t.conv1);n=mE(n,t.conv2);let r=ha(e,2,2,"valid"),a=vt(r.shape),s=r.shape[3]!==n.shape[3];if(r.shape[1]!==n.shape[1]||r.shape[2]!==n.shape[2]){let i=[...n.shape];i[1]=1;let o=vt(i);n=it([n,o],1);let l=[...n.shape];l[2]=1;let p=vt(l);n=it([n,p],2)}return r=s?it([r,a],3):r,n=X(r,n),n=et(n),n}var Yde=class extends ds{constructor(){super("FaceRecognitionNet")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceRecognitionNet - load model before inference");return B(()=>{let n=se(e.toBatchTensor(150,!0),"float32"),r=Sd(n,[122.782,117.001,104.298]).div(255),a=gE(r,t.conv32_down);a=Vt(a,3,2,"valid"),a=Ar(a,t.conv32_1),a=Ar(a,t.conv32_2),a=Ar(a,t.conv32_3),a=nh(a,t.conv64_down),a=Ar(a,t.conv64_1),a=Ar(a,t.conv64_2),a=Ar(a,t.conv64_3),a=nh(a,t.conv128_down),a=Ar(a,t.conv128_1),a=Ar(a,t.conv128_2),a=nh(a,t.conv256_down),a=Ar(a,t.conv256_1),a=Ar(a,t.conv256_2),a=nh(a,t.conv256_down_out);let s=a.mean([1,2]);return Oe(s,t.fc)})}async forward(e){return this.forwardInput(await gn(e))}async computeFaceDescriptor(e){var t;if((t=e==null?void 0:e.shape)!=null&&t.some(s=>s<=0))return new Float32Array(128);let n=await gn(e),r=B(()=>St(this.forwardInput(n))),a=await Promise.all(r.map(s=>s.data()));return r.forEach(s=>s.dispose()),n.isBatchInput?a:a[0]}getDefaultModelName(){return"face_recognition_model"}extractParamsFromWeightMap(e){return Jde(e)}extractParams(e){return Xde(e)}};function yE(e,t){return{...e,descriptor:t}}function bE(e,t){return{...e,age:t}}function xE(e,t,n){return{...e,gender:t,genderProbability:n}}function Qde(e,t){function n(l,p){let u=Ua(e(9*l),[3,3,l,1]),d=Ye(e(l)),h=Ye(e(l)),c=Ye(e(l)),f=Ye(e(l));return t.push({paramPath:`${p}/filters`},{paramPath:`${p}/batch_norm_scale`},{paramPath:`${p}/batch_norm_offset`},{paramPath:`${p}/batch_norm_mean`},{paramPath:`${p}/batch_norm_variance`}),{filters:u,batch_norm_scale:d,batch_norm_offset:h,batch_norm_mean:c,batch_norm_variance:f}}function r(l,p,u,d,h){let c=Ua(e(l*p*u*u),[u,u,l,p]),f=Ye(e(p));return t.push({paramPath:`${d}/filters`},{paramPath:`${d}/${h?"batch_norm_offset":"bias"}`}),{filters:c,bias:f}}function a(l,p,u,d){let{filters:h,bias:c}=r(l,p,u,d,!0);return{filters:h,batch_norm_offset:c}}function s(l,p,u){let d=n(l,`${u}/depthwise_conv`),h=a(l,p,1,`${u}/pointwise_conv`);return{depthwise_conv:d,pointwise_conv:h}}function i(){let l=a(3,32,3,"mobilenetv1/conv_0"),p=s(32,64,"mobilenetv1/conv_1"),u=s(64,128,"mobilenetv1/conv_2"),d=s(128,128,"mobilenetv1/conv_3"),h=s(128,256,"mobilenetv1/conv_4"),c=s(256,256,"mobilenetv1/conv_5"),f=s(256,512,"mobilenetv1/conv_6"),m=s(512,512,"mobilenetv1/conv_7"),g=s(512,512,"mobilenetv1/conv_8"),y=s(512,512,"mobilenetv1/conv_9"),b=s(512,512,"mobilenetv1/conv_10"),x=s(512,512,"mobilenetv1/conv_11"),v=s(512,1024,"mobilenetv1/conv_12"),I=s(1024,1024,"mobilenetv1/conv_13");return{conv_0:l,conv_1:p,conv_2:u,conv_3:d,conv_4:h,conv_5:c,conv_6:f,conv_7:m,conv_8:g,conv_9:y,conv_10:b,conv_11:x,conv_12:v,conv_13:I}}function o(){let l=a(1024,256,1,"prediction_layer/conv_0"),p=a(256,512,3,"prediction_layer/conv_1"),u=a(512,128,1,"prediction_layer/conv_2"),d=a(128,256,3,"prediction_layer/conv_3"),h=a(256,128,1,"prediction_layer/conv_4"),c=a(128,256,3,"prediction_layer/conv_5"),f=a(256,64,1,"prediction_layer/conv_6"),m=a(64,128,3,"prediction_layer/conv_7"),g=r(512,12,1,"prediction_layer/box_predictor_0/box_encoding_predictor"),y=r(512,9,1,"prediction_layer/box_predictor_0/class_predictor"),b=r(1024,24,1,"prediction_layer/box_predictor_1/box_encoding_predictor"),x=r(1024,18,1,"prediction_layer/box_predictor_1/class_predictor"),v=r(512,24,1,"prediction_layer/box_predictor_2/box_encoding_predictor"),I=r(512,18,1,"prediction_layer/box_predictor_2/class_predictor"),T=r(256,24,1,"prediction_layer/box_predictor_3/box_encoding_predictor"),_=r(256,18,1,"prediction_layer/box_predictor_3/class_predictor"),E=r(256,24,1,"prediction_layer/box_predictor_4/box_encoding_predictor"),A=r(256,18,1,"prediction_layer/box_predictor_4/class_predictor"),R=r(128,24,1,"prediction_layer/box_predictor_5/box_encoding_predictor"),F=r(128,18,1,"prediction_layer/box_predictor_5/class_predictor");return{conv_0:l,conv_1:p,conv_2:u,conv_3:d,conv_4:h,conv_5:c,conv_6:f,conv_7:m,box_predictor_0:{box_encoding_predictor:g,class_predictor:y},box_predictor_1:{box_encoding_predictor:b,class_predictor:x},box_predictor_2:{box_encoding_predictor:v,class_predictor:I},box_predictor_3:{box_encoding_predictor:T,class_predictor:_},box_predictor_4:{box_encoding_predictor:E,class_predictor:A},box_predictor_5:{box_encoding_predictor:R,class_predictor:F}}}return{extractMobilenetV1Params:i,extractPredictionLayerParams:o}}function ehe(e){let t=[],{extractWeights:n,getRemainingWeights:r}=cs(e),{extractMobilenetV1Params:a,extractPredictionLayerParams:s}=Qde(n,t),i=a(),o=s(),l={extra_dim:Rc(n(5118*4),[1,5118,4])};if(t.push({paramPath:"output_layer/extra_dim"}),r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{params:{mobilenetv1:i,prediction_layer:o,output_layer:l},paramMappings:t}}function the(e,t){let n=Eo(e,t);function r(p,u,d){let h=n(`${p}/Conv2d_${u}_pointwise/weights`,4,`${d}/filters`),c=n(`${p}/Conv2d_${u}_pointwise/convolution_bn_offset`,1,`${d}/batch_norm_offset`);return{filters:h,batch_norm_offset:c}}function a(p){let u=`mobilenetv1/conv_${p}`,d=`MobilenetV1/Conv2d_${p}_depthwise`,h=`${u}/depthwise_conv`,c=`${u}/pointwise_conv`,f=n(`${d}/depthwise_weights`,4,`${h}/filters`),m=n(`${d}/BatchNorm/gamma`,1,`${h}/batch_norm_scale`),g=n(`${d}/BatchNorm/beta`,1,`${h}/batch_norm_offset`),y=n(`${d}/BatchNorm/moving_mean`,1,`${h}/batch_norm_mean`),b=n(`${d}/BatchNorm/moving_variance`,1,`${h}/batch_norm_variance`);return{depthwise_conv:{filters:f,batch_norm_scale:m,batch_norm_offset:g,batch_norm_mean:y,batch_norm_variance:b},pointwise_conv:r("MobilenetV1",p,c)}}function s(){return{conv_0:r("MobilenetV1",0,"mobilenetv1/conv_0"),conv_1:a(1),conv_2:a(2),conv_3:a(3),conv_4:a(4),conv_5:a(5),conv_6:a(6),conv_7:a(7),conv_8:a(8),conv_9:a(9),conv_10:a(10),conv_11:a(11),conv_12:a(12),conv_13:a(13)}}function i(p,u){let d=n(`${p}/weights`,4,`${u}/filters`),h=n(`${p}/biases`,1,`${u}/bias`);return{filters:d,bias:h}}function o(p){let u=i(`Prediction/BoxPredictor_${p}/BoxEncodingPredictor`,`prediction_layer/box_predictor_${p}/box_encoding_predictor`),d=i(`Prediction/BoxPredictor_${p}/ClassPredictor`,`prediction_layer/box_predictor_${p}/class_predictor`);return{box_encoding_predictor:u,class_predictor:d}}function l(){return{conv_0:r("Prediction",0,"prediction_layer/conv_0"),conv_1:r("Prediction",1,"prediction_layer/conv_1"),conv_2:r("Prediction",2,"prediction_layer/conv_2"),conv_3:r("Prediction",3,"prediction_layer/conv_3"),conv_4:r("Prediction",4,"prediction_layer/conv_4"),conv_5:r("Prediction",5,"prediction_layer/conv_5"),conv_6:r("Prediction",6,"prediction_layer/conv_6"),conv_7:r("Prediction",7,"prediction_layer/conv_7"),box_predictor_0:o(0),box_predictor_1:o(1),box_predictor_2:o(2),box_predictor_3:o(3),box_predictor_4:o(4),box_predictor_5:o(5)}}return{extractMobilenetV1Params:s,extractPredictionLayerParams:l}}function nhe(e){let t=[],{extractMobilenetV1Params:n,extractPredictionLayerParams:r}=the(e,t),a=e["Output/extra_dim"];if(t.push({originalPath:"Output/extra_dim",paramPath:"output_layer/extra_dim"}),!Id(a))throw new Error(`expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have ${a}`);let s={mobilenetv1:n(),prediction_layer:r(),output_layer:{extra_dim:a}};return hs(e,t),{params:s,paramMappings:t}}function Dr(e,t,n){return B(()=>{let r=fn(e,t.filters,n,"same");return r=X(r,t.batch_norm_offset),an(r,0,6)})}var rhe=.0010000000474974513;function ahe(e,t,n){return B(()=>{let r=xo(e,t.filters,n,"same");return r=bo(r,t.batch_norm_mean,t.batch_norm_variance,t.batch_norm_offset,t.batch_norm_scale,rhe),an(r,0,6)})}function she(e){return[2,4,6,12].some(t=>t===e)?[2,2]:[1,1]}function ihe(e,t){return B(()=>{let n,r=Dr(e,t.conv_0,[2,2]);if([t.conv_1,t.conv_2,t.conv_3,t.conv_4,t.conv_5,t.conv_6,t.conv_7,t.conv_8,t.conv_9,t.conv_10,t.conv_11,t.conv_12,t.conv_13].forEach((a,s)=>{let i=s+1,o=she(i);r=ahe(r,a.depthwise_conv,o),r=Dr(r,a.pointwise_conv,[1,1]),i===11&&(n=r)}),n===null)throw new Error("mobileNetV1 - output of conv layer 11 is null");return{out:r,conv11:n}})}function ohe(e,t,n){let r=e.arraySync(),a=Math.min(r[t][0],r[t][2]),s=Math.min(r[t][1],r[t][3]),i=Math.max(r[t][0],r[t][2]),o=Math.max(r[t][1],r[t][3]),l=Math.min(r[n][0],r[n][2]),p=Math.min(r[n][1],r[n][3]),u=Math.max(r[n][0],r[n][2]),d=Math.max(r[n][1],r[n][3]),h=(i-a)*(o-s),c=(u-l)*(d-p);if(h<=0||c<=0)return 0;let f=Math.max(a,l),m=Math.max(s,p),g=Math.min(i,u),y=Math.min(o,d),b=Math.max(g-f,0)*Math.max(y-m,0);return b/(h+c-b)}function lhe(e,t,n,r,a){let s=e.shape[0],i=Math.min(n,s),o=t.map((u,d)=>({score:u,boxIndex:d})).filter(u=>u.score>a).sort((u,d)=>d.score-u.score),l=u=>u<=r?1:0,p=[];return o.forEach(u=>{if(p.length>=i)return;let d=u.score;for(let h=p.length-1;h>=0;--h){let c=ohe(e,u.boxIndex,p[h]);if(c!==0&&(u.score*=l(c),u.score<=a))break}d===u.score&&p.push(u.boxIndex)}),p}function uhe(e){let t=St(Le(e,[1,0])),n=[de(t[2],t[0]),de(t[3],t[1])],r=[X(t[0],fe(n[0],2)),X(t[1],fe(n[1],2))];return{sizes:n,centers:r}}function phe(e,t){let{sizes:n,centers:r}=uhe(e),a=St(Le(t,[1,0])),s=fe(z(sn(fe(a[2],5)),n[0]),2),i=X(z(fe(a[0],10),n[0]),r[0]),o=fe(z(sn(fe(a[3],5)),n[1]),2),l=X(z(fe(a[1],10),n[1]),r[1]);return Le(At([de(i,s),de(l,o),X(i,s),X(l,o)]),[1,0])}function dhe(e,t,n){return B(()=>{let r=e.shape[0],a=phe(P(Pn(n.extra_dim,[r,1,1]),[-1,4]),P(e,[-1,4]));a=P(a,[r,a.shape[0]/r,4]);let s=pr(Ue(t,[0,0,1],[-1,-1,-1])),i=Ue(s,[0,0,0],[-1,-1,1]);i=P(i,[r,i.shape[1]]);let o=St(a),l=St(i);return{boxes:o,scores:l}})}function Mo(e,t){return B(()=>{let n=e.shape[0],r=P(np(e,t.box_encoding_predictor),[n,-1,1,4]),a=P(np(e,t.class_predictor),[n,-1,3]);return{boxPredictionEncoding:r,classPrediction:a}})}function hhe(e,t,n){return B(()=>{let r=Dr(e,n.conv_0,[1,1]),a=Dr(r,n.conv_1,[2,2]),s=Dr(a,n.conv_2,[1,1]),i=Dr(s,n.conv_3,[2,2]),o=Dr(i,n.conv_4,[1,1]),l=Dr(o,n.conv_5,[2,2]),p=Dr(l,n.conv_6,[1,1]),u=Dr(p,n.conv_7,[2,2]),d=Mo(t,n.box_predictor_0),h=Mo(e,n.box_predictor_1),c=Mo(a,n.box_predictor_2),f=Mo(i,n.box_predictor_3),m=Mo(l,n.box_predictor_4),g=Mo(u,n.box_predictor_5),y=it([d.boxPredictionEncoding,h.boxPredictionEncoding,c.boxPredictionEncoding,f.boxPredictionEncoding,m.boxPredictionEncoding,g.boxPredictionEncoding],1),b=it([d.classPrediction,h.classPrediction,c.classPrediction,f.classPrediction,m.classPrediction,g.classPrediction],1);return{boxPredictions:y,classPredictions:b}})}var vf=class{constructor({minConfidence:e,maxResults:t}={}){if(this._name="SsdMobilenetv1Options",this._minConfidence=e||.5,this._maxResults=t||100,typeof this._minConfidence!="number"||this._minConfidence<=0||this._minConfidence>=1)throw new Error(`${this._name} - expected minConfidence to be a number between 0 and 1`);if(typeof this._maxResults!="number")throw new Error(`${this._name} - expected maxResults to be a number`)}get minConfidence(){return this._minConfidence}get maxResults(){return this._maxResults}},che=class extends ds{constructor(){super("SsdMobilenetv1")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("SsdMobilenetv1 - load model before inference");return B(()=>{let n=se(e.toBatchTensor(512,!1),"float32"),r=de(fe(n,127.5),1),a=ihe(r,t.mobilenetv1),{boxPredictions:s,classPredictions:i}=hhe(a.out,a.conv11,t.prediction_layer);return dhe(s,i,t.output_layer)})}async forward(e){return this.forwardInput(await gn(e))}async locateFaces(e,t={}){let{maxResults:n,minConfidence:r}=new vf(t),a=await gn(e),{boxes:s,scores:i}=this.forwardInput(a),o=s[0],l=i[0];for(let y=1;y<s.length;y++)s[y].dispose(),i[y].dispose();let p=Array.from(l.dataSync()),u=lhe(o,p,n,.5,r),d=a.getReshapedInputDimensions(0),h=a.inputSize,c=h/d.width,f=h/d.height,m=o.arraySync(),g=u.map(y=>{let[b,x]=[Math.max(0,m[y][0]),Math.min(1,m[y][2])].map(T=>T*f),[v,I]=[Math.max(0,m[y][1]),Math.min(1,m[y][3])].map(T=>T*c);return new Cr(p[y],new P_(v,b,I-v,x-b),{height:a.getInputHeight(0),width:a.getInputWidth(0)})});return o.dispose(),l.dispose(),g}getDefaultModelName(){return"ssd_mobilenetv1_model"}extractParamsFromWeightMap(e){return nhe(e)}extractParams(e){return ehe(e)}},fhe=.4,mhe=[new at(.738768,.874946),new at(2.42204,2.65704),new at(4.30971,7.04493),new at(10.246,4.59428),new at(12.6868,11.8741)],ghe=[new at(1.603231,2.094468),new at(6.041143,7.080126),new at(2.882459,3.518061),new at(4.266906,5.178857),new at(9.041765,10.66308)],yhe=[117.001,114.697,97.404],bhe="tiny_yolov2_model",xhe="tiny_yolov2_separable_conv_model",rh=e=>typeof e=="number";function vhe(e){if(!e)throw new Error(`invalid config: ${e}`);if(typeof e.withSeparableConvs!="boolean")throw new Error(`config.withSeparableConvs has to be a boolean, have: ${e.withSeparableConvs}`);if(!rh(e.iouThreshold)||e.iouThreshold<0||e.iouThreshold>1)throw new Error(`config.iouThreshold has to be a number between [0, 1], have: ${e.iouThreshold}`);if(!Array.isArray(e.classes)||!e.classes.length||!e.classes.every(t=>typeof t=="string"))throw new Error(`config.classes has to be an array class names: string[], have: ${JSON.stringify(e.classes)}`);if(!Array.isArray(e.anchors)||!e.anchors.length||!e.anchors.map(t=>t||{}).every(t=>rh(t.x)&&rh(t.y)))throw new Error(`config.anchors has to be an array of { x: number, y: number }, have: ${JSON.stringify(e.anchors)}`);if(e.meanRgb&&(!Array.isArray(e.meanRgb)||e.meanRgb.length!==3||!e.meanRgb.every(rh)))throw new Error(`config.meanRgb has to be an array of shape [number, number, number], have: ${JSON.stringify(e.meanRgb)}`)}function ov(e){return B(()=>{let t=z(e,we(.10000000149011612));return X(et(de(e,t)),t)})}function wa(e,t){return B(()=>{let n=_r(e,[[0,0],[1,1],[1,1],[0,0]]);return n=fn(n,t.conv.filters,[1,1],"valid"),n=de(n,t.bn.sub),n=z(n,t.bn.truediv),n=X(n,t.conv.bias),ov(n)})}function ka(e,t){return B(()=>{let n=_r(e,[[0,0],[1,1],[1,1],[0,0]]);return n=yu(n,t.depthwise_filter,t.pointwise_filter,[1,1],"valid"),n=X(n,t.bias),ov(n)})}function whe(e,t){let n=nv(e,t);function r(i,o){let l=Ye(e(i)),p=Ye(e(i));return t.push({paramPath:`${o}/sub`},{paramPath:`${o}/truediv`}),{sub:l,truediv:p}}function a(i,o,l){let p=n(i,o,3,`${l}/conv`),u=r(o,`${l}/bn`);return{conv:p,bn:u}}let s=rv(e,t);return{extractConvParams:n,extractConvWithBatchNormParams:a,extractSeparableConvParams:s}}function khe(e,t,n,r){let{extractWeights:a,getRemainingWeights:s}=cs(e),i=[],{extractConvParams:o,extractConvWithBatchNormParams:l,extractSeparableConvParams:p}=whe(a,i),u;if(t.withSeparableConvs){let[d,h,c,f,m,g,y,b,x]=r,v=t.isFirstLayerConv2d?o(d,h,3,"conv0"):p(d,h,"conv0"),I=p(h,c,"conv1"),T=p(c,f,"conv2"),_=p(f,m,"conv3"),E=p(m,g,"conv4"),A=p(g,y,"conv5"),R=b?p(y,b,"conv6"):void 0,F=x?p(b,x,"conv7"):void 0,S=o(x||b||y,5*n,1,"conv8");u={conv0:v,conv1:I,conv2:T,conv3:_,conv4:E,conv5:A,conv6:R,conv7:F,conv8:S}}else{let[d,h,c,f,m,g,y,b,x]=r,v=l(d,h,"conv0"),I=l(h,c,"conv1"),T=l(c,f,"conv2"),_=l(f,m,"conv3"),E=l(m,g,"conv4"),A=l(g,y,"conv5"),R=l(y,b,"conv6"),F=l(b,x,"conv7"),S=o(x,5*n,1,"conv8");u={conv0:v,conv1:I,conv2:T,conv3:_,conv4:E,conv5:A,conv6:R,conv7:F,conv8:S}}if(s().length!==0)throw new Error(`weights remaing after extract: ${s().length}`);return{params:u,paramMappings:i}}function Ihe(e,t){let n=Eo(e,t);function r(o){let l=n(`${o}/sub`,1),p=n(`${o}/truediv`,1);return{sub:l,truediv:p}}function a(o){let l=n(`${o}/filters`,4),p=n(`${o}/bias`,1);return{filters:l,bias:p}}function s(o){let l=a(`${o}/conv`),p=r(`${o}/bn`);return{conv:l,bn:p}}let i=av(n);return{extractConvParams:a,extractConvWithBatchNormParams:s,extractSeparableConvParams:i}}function She(e,t){let n=[],{extractConvParams:r,extractConvWithBatchNormParams:a,extractSeparableConvParams:s}=Ihe(e,n),i;if(t.withSeparableConvs){let o=t.filterSizes&&t.filterSizes.length||9;i={conv0:t.isFirstLayerConv2d?r("conv0"):s("conv0"),conv1:s("conv1"),conv2:s("conv2"),conv3:s("conv3"),conv4:s("conv4"),conv5:s("conv5"),conv6:o>7?s("conv6"):void 0,conv7:o>8?s("conv7"):void 0,conv8:r("conv8")}}else i={conv0:a("conv0"),conv1:a("conv1"),conv2:a("conv2"),conv3:a("conv3"),conv4:a("conv4"),conv5:a("conv5"),conv6:a("conv6"),conv7:a("conv7"),conv8:r("conv8")};return hs(e,n),{params:i,paramMappings:n}}var lv=class{constructor({inputSize:e,scoreThreshold:t}={}){if(this._name="TinyYolov2Options",this._inputSize=e||416,this._scoreThreshold=t||.5,typeof this._inputSize!="number"||this._inputSize%32!==0)throw new Error(`${this._name} - expected inputSize to be a number divisible by 32`);if(typeof this._scoreThreshold!="number"||this._scoreThreshold<=0||this._scoreThreshold>=1)throw new Error(`${this._name} - expected scoreThreshold to be a number between 0 and 1`)}get inputSize(){return this._inputSize}get scoreThreshold(){return this._scoreThreshold}},vE=class wE extends ds{constructor(t){super("TinyYolov2"),vhe(t),this._config=t}get config(){return this._config}get withClassScores(){return this.config.withClassScores||this.config.classes.length>1}get boxEncodingSize(){return 5+(this.withClassScores?this.config.classes.length:0)}runTinyYolov2(t,n){let r=wa(t,n.conv0);return r=Vt(r,[2,2],[2,2],"same"),r=wa(r,n.conv1),r=Vt(r,[2,2],[2,2],"same"),r=wa(r,n.conv2),r=Vt(r,[2,2],[2,2],"same"),r=wa(r,n.conv3),r=Vt(r,[2,2],[2,2],"same"),r=wa(r,n.conv4),r=Vt(r,[2,2],[2,2],"same"),r=wa(r,n.conv5),r=Vt(r,[2,2],[1,1],"same"),r=wa(r,n.conv6),r=wa(r,n.conv7),np(r,n.conv8,"valid",!1)}runMobilenet(t,n){let r=this.config.isFirstLayerConv2d?ov(np(t,n.conv0,"valid",!1)):ka(t,n.conv0);return r=Vt(r,[2,2],[2,2],"same"),r=ka(r,n.conv1),r=Vt(r,[2,2],[2,2],"same"),r=ka(r,n.conv2),r=Vt(r,[2,2],[2,2],"same"),r=ka(r,n.conv3),r=Vt(r,[2,2],[2,2],"same"),r=ka(r,n.conv4),r=Vt(r,[2,2],[2,2],"same"),r=ka(r,n.conv5),r=Vt(r,[2,2],[1,1],"same"),r=n.conv6?ka(r,n.conv6):r,r=n.conv7?ka(r,n.conv7):r,np(r,n.conv8,"valid",!1)}forwardInput(t,n){let{params:r}=this;if(!r)throw new Error("TinyYolov2 - load model before inference");return B(()=>{let a=se(t.toBatchTensor(n,!1),"float32");return a=this.config.meanRgb?Sd(a,this.config.meanRgb):a,a=a.div(255),this.config.withSeparableConvs?this.runMobilenet(a,r):this.runTinyYolov2(a,r)})}async forward(t,n){return this.forwardInput(await gn(t),n)}async detect(t,n={}){let{inputSize:r,scoreThreshold:a}=new lv(n),s=await gn(t),i=await this.forwardInput(s,r),o=B(()=>St(i)[0].expandDims()),l={width:s.getInputWidth(0),height:s.getInputHeight(0)},p=await this.extractBoxes(o,s.getReshapedInputDimensions(0),a);i.dispose(),o.dispose();let u=p.map(f=>f.box),d=p.map(f=>f.score),h=p.map(f=>f.classScore),c=p.map(f=>this.config.classes[f.label]);return lde(u.map(f=>f.rescale(r)),d,this.config.iouThreshold,!0).map(f=>new O_(d[f],h[f],c[f],u[f],l))}getDefaultModelName(){return""}extractParamsFromWeightMap(t){return She(t,this.config)}extractParams(t){let n=this.config.filterSizes||wE.DEFAULT_FILTER_SIZES,r=n?n.length:void 0;if(r!==7&&r!==8&&r!==9)throw new Error(`TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found ${r} filterSizes in config`);return khe(t,this.config,this.boxEncodingSize,n)}async extractBoxes(t,n,r){let{width:a,height:s}=n,i=Math.max(a,s),o=i/a,l=i/s,p=t.shape[1],u=this.config.anchors.length,[d,h,c]=B(()=>{let y=t.reshape([p,p,u,this.boxEncodingSize]),b=y.slice([0,0,0,0],[p,p,u,4]),x=y.slice([0,0,0,4],[p,p,u,1]),v=this.withClassScores?ss(y.slice([0,0,0,5],[p,p,u,this.config.classes.length]),3):we(0);return[b,x,v]}),f=[],m=await h.array(),g=await d.array();for(let y=0;y<p;y++)for(let b=0;b<p;b++)for(let x=0;x<u;x++){let v=Gf(m[y][b][x][0]);if(!r||v>r){let I=(b+Gf(g[y][b][x][0]))/p*o,T=(y+Gf(g[y][b][x][1]))/p*l,_=Math.exp(g[y][b][x][2])*this.config.anchors[x].x/p*o,E=Math.exp(g[y][b][x][3])*this.config.anchors[x].y/p*l,A=I-_/2,R=T-E/2,F={row:y,col:b,anchor:x},{classScore:S,label:M}=this.withClassScores?await this.extractPredictedClass(c,F):{classScore:1,label:0};f.push({box:new M_(A,R,A+_,R+E),score:v,classScore:v*S,label:M,...F})}}return d.dispose(),h.dispose(),c.dispose(),f}async extractPredictedClass(t,n){let{row:r,col:a,anchor:s}=n,i=await t.array();return Array(this.config.classes.length).fill(0).map((o,l)=>i[r][a][s][l]).map((o,l)=>({classScore:o,label:l})).reduce((o,l)=>o.classScore>l.classScore?o:l)}};vE.DEFAULT_FILTER_SIZES=[3,16,32,64,128,256,512,1024,1024];var kE=vE,Nhe=class extends kE{constructor(e=!0){let t={withSeparableConvs:e,iouThreshold:fhe,classes:["face"],...e?{anchors:ghe,meanRgb:yhe}:{anchors:mhe,withClassScores:!0}};super(t)}get withSeparableConvs(){return this.config.withSeparableConvs}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map(n=>new Cr(n.score,n.relativeBox,{width:n.imageWidth,height:n.imageHeight}))}getDefaultModelName(){return this.withSeparableConvs?xhe:bhe}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}},The=class extends lv{constructor(){super(...arguments),this._name="TinyFaceDetectorOptions"}},Nd=class{async then(e){return e(await this.run())}async run(){throw new Error("ComposableTask - run is not implemented")}};async function wf(e,t,n,r,a=({alignedRect:s})=>s){let s=e.map(l=>uE(l)?a(l):l.detection),i=r||(t instanceof Fe?await tv(t,s):await ev(t,s)),o=await n(i);return i.forEach(l=>l instanceof Fe&&l.dispose()),o}async function uv(e,t,n,r,a){return wf([e],t,async s=>n(s[0]),r,a)}var Che=.4,_he=[new at(1.603231,2.094468),new at(6.041143,7.080126),new at(2.882459,3.518061),new at(4.266906,5.178857),new at(9.041765,10.66308)],Ehe=[117.001,114.697,97.404],$he=class extends kE{constructor(){let e={withSeparableConvs:!0,iouThreshold:Che,classes:["face"],anchors:_he,meanRgb:Ehe,isFirstLayerConv2d:!0,filterSizes:[3,16,32,64,128,256,512]};super(e)}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map(n=>new Cr(n.score,n.relativeBox,{width:n.imageWidth,height:n.imageHeight}))}getDefaultModelName(){return"tiny_face_detector_model"}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}},kr={ssdMobilenetv1:new che,tinyFaceDetector:new $he,tinyYolov2:new Nhe,faceLandmark68Net:new Wde,faceLandmark68TinyNet:new Hde,faceRecognitionNet:new Yde,faceExpressionNet:new Tde,ageGenderNet:new Bde},IE=class extends Nd{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},pv=class extends IE{async run(){let e=await this.parentTask,t=await wf(e,this.input,async n=>Promise.all(n.map(r=>kr.faceExpressionNet.predictExpressions(r))),this.extractedFaces);return e.map((n,r)=>lE(n,t[r]))}withAgeAndGender(){return new fv(this,this.input)}},dv=class extends IE{async run(){let e=await this.parentTask;if(!e)return;let t=await uv(e,this.input,n=>kr.faceExpressionNet.predictExpressions(n),this.extractedFaces);return lE(e,t)}withAgeAndGender(){return new mv(this,this.input)}},hv=class extends pv{withAgeAndGender(){return new gv(this,this.input)}withFaceDescriptors(){return new bv(this,this.input)}},cv=class extends dv{withAgeAndGender(){return new yv(this,this.input)}withFaceDescriptor(){return new xv(this,this.input)}},SE=class extends Nd{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},fv=class extends SE{async run(){let e=await this.parentTask,t=await wf(e,this.input,async n=>Promise.all(n.map(r=>kr.ageGenderNet.predictAgeAndGender(r))),this.extractedFaces);return e.map((n,r)=>{let{age:a,gender:s,genderProbability:i}=t[r];return bE(xE(n,s,i),a)})}withFaceExpressions(){return new pv(this,this.input)}},mv=class extends SE{async run(){let e=await this.parentTask;if(!e)return;let{age:t,gender:n,genderProbability:r}=await uv(e,this.input,a=>kr.ageGenderNet.predictAgeAndGender(a),this.extractedFaces);return bE(xE(e,n,r),t)}withFaceExpressions(){return new dv(this,this.input)}},gv=class extends fv{withFaceExpressions(){return new hv(this,this.input)}withFaceDescriptors(){return new bv(this,this.input)}},yv=class extends mv{withFaceExpressions(){return new cv(this,this.input)}withFaceDescriptor(){return new xv(this,this.input)}},NE=class extends Nd{constructor(e,t){super(),this.parentTask=e,this.input=t}},bv=class extends NE{async run(){let e=await this.parentTask;return(await wf(e,this.input,t=>Promise.all(t.map(n=>kr.faceRecognitionNet.computeFaceDescriptor(n))),null,t=>t.landmarks.align(null,{useDlibAlignment:!0}))).map((t,n)=>yE(e[n],t))}withFaceExpressions(){return new hv(this,this.input)}withAgeAndGender(){return new gv(this,this.input)}},xv=class extends NE{async run(){let e=await this.parentTask;if(!e)return;let t=await uv(e,this.input,n=>kr.faceRecognitionNet.computeFaceDescriptor(n),null,n=>n.landmarks.align(null,{useDlibAlignment:!0}));return yE(e,t)}withFaceExpressions(){return new cv(this,this.input)}withAgeAndGender(){return new yv(this,this.input)}},TE=class extends Nd{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.useTinyLandmarkNet=n}get landmarkNet(){return this.useTinyLandmarkNet?kr.faceLandmark68TinyNet:kr.faceLandmark68Net}},Ahe=class extends TE{async run(){let e=await this.parentTask,t=e.map(a=>a.detection),n=this.input instanceof Fe?await tv(this.input,t):await ev(this.input,t),r=await Promise.all(n.map(a=>this.landmarkNet.detectLandmarks(a)));return n.forEach(a=>a instanceof Fe&&a.dispose()),e.filter((a,s)=>r[s]).map((a,s)=>pE(a,r[s]))}withFaceExpressions(){return new hv(this,this.input)}withAgeAndGender(){return new gv(this,this.input)}withFaceDescriptors(){return new bv(this,this.input)}},Fhe=class extends TE{async run(){let e=await this.parentTask;if(!e)return;let{detection:t}=e,n=this.input instanceof Fe?await tv(this.input,[t]):await ev(this.input,[t]),r=await this.landmarkNet.detectLandmarks(n[0]);return n.forEach(a=>a instanceof Fe&&a.dispose()),pE(e,r)}withFaceExpressions(){return new cv(this,this.input)}withAgeAndGender(){return new yv(this,this.input)}withFaceDescriptor(){return new xv(this,this.input)}},CE=class extends Nd{constructor(e,t=new vf){super(),this.input=e,this.options=t}},Rhe=class extends CE{async run(){let{input:e,options:t}=this,n;if(t instanceof The)n=kr.tinyFaceDetector.locateFaces(e,t);else if(t instanceof vf)n=kr.ssdMobilenetv1.locateFaces(e,t);else if(t instanceof lv)n=kr.tinyYolov2.locateFaces(e,t);else throw new Error("detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | TinyYolov2Options");return n}runAndExtendWithFaceDetections(){return new Promise((e,t)=>{this.run().then(n=>e(n.map(r=>W_({},r)))).catch(n=>t(n))})}withFaceLandmarks(e=!1){return new Ahe(this.runAndExtendWithFaceDetections(),this.input,e)}withFaceExpressions(){return new pv(this.runAndExtendWithFaceDetections(),this.input)}withAgeAndGender(){return new fv(this.runAndExtendWithFaceDetections(),this.input)}},Dhe=class extends CE{async run(){let e=await new Rhe(this.input,this.options),t=e[0];return e.forEach(n=>{n.score>t.score&&(t=n)}),t}runAndExtendWithFaceDetection(){return new Promise(async e=>{let t=await this.run();e(t?W_({},t):void 0)})}withFaceLandmarks(e=!1){return new Fhe(this.runAndExtendWithFaceDetection(),this.input,e)}withFaceExpressions(){return new dv(this.runAndExtendWithFaceDetection(),this.input)}withAgeAndGender(){return new mv(this.runAndExtendWithFaceDetection(),this.input)}};function Mhe(e,t=new vf){return new Dhe(e,t)}export{Mhe as _,The as f,kr as r};
